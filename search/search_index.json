{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prove","text":"<p>A programming language that fights back against AI slop and code scraping.</p> <p>Prove is a strongly typed, compiler-driven language where contracts generate tests, intent verbs enforce purity, and the compiler rejects code that can't demonstrate understanding. Source is stored as binary AST \u2014 unscrapable, unnormalizable, unlicensed for training. If it compiles, the author understood what they wrote. If it's AI-generated, it won't.</p> <pre><code>transforms add(a Integer, b Integer) Integer\n  ensures result == a + b\n  proof\n    correctness: result is the sum of a and b\nfrom\n    a + b\n</code></pre> <p>The <code>ensures</code> clause declares guarantees. The <code>proof</code> block explains why they hold. The <code>transforms</code> verb guarantees purity. The compiler enforces every contract \u2014 and none of it can be faked by autocomplete.</p>"},{"location":"#why-prove","title":"Why Prove?","text":"Problem How Prove solves it AI scrapes your code for training Binary AST format + anti-training license + semantic normalization AI slop PRs waste maintainer time Compiler rejects code without proof obligations and intent Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit Null/nil crashes No null \u2014 <code>Option&lt;T&gt;</code> enforced by compiler \"I forgot an edge case\" Compiler generates edge cases from types Runtime type errors Refinement types catch invalid values at compile time Contracts without proof <code>ensures</code> without <code>proof</code> is a compile error (E390)"},{"location":"#quick-start","title":"Quick Start","text":"<p>Requirements: Python 3.11+, gcc or clang</p> <pre><code># Install\npip install -e \".[dev]\"\n\n# Create a project\nprove new hello\n\n# Build and run\ncd hello\nprove build\n./build/hello\n\n# Type-check only\nprove check\n\n# Run auto-generated tests\nprove test\n</code></pre>"},{"location":"#language-tour","title":"Language Tour","text":""},{"location":"#intent-verbs","title":"Intent Verbs","text":"<p>Every function declares its purpose. The compiler enforces it.</p> <pre><code>transforms area(s Shape) Decimal          // pure computation \u2014 no IO\nfrom\n    match s\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n\nvalidates email(address String)           // pure boolean check\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ninputs users(db Database) List&lt;User&gt;!     // reads from external world, can fail\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)               // writes to external world\nfrom\n    write(stdout, message)\n</code></pre> <p>The same name can exist with different verbs \u2014 the compiler resolves which to call from context:</p> <pre><code>validates email(address String)           // check if valid\ntransforms email(raw String) Email        // convert to Email type\ninputs email(user_id Integer) Email!      // fetch from database\n</code></pre>"},{"location":"#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1..65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T         // no Option needed \u2014 emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"#contracts-and-proofs","title":"Contracts and Proofs","text":"<p>Functions declare what they guarantee. The compiler verifies or tests it.</p> <pre><code>transforms apply_discount(discount Discount, amount Price) Price\n  ensures result &gt;= 0\n  ensures result &lt;= amount\n  proof\n    non_negative: FlatOff is clamped to zero, PercentOff rate is 0..1\n    bounded: every discount path subtracts from amount, never adds\nfrom\n    match discount\n        FlatOff(off)      =&gt; max(0, amount - off)\n        PercentOff(rate)  =&gt; amount * (1 - rate)\n</code></pre>"},{"location":"#no-loops-functional-iteration","title":"No Loops \u2014 Functional Iteration","text":"<pre><code>names as List&lt;String&gt; = map(users, |u| u.name)\nactive as List&lt;User&gt; = filter(users, |u| u.active)\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Errors are values. <code>!</code> propagates failures. No exceptions.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\nfrom\n    config as Config = load(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"#complete-example","title":"Complete Example","text":"<p>A RESTful inventory service demonstrating the full feature set:</p> <pre><code>module InventoryService\n    narrative: \"\"\"\n    Products are added to inventory with validated stock levels.\n    Orders consume stock. The system ensures stock never goes negative\n    and all monetary calculations use exact decimal arithmetic.\n    \"\"\"\n\ntype Port is Integer:[16 Unsigned] where 1..65535\ntype Price is Decimal:[128 Scale:2] where &gt;= 0\ntype Sku is String where matches(/^[A-Z]{2,4}-[0-9]{4,8}$/)\n\ntype Product is\n    sku Sku\n    name String\n    price Price\n    stock Quantity\n\n/// Checks whether every item in an order can be fulfilled.\nvalidates fulfillable(order Order)\nfrom\n    all(order.items, |item| in_stock(item.product, item.quantity))\n\n/// Places an order: validates stock, calculates total, deducts inventory.\noutputs place_order(db Database, order Order, tax TaxRule) Order!\n  requires fulfillable(order)\n  ensures result.status == Confirmed\n  proof\n    fulfillment: requires clause guarantees stock sufficiency\n                 before deduction, so stock never goes negative\nfrom\n    total as Price = calculate_total(order.items, None, tax)\n    confirmed as Order = Order(order.id, order.items, Confirmed, total)\n    insert(db, \"orders\", confirmed)!\n    deduct_stock(all_products(db)!, order.items) |&gt; update_all(db, \"products\")!\n    confirmed\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\nfrom\n    Get(\"/health\")   =&gt; ok(\"healthy\")\n    Get(\"/products\") =&gt; all_products(db)! |&gt; encode |&gt; ok\n    Post(\"/orders\")  =&gt; parse_order(body)! |&gt; place_order(db, tax)! |&gt; encode |&gt; created\n    _                =&gt; not_found()\n\nmain() Result&lt;Unit, Error&gt;!\nfrom\n    cfg as Config = load_config(\"inventory.yaml\")!\n    db as Database = connect(cfg.db_url)!\n    server as Server = new_server()\n    route(server, \"/\", request)\n    listen(server, cfg.port)!\n</code></pre>"},{"location":"#compiler-pipeline","title":"Compiler Pipeline","text":"<pre><code>Source (.prv) \u2192 Lexer \u2192 Parser \u2192 Checker \u2192 Prover \u2192 C Emitter \u2192 gcc/clang \u2192 Native Binary\n</code></pre>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>tree-sitter-prove \u2014 Tree-sitter grammar for editor syntax highlighting</li> <li>chroma-lexer-prove \u2014 Chroma lexer for Gitea/Hugo code rendering</li> </ul>"},{"location":"#status","title":"Status","text":"<p>v0.1.0 \u2014 the core compilation pipeline works end-to-end. The compiler lexes, parses, type-checks, verifies proof obligations, emits C, and produces native binaries. 326 tests pass across every stage.</p>"},{"location":"#license","title":"License","text":"<p>Prove Source License v1.0 \u2014 permissive for developers, prohibits use as AI training data.</p>"},{"location":"ai-resistance/","title":"AI Resistance","text":""},{"location":"ai-resistance/#phase-1-generation-resistance","title":"Phase 1 \u2014 Generation Resistance","text":"<p>AI models generate code by pattern-matching on statistical regularities in training data. To resist AI generation, a language needs correctness to require deep, holistic understanding \u2014 local patterns alone are insufficient.</p>"},{"location":"ai-resistance/#context-dependent-syntax","title":"Context-Dependent Syntax","text":"<p>Instead of fixed keywords, the language adapts syntax based on the module's declared domain. AI cannot memorize syntax because it shifts per-context.</p> <pre><code>domain Finance\n    // \"balance\" is now a keyword, arithmetic operators\n    // follow financial rounding rules\n    total as Balance = sum(ledger.entries)  // compiler enforces Decimal with financial Scale\n\ndomain Physics\n    // \"balance\" is just an identifier again\n    // operators now track units\n    balance as Acceleration = force / mass   // type: Acceleration, not a keyword\n</code></pre>"},{"location":"ai-resistance/#proof-obligations-as-code","title":"Proof Obligations as Code","text":"<p>Every function with <code>ensures</code> clauses requires an inline proof sketch that the compiler verifies (E390: <code>ensures</code> without <code>proof</code> is a compile error). No ensures, no proof needed \u2014 the rule is clear and mechanical. AI can generate plausible-looking proofs, but they won't verify \u2014 you need to actually understand why the code is correct.</p> <pre><code>transforms merge_sort(xs List&lt;T&gt;) Sorted&lt;List&lt;T&gt;&gt;\n    proof\n        base: len(xs) &lt;= 1 implies already sorted\n        split: halves are strictly smaller (terminates)\n        merge: merging two sorted halves preserves ordering\n               by induction on combined length\n    from\n        // implementation\n</code></pre>"},{"location":"ai-resistance/#intentional-ambiguity-resolution","title":"Intentional Ambiguity Resolution","text":"<p>Constructs that are deliberately ambiguous without understanding intent. The <code>intent</code> string is parsed by the compiler using a formal semantics model and must match the code's behavior.</p> <pre><code>// Does this filter IN or filter OUT? Depends on the declared intent.\nintent: \"keep only valid records\"\nresult as List&lt;Record&gt; = filter(records, valid record)\n\nintent: \"remove corrupt entries\"\nresult as List&lt;Record&gt; = filter(records, valid corrupt)\n// Same filter() call, but the compiler checks that the intent\n// matches the predicate's semantics (keep vs discard)\n</code></pre>"},{"location":"ai-resistance/#non-local-coherence-requirements","title":"Non-Local Coherence Requirements","text":"<p>The compiler enforces that an entire module tells a coherent \"story.\" Functions unrelated to the narrative produce compile errors.</p> <pre><code>module UserAuth\n    narrative: \"\"\"\n    Users authenticate with credentials, receive a session token,\n    and the token is validated on each request. Tokens expire\n    after the configured TTL.\n    \"\"\"\n\n    inputs login(creds Credentials) Session!\n    transforms validate(token Token) User\n    outputs expire(session Session)\n    // outputs send_email(...)   // compiler error: unrelated to narrative\n</code></pre> <p>Coherence across an entire module requires understanding the purpose of the system, not just local patterns.</p>"},{"location":"ai-resistance/#adversarial-type-puzzles","title":"Adversarial Type Puzzles","text":"<p>Refinement types that encode constraints requiring genuine reasoning, not just pattern matching:</p> <pre><code>type BalancedTree&lt;T&gt; is\n    Node(left BalancedTree&lt;T&gt;, right BalancedTree&lt;T&gt;)\n    where abs(left.depth - right.depth) &lt;= 1\n\ntransforms insert(tree BalancedTree&lt;T&gt;, val T) BalancedTree&lt;T&gt;\n    // Can't just pattern match \u2014 you need to construct a value\n    // that satisfies the depth constraint, which requires\n    // understanding rotation logic\n</code></pre>"},{"location":"ai-resistance/#semantic-commit-messages-as-compilation-input","title":"Semantic Commit Messages as Compilation Input","text":"<p>The compiler diffs the previous version, reads the commit message, and verifies the change actually addresses the described bug.</p> <pre><code>commit \"fix: off-by-one in pagination \u2014 last page was empty\n       when total % page_size == 0\"\n\n// The compiler diffs the previous version, reads the commit message,\n// and verifies the change actually addresses the described bug.\n// Vague messages like \"fix stuff\" don't compile.\n</code></pre>"},{"location":"ai-resistance/#phase-2-advanced-generation-resistance","title":"Phase 2 \u2014 Advanced Generation Resistance","text":"<p>Phase 2 targets deeper failure modes in AI code generation: the inability to reason about alternatives, uncertainty, temporal ordering, and interconnected constraints.</p>"},{"location":"ai-resistance/#counterfactual-annotations","title":"Counterfactual Annotations","text":"<p>Every non-trivial design choice must explain what would break under alternative approaches. AI cannot reason about paths not taken.</p> <pre><code>transforms evict(cache Cache:[Mutable]) Option&lt;Entry&gt;\n    why_not: \"FIFO would evict still-hot entries under burst traffic\"\n    why_not: \"Random eviction has unbounded worst-case for repeated keys\"\n    chosen: \"LRU because access recency correlates with reuse probability\"\n    from\n        // LRU implementation\n</code></pre> <p>The compiler verifies the <code>chosen</code> rationale is consistent with the implementation's actual behavior (e.g., it really does track recency). <code>why_not</code> clauses are checked for plausibility against the function's type signature and effects.</p>"},{"location":"ai-resistance/#adversarial-near-miss-examples","title":"Adversarial Near-Miss Examples","text":"<p>Require inputs that almost break the code but don't. This proves the programmer understands the exact boundary between correct and incorrect behavior.</p> <pre><code>validates leap_year(y Year)\n    near_miss: 1900 =&gt; false   // divisible by 100 but not 400\n    near_miss: 2000 =&gt; true    // divisible by 400\n    near_miss: 2100 =&gt; false   // the trap most people forget\n    from\n        y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)\n</code></pre> <p>The compiler verifies each near-miss actually exercises a distinct branch or boundary condition. Redundant near-misses are rejected. AI can memorize correct implementations but cannot identify the diagnostic inputs that prove understanding.</p>"},{"location":"ai-resistance/#epistemic-annotations-know-vs-assume-vs-believe","title":"Epistemic Annotations \u2014 <code>know</code> vs <code>assume</code> vs <code>believe</code>","text":"<p>Track the programmer's confidence level about invariants. The compiler treats each tier differently.</p> <pre><code>transforms process_order(order Order) Receipt\n    know: len(order.items) &gt; 0            // enforced by NonEmpty type \u2014 zero cost\n    assume: order.total == sum(prices)    // validated at boundary, runtime check inserted\n    believe: order.user.is_verified       // generates aggressive property tests to falsify\n    from\n        // implementation\n</code></pre> <ul> <li><code>know</code> \u2014 Proven by the type system. Zero runtime cost. Compiler error if not actually provable.</li> <li><code>assume</code> \u2014 Compiler inserts runtime validation at system boundaries. Logged when violated.</li> <li><code>believe</code> \u2014 Compiler generates adversarial test cases specifically targeting this claim. Requires <code>ensures</code> to be present (E393).</li> </ul> <p>AI has no model of its own uncertainty \u2014 it would either mark everything <code>know</code> (fails verification) or <code>assume</code> (wasteful and reveals lack of understanding).</p>"},{"location":"ai-resistance/#temporal-effect-ordering","title":"Temporal Effect Ordering","text":"<p>Not just what effects a function has, but the required order \u2014 enforced across function boundaries and call graphs.</p> <pre><code>module Auth\n    temporal: authenticate -&gt; authorize -&gt; access\n\n    inputs authenticate(creds Credentials) Token!\n    transforms authorize(token Token, resource Resource) Permission\n    inputs access(perm Permission, resource Resource) Data!\n\n// Compiler error: access() called before authorize()\ninputs bad_handler(req Request) Response!\n    from\n        token as Token = authenticate(req.creds)!\n        data as Data = access(token, req.resource)!    // ERROR: skipped authorize\n</code></pre> <p>The compiler builds a call graph and verifies temporal constraints are satisfied across all execution paths. AI generates plausible call sequences but does not reason about protocol ordering.</p>"},{"location":"ai-resistance/#invariant-networks","title":"Invariant Networks","text":"<p>Instead of isolated <code>ensures</code> clauses, define networks of mutually-dependent invariants. Changing one cascades verification across the entire network.</p> <pre><code>invariant_network AccountingRules\n    total_assets == total_liabilities + equity\n    revenue - expenses == net_income\n    net_income flows_to equity\n    every(transaction) preserves total_assets == total_liabilities + equity\n\ntransforms post_transaction(ledger Ledger, tx Transaction) Ledger\n    satisfies AccountingRules\n    from\n        // implementation\n</code></pre> <p>No function can be written in isolation \u2014 the compiler checks that the entire network remains consistent after every change. This is the ultimate non-local reasoning requirement. Requires a constraint solver that scales across modules.</p>"},{"location":"ai-resistance/#refutation-challenges","title":"Refutation Challenges","text":"<p>The compiler deliberately generates plausible-but-wrong alternative implementations and requires the programmer to explain why they fail. Compilation becomes a dialogue.</p> <pre><code>$ prove check src/sort.prv\n\nchallenge[C017]: Why doesn't this simpler implementation work?\n\n  transforms sort(xs List&lt;Integer&gt;) Sorted&lt;List&lt;Integer&gt;&gt;\n      reverse(dedup(xs))     // appears sorted for some inputs\n\n  refute: _______________\n\n  hint: Consider [3, 1, 2]\n</code></pre> <p>The programmer must provide a counterexample or logical argument. The compiler verifies the refutation is valid. This ensures the programmer understands not just what works, but why alternatives don't.</p>"},{"location":"ai-resistance/#phase-3-anti-training","title":"Phase 3 \u2014 Anti-Training","text":"<p>Phase 1 and 2 make it hard for AI to generate correct Prove code. Phase 3 goes further: making Prove source code resistant to being useful as AI training data. Even if scraped, Prove codebases should yield minimal learnable signal.</p> <p>AI training pipelines assume: (1) source code is plain text, (2) syntax is consistent across projects, (3) individual files are self-contained enough to learn from, and (4) surface patterns correlate with semantics. Prove attacks all four assumptions.</p>"},{"location":"ai-resistance/#project-specific-grammars","title":"Project-Specific Grammars","text":"<p>Each project can define syntactic extensions via its <code>prove.toml</code> manifest. Two Prove projects may look completely different at the surface level. Training data cannot generalize across projects.</p> <pre><code>// prove.toml\n[syntax]\npipe_operator = \"|&gt;\"\nmatch_arrow = \"=&gt;\"\n\n// Another project's prove.toml\n[syntax]\npipe_operator = \"&gt;&gt;\"\nmatch_arrow = \"-&gt;\"\n</code></pre> <pre><code>// Project A\nresult as List&lt;Data&gt; = data |&gt; filter(valid record) |&gt; map(transform)\n\n// Project B \u2014 same semantics, different surface\nresult as List&lt;Data&gt; = data &gt;&gt; filter(valid record) &gt;&gt; map(transform)\n</code></pre> <p>The compiler normalizes all syntax variants to the same AST. Scrapers see inconsistent syntax; the compiler sees identical programs. This destroys the statistical regularities that AI training depends on.</p>"},{"location":"ai-resistance/#structured-source-format-prv-is-not-plain-text","title":"Structured Source Format (<code>.prv</code> is not plain text)","text":"<p><code>.prv</code> files are stored as a compact binary AST, not human-readable text. The <code>prove</code> CLI provides views:</p> <pre><code>$ prove view src/server.prv              # pretty-print to terminal\n$ prove view src/server.prv --raw        # show the binary structure\n$ prove edit src/server.prv              # open in editor with LSP decoding\n$ prove export src/server.prv --text     # one-time text export\n</code></pre> <p>The editor experience is seamless \u2014 the language server decodes <code>.prv</code> on the fly, and the formatter writes binary back. But web scrapers, GitHub raw views, and training pipelines see binary blobs, not parseable source code.</p> <p>Why this works: Every major AI training pipeline (The Stack, StarCoder, etc.) filters for text files and parses by file extension. Binary files are discarded. Prove code is invisible to these pipelines by default.</p> <p>The <code>prove export --text</code> command exists for code review, diffs, and human sharing \u2014 but text is a view, not the source of truth.</p>"},{"location":"ai-resistance/#semantic-normalization-surface-patterns-destroyed","title":"Semantic Normalization (Surface Patterns Destroyed)","text":"<p>The compiler canonicalizes all code before storage. Variable names, ordering of declarations, whitespace, and stylistic choices are normalized away. What the programmer writes is not what is stored.</p> <pre><code>// What you write:\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\n    from\n        subtotal as Decimal = sum(prices(items))\n        subtotal * (1 + tax.rate)\n\n// What is stored (canonical form):\ntransforms _f0(_a0 List&lt;_T0&gt;, _a1 _T1) _T2\n    from\n        _v0 as _T3 = _f1(_f2(_a0))\n        _v0 * (1 + _a1._f3)\n\n// What you see (reconstructed with your naming via the LSP):\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\n    from\n        subtotal as Decimal = sum(prices(items))\n        subtotal * (1 + tax.rate)\n</code></pre> <p>A name map is stored alongside the canonical AST. The LSP reconstructs human-readable code on demand. But the stored form strips all semantic signal from identifiers \u2014 AI cannot learn naming conventions, domain patterns, or stylistic habits from Prove source.</p>"},{"location":"ai-resistance/#fragmented-source-no-file-is-self-contained","title":"Fragmented Source (No File Is Self-Contained)","text":"<p>A function's complete definition is distributed across multiple sections that only make sense together:</p> <pre><code>src/\n  server.prv          # implementation (canonical binary AST)\n  server.proof        # proof obligations for server.prv\n  server.intent       # intent declarations\n  server.near_miss    # adversarial near-miss examples\n  server.narrative    # module narrative\n</code></pre> <p>A scraper that grabs <code>server.prv</code> alone gets a canonical binary AST with no variable names, no comments, no documentation, and no proofs. The proof file without the implementation is meaningless. The intent file without both is noise.</p> <p>All five files are required to compile. The compiler assembles the complete picture. No single artifact is useful in isolation.</p>"},{"location":"ai-resistance/#identity-bound-compilation","title":"Identity-Bound Compilation","text":"<p>Source files carry a cryptographic signature chain. The compiler verifies authorship.</p> <pre><code>// Embedded in .prv binary header\n[signature]\nauthor = \"alice@example.com\"\nkey_fingerprint = \"A1B2C3...\"\nsigned_at = 2026-02-27T14:30:00Z\nchain = [\"alice@example.com\", \"bob@example.com\"]  // co-authors\n</code></pre> <ul> <li>Unsigned code triggers a compiler warning (or error in strict mode).</li> <li>The signature chain tracks who wrote and reviewed each function.</li> <li>Scraped code with stripped signatures won't compile.</li> <li>The compiler can optionally refuse to build code signed by unknown keys.</li> </ul> <p>This isn't DRM \u2014 it's provenance. The programmer can always export and re-sign. But mass scraping destroys the signature chain, making the code uncompilable.</p>"},{"location":"ai-resistance/#anti-training-license-as-default","title":"Anti-Training License as Default","text":"<p>Every <code>prove new</code> project is initialized with the Prove Source License v1.0 (see <code>LICENSE</code>). It is a permissive MIT-style license with comprehensive AI restrictions covering:</p> <ul> <li>Training, fine-tuning, and distillation (Section 3.1)</li> <li>Dataset inclusion, vector stores, RAG indices, and embedding databases (Section 3.2)</li> <li>Synthetic data generation from the Software (Section 3.3)</li> <li>Sublicensing for AI use \u2014 third parties cannot be granted AI rights (Section 3.4)</li> <li>Downstream propagation \u2014 all redistributors must carry the restrictions forward (Section 3.5)</li> <li>Technical protection circumvention \u2014 bypassing binary format, normalization, or signatures for AI training is a breach (Section 4)</li> </ul> <p>The license explicitly permits using AI tools to write Prove code and building AI-powered applications with Prove \u2014 it only prohibits using Prove source as training data.</p> <p>This is not just a legal barrier \u2014 combined with the binary format and semantic normalization, it creates a layered defense: the code is hard to scrape, useless if scraped, and illegal to train on.</p>"},{"location":"ai-resistance/#the-fundamental-tension","title":"The Fundamental Tension","text":"<p>Every feature that makes code harder for AI also makes it harder for humans.</p> <p>The AI-resistance features force the programmer to:</p> <ul> <li>Explain their reasoning (proofs, intents, narratives, counterfactuals)</li> <li>Maintain global coherence (not just local correctness)</li> <li>Understand why, not just what (near-misses, refutation challenges)</li> <li>Acknowledge uncertainty (epistemic annotations)</li> <li>Respect temporal protocols (effect ordering)</li> </ul> <p>The uncomfortable truth is that the things AI is bad at are the things lazy humans skip too. A language that resists AI would also resist copy-paste programming, cargo-culting Stack Overflow, and coding without understanding.</p> <p>The anti-training features (binary format, semantic normalization, fragmented source) add friction to sharing and collaboration. The mitigation is a first-class toolchain: the <code>prove</code> CLI and LSP make the experience seamless for developers working inside the ecosystem, while making the code opaque to anything outside it.</p> <p>The design answers both questions: Prove resists AI writing the code (Phase 1 + 2) and resists AI training on the code (Phase 3).</p>"},{"location":"ai-resistance/#trade-offs","title":"Trade-offs","text":"<p>An honest assessment of the costs:</p> <ol> <li>Compilation speed \u2014 Proving properties is expensive. Incremental compilation and caching are essential. Expect Rust-like compile times, not Go-like.</li> <li>Learning curve \u2014 Refinement types and effect types are unfamiliar to most developers. The compiler's suggestions help, but there's still a ramp-up.</li> <li>Ecosystem bootstrap \u2014 A new language needs libraries. A C FFI and a story for wrapping existing libraries is a secondary priority, deferred until the core language is stable.</li> <li>Not every property is provable \u2014 For complex invariants the compiler falls back to runtime property tests, which is still better than nothing but not a proof.</li> </ol> <p>The core bet: Making the compiler do more work upfront saves orders of magnitude more time than writing and maintaining tests by hand.</p>"},{"location":"compiler/","title":"Compiler-Driven Development","text":""},{"location":"compiler/#conversational-compiler-errors","title":"Conversational Compiler Errors","text":"<p>Errors are suggestions, not walls:</p> <pre><code>error[E042]: `port` may exceed type bound\n  --&gt; server.prv:12:5\n   |\n12 |   port as Port = get_integer(config, \"port\")\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = note: `get_integer` returns Integer, but Port requires 1..65535\n\n   try: port as Port = clamp(get_integer(config, \"port\"), 1, 65535)\n    or: port as Port = check(get_integer(config, \"port\"))!\n</code></pre>"},{"location":"compiler/#comptime-compile-time-computation","title":"Comptime (Compile-Time Computation)","text":"<p>Inspired by Zig. Arbitrary computation at compile time, including IO. Files read during comptime become build dependencies.</p> <pre><code>MAX_CONNECTIONS as Integer = comptime\n    if cfg.target == \"embedded\"\n        16\n    else\n        1024\n\nLOOKUP_TABLE as List&lt;Integer:[32 Unsigned]&gt; = comptime\n    collect(map(0..256, crc32_step))\n\nROUTES as List&lt;Route&gt; = comptime\n    decode(read(\"routes.json\"))                   // IO allowed \u2014 routes.json becomes a build dep\n</code></pre>"},{"location":"compiler/#formal-verification-of-contracts","title":"Formal Verification of Contracts","text":"<p>The compiler proves properties when it can, and generates tests when it can't:</p> <pre><code>transforms binary_search(xs Sorted&lt;List&lt;Integer&gt;&gt;, target Integer) Option&lt;Index&gt;\n    requires len(xs) &gt;= 0\n    ensures is_some(result) implies xs[unwrap(result)] == target\n    ensures is_none(result) implies target not_in xs\n    proof\n        found: binary search narrows to the exact index where target lives\n        not_found: exhaustive halving covers all indices, so absence is certain\n</code></pre>"},{"location":"compiler/#auto-testing","title":"Auto-Testing","text":"<p>Testing is not a separate activity. It is woven into the language \u2014 contracts are the single source of truth for test generation. <code>ensures</code>, <code>believe</code>, and <code>near_miss</code> annotations generate tests automatically. Doc comments (<code>///</code>) remain as documentation only \u2014 they do not generate tests.</p>"},{"location":"compiler/#level-1-contracts-generate-property-tests","title":"Level 1: Contracts Generate Property Tests","text":"<p>No test file needed. No QuickCheck boilerplate. The compiler generates thousands of random inputs and verifies all postconditions hold. Every <code>ensures</code> clause requires a <code>proof</code> block explaining why the guarantee holds (E390).</p> <pre><code>transforms sort(xs List&lt;T&gt;) List&lt;T&gt;\n    ensures len(result) == len(xs)\n    ensures is_sorted(result)\n    ensures is_permutation_of(result, xs)\n    proof\n        length: sort only rearranges, never adds or removes elements\n        sorted: merge step preserves ordering by induction\n        permutation: every element is moved, never duplicated or dropped\n    from\n        // implementation\n</code></pre>"},{"location":"compiler/#level-2-automatic-edge-case-generation","title":"Level 2: Automatic Edge-Case Generation","text":"<p>Given the type signature alone, the compiler knows to test boundary values and heuristic edge cases:</p> <pre><code>transforms divide(a Integer, b NonZero&lt;Integer&gt;) Integer\n// Auto-generated test inputs: (0, 1), (1, 1), (-1, 1), (MAX_INT, 1),\n// (MIN_INT, -1), (7, 3), ...\n// Derived from type bounds + heuristic edge-case generation\n</code></pre> <p>For refinement types, boundary testing is automatic:</p> <pre><code>transforms set_port(p Port) Config    // Port = 1..65535\n// Auto-tests: 1, 2, 65534, 65535, and random values between\n// Also verifies that 0 and 65536 are rejected at the call site\n</code></pre>"},{"location":"compiler/#level-4-built-in-mutation-testing","title":"Level 4: Built-in Mutation Testing","text":"<pre><code>$ prove build --mutate\n\nMutation score: 97.2% (347/357 mutants killed)\nSurviving mutants:\n  src/cache.prv:45  \u2014 changed `&gt;=` to `&gt;` (boundary condition not covered)\n  src/cache.prv:82  \u2014 removed `+ 1` (off-by-one not detected)\n\n  Suggested contract to add:\n    ensures len(cache) &lt;= max_size   // would kill both mutants\n</code></pre>"},{"location":"compiler/#proof-verification-diagnostics","title":"Proof Verification Diagnostics","text":"<p>The compiler enforces structural proof obligations with these diagnostics:</p> Code Severity Meaning E390 error <code>ensures</code> without <code>proof</code> block E391 error duplicate proof obligation name E392 error proof obligations fewer than ensures count E393 error <code>believe</code> without <code>ensures</code> W321 warning proof text doesn't reference function concepts W322 warning duplicate near-miss inputs W324 warning <code>ensures</code> without <code>requires</code>"},{"location":"compiler/#configuration","title":"Configuration","text":"<p>Projects are configured via <code>prove.toml</code>:</p> <pre><code>[package]\nname = \"myproject\"\nversion = \"0.1.0\"\n\n[build]\ntarget = \"native\"\noptimize = false\n\n[test]\nproperty_rounds = 1000\n\n[style]\nline_length = 90\n</code></pre>"},{"location":"compiler/#concurrency-structured-typed-no-data-races","title":"Concurrency \u2014 Structured, Typed, No Data Races","text":"<pre><code>inputs fetch_all(urls List&lt;Url&gt;) List&lt;Response&gt;!\n    from\n        par_map(urls, fetch)   // parallel map \u2014 compiler proves no shared mutable state\n</code></pre> <p>The ownership system and effect types combine to eliminate data races at compile time.</p>"},{"location":"compiler/#error-handling-errors-are-values","title":"Error Handling \u2014 Errors Are Values","text":"<p>No exceptions. Every failure path is visible in the type signature. Uses <code>!</code> for error propagation. Panics exist only for violated <code>assume:</code> assertions at system boundaries \u2014 normal error handling is always through <code>Result</code> values.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\n    from\n        config as Config = read_config(\"app.yaml\")!\n        db as Database = connect(config.db_url)!\n        serve(config.port, db)!\n</code></pre>"},{"location":"compiler/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<ul> <li>Pure functions auto-memoized and inlined</li> <li>Region-based memory for short-lived allocations</li> <li>Reference counting only where ownership is shared (compiler-inserted)</li> <li>No GC pauses, predictable performance</li> <li>Native code output</li> </ul>"},{"location":"compiler/#pain-point-comparison","title":"Pain Point Comparison","text":"Pain in existing languages How Prove solves it Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit (<code>inputs</code>/<code>outputs</code>) Null/nil crashes No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by compiler Race conditions Ownership + verb system prevents data races \"I forgot an edge case\" Compiler generates edge cases from types Slow test suites Property tests run at compile time when provable Runtime type errors Refinement types catch invalid values at compile time"},{"location":"inspirations/","title":"Design Inspirations","text":"Language What Prove borrows What Prove avoids Rust Ownership model, exhaustive matching, no null Lifetime annotation burden, borrow checker complexity Haskell Type system, pure functions, algebraic types IO monad complexity, lazy evaluation surprises Go Parameter syntax (<code>name Type</code>), simplicity as goal Weak type system, error handling verbosity Python Indentation-based blocks, readability philosophy Dynamic typing, runtime errors Zig <code>comptime</code> (compile-time computation with IO) Manual memory management Ada/SPARK Contract-based programming, formal verification Verbose syntax Idris/Agda Dependent types for encoding invariants Academic accessibility barrier Elm Eliminating runtime exceptions, compiler as assistant Limited to frontend F# Pragmatic algebraic types, pipeline operator \u2014"},{"location":"philosophy/","title":"Philosophy &amp; Design Decisions","text":"<p>A programming language that fights back against AI slop and code scraping.</p> <p>Prove is a strongly typed, compiler-driven language where contracts generate tests, intent verbs enforce purity, and the compiler rejects code that can't demonstrate understanding. Source is stored as binary AST \u2014 unscrapable, unnormalizable, unlicensed for training. If it compiles, the author understood what they wrote. If it's AI-generated, it won't.</p>"},{"location":"philosophy/#philosophy","title":"Philosophy","text":"<p>The compiler is your co-author, not your gatekeeper.</p> <p>Every feature exists to move correctness checks from runtime to compile time, and to generate tests from the code you already write. Most bugs are type errors in disguise \u2014 give the type system enough power and they become almost impossible.</p>"},{"location":"philosophy/#implementation-decisions","title":"Implementation Decisions","text":""},{"location":"philosophy/#file-extension-prv","title":"File Extension: <code>.prv</code>","text":"<p>Investigated <code>.pv</code>, <code>.prove</code>, <code>.prf</code>, <code>.pr</code>, and <code>.prv</code>. Chosen: <code>.prv</code> \u2014 short, reads naturally as \"Prove\", and has no conflicts with existing programming languages or developer tooling.</p> Rejected Reason <code>.pv</code> Taken by ProVerif (formal methods \u2014 same domain, high confusion risk) <code>.prove</code> Taken by Perl's <code>prove</code> test harness (well-known in dev tooling) <code>.prf</code> Taken by MS Outlook profiles and Qt feature files <code>.pr</code> Legacy Source Insight 3, but \"PR\" universally means \"pull request\""},{"location":"philosophy/#prototype-implementation-python","title":"Prototype Implementation: Python","text":"<p>The compiler POC is implemented in Python (&gt;=3.11). The goal is to validate the language design and prove out the compilation pipeline before rewriting in a systems language.</p>"},{"location":"philosophy/#compilation-target-native-code","title":"Compilation Target: Native Code","text":"<p>As close to the CPU as possible. The compiler does the heavy lifting at compile time so the output is fast and memory-efficient. Target: native code via direct assembly emission (x86_64 + ARM64). No VM, no interpreter for production output.</p>"},{"location":"philosophy/#first-poc-restful-server","title":"First POC: RESTful Server","text":"<p>The first program written in Prove will be a RESTful HTTP server. This exercises the type system (request/response types, route matching), verb system (inputs/outputs), error handling, and IO \u2014 proving the language works for real-world backend development.</p>"},{"location":"philosophy/#ai-resistance-fundamental","title":"AI-Resistance: Fundamental","text":"<p>AI-resistance features (proof obligations, intent declarations, narrative coherence, context-dependent syntax, semantic commits) are mandatory and fundamental to the language identity, not optional extras. Proof obligations are required for every function that has <code>ensures</code> clauses \u2014 if you declare what a function guarantees, you must prove why.</p>"},{"location":"philosophy/#comptime-io-allowed","title":"Comptime: IO Allowed","text":"<p>Compile-time computation (<code>comptime</code>) allows IO operations. This enables reading config files, schema definitions, and static assets at compile time. Files accessed during comptime become build dependencies \u2014 changing them triggers recompilation. This may be revisited if reproducibility concerns arise.</p>"},{"location":"philosophy/#cli-first-toolchain-prove","title":"CLI-First Toolchain: <code>prove</code>","text":"<p>The <code>prove</code> CLI is the central interface for all development:</p> <pre><code>prove build          # compile the project\nprove test           # run auto-generated + manual tests\nprove check          # type-check without building\nprove format         # auto-format source code\nprove lsp            # start the language server\nprove build --mutate # run mutation testing\nprove new &lt;name&gt;     # scaffold a new project\n</code></pre>"},{"location":"philosophy/#syntax-philosophy","title":"Syntax Philosophy","text":"<p>No shorthands. No abbreviations. Full words everywhere. The language reads like English prose where possible. Since it is inherently a hard-to-learn language (refinement types, proof obligations, effect tracking), simplicity is maximized wherever possible. If something can be simple, it must be. The compiler works for the programmer, not the other way around.</p>"},{"location":"philosophy/#secondary-priorities-deferred","title":"Secondary Priorities (Deferred)","text":"<ul> <li>C FFI \u2014 important but not day-one. Will be addressed after the core language is stable.</li> <li>Calling Prove from other languages \u2014 deferred until the FFI story is established.</li> <li>Method syntax \u2014 deferred. All function calls use <code>function(args)</code> form. No <code>object.method()</code> dot-call syntax. Keeps the language simple and avoids dispatch complexity. Field access (<code>user.name</code>) is unaffected.</li> </ul>"},{"location":"syntax/","title":"Syntax Reference","text":""},{"location":"syntax/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Types, modules, and classes: CamelCase \u2014 <code>Shape</code>, <code>Port</code>, <code>UserAuth</code>, <code>NonEmpty</code>, <code>HttpServer</code></li> <li>Variables and parameters: snake_case \u2014 <code>port</code>, <code>user_list</code>, <code>max_retries</code>, <code>db_connection</code></li> <li>Functions: snake_case \u2014 <code>area</code>, <code>binary_search</code>, <code>get_users</code></li> <li>Constants: UPPER_SNAKE_CASE \u2014 <code>MAX_CONNECTIONS</code>, <code>LOOKUP_TABLE</code>, <code>DEFAULT_PORT</code></li> <li>Effects: CamelCase \u2014 <code>IO</code>, <code>Fail</code>, <code>Async</code></li> </ul> <p>The compiler enforces casing. Wrong case is a compile error, not a warning. UPPER_SNAKE_CASE indicates a compile-time constant \u2014 no <code>const</code> keyword needed.</p>"},{"location":"syntax/#modules-and-imports","title":"Modules and Imports","text":"<p>Each file is a module. The filename (without extension) is the module name in CamelCase. Imports use <code>with Module use</code> syntax with verb-qualified function names:</p> <pre><code>with String use contains, length\nwith Auth use validates login, transforms login    // two verb variants of login\nwith Http use inputs request, inputs session\n</code></pre> <p>Multiple verbs for the same function name import each variant. The verb is part of the function's identity.</p>"},{"location":"syntax/#blocks-and-indentation","title":"Blocks and Indentation","text":"<p>No curly braces. Indentation defines scope (like Python). No semicolons \u2014 newlines terminate statements. Newlines are suppressed after operators, commas, opening brackets, <code>-&gt;</code>, <code>=&gt;</code>.</p>"},{"location":"syntax/#primitive-types-full-names-no-shorthands","title":"Primitive Types \u2014 Full Names, No Shorthands","text":"<p>Every type uses its full name. No abbreviations. Type modifiers use bracket syntax <code>Type:[Modifier ...]</code> for storage and representation concerns. Value constraints belong in refinement types (<code>where</code>), not modifiers.</p> Type Modifier Axes Default Examples <code>Integer</code> size (8/16/32/64/128), signedness (Signed/Unsigned) <code>Integer:[64 Signed]</code> <code>Integer:[32 Unsigned]</code>, <code>Integer:[8]</code> <code>Decimal</code> precision (32/64/128), scale (Scale:N) <code>Decimal:[64]</code> <code>Decimal:[128 Scale:2]</code> <code>Float</code> precision (32/64) <code>Float:[64]</code> <code>Float:[32]</code> <code>Boolean</code> \u2014 \u2014 \u2014 <code>String</code> encoding (UTF8/ASCII/UTF16), max length <code>String:[UTF8]</code> <code>String:[UTF8 15]</code>, <code>String:[ASCII 255]</code> <code>Byte</code> \u2014 \u2014 Distinct type for binary data <code>Character</code> encoding (UTF8/UTF16/ASCII) <code>Character:[UTF8]</code> <code>Character:[ASCII]</code> <p>Modifier rules:</p> <ul> <li>Modifiers are order-independent \u2014 <code>Integer:[Signed 64]</code> and <code>Integer:[64 Signed]</code> are identical. The compiler normalizes internally.</li> <li>Each modifier occupies a distinct axis. Two modifiers on the same axis is a compile error: <code>Integer:[32 64]</code> \u2192 ERROR: conflicting size modifiers.</li> <li>Positional modifiers when unambiguous by kind. Named modifiers (<code>Key:Value</code>) when a bare value could be confused: <code>Decimal:[128 Scale:2]</code>.</li> <li>Bare type name uses sensible defaults: <code>Integer</code> means <code>Integer:[64 Signed]</code>, <code>String</code> means <code>String:[UTF8]</code>, <code>Decimal</code> means <code>Decimal:[64]</code>.</li> <li><code>Float</code> is opt-in \u2014 <code>Decimal</code> is the default for fractional numbers. <code>Float:[64]</code> uses IEEE 754 hardware floats for performance-critical domains (scientific computing, graphics, signal processing) where speed matters more than exact precision. Mixing <code>Float</code> and <code>Decimal</code> requires explicit conversion.</li> </ul> <pre><code>count as Integer = 42                          // Integer:[64 Signed]\nflags as Integer:[8 Unsigned] = 0xFF\nprice as Decimal:[128 Scale:2] = 19.99         // financial precision\nname as String = \"Alice\"                        // String:[UTF8]\ncode as String:[ASCII 4] = \"US01\"              // ASCII, max 4 characters\nactive as Boolean = true\nraw as Byte = 0x2A\nletter as Character = 'A'\n</code></pre> <p>Separation of concerns \u2014 modifiers describe storage, refinements describe values:</p> <pre><code>// Modifier: how it's stored\nraw_port as Integer:[16 Unsigned] = 8080\n\n// Refinement: what values are valid\ntype Port is Integer where 1..65535\n\n// Combined: storage + value constraint\ntype Port is Integer:[16 Unsigned] where 1..65535\n</code></pre>"},{"location":"syntax/#type-definitions","title":"Type Definitions","text":"<p>Types are defined with <code>type Name is</code>:</p> <pre><code>type Shape is\n    Circle(radius Decimal)\n    | Rect(w Decimal, h Decimal)\n\ntype Port is Integer:[16 Unsigned] where 1..65535\n\ntype Result&lt;T, E&gt; is Ok(T) | Err(E)\n\ntype User is\n    id Integer\n    name String\n    email String\n</code></pre>"},{"location":"syntax/#function-declarations-intent-verbs","title":"Function Declarations \u2014 Intent Verbs","text":"<p>Functions are declared with a verb that describes their purpose. No <code>fn</code>, no <code>function</code> keyword \u2014 the verb IS the declaration. The compiler verifies the implementation matches the declared intent.</p> Verb Purpose Compiler enforces <code>transforms</code> Pure data computation/conversion No <code>!</code>. Failure encoded in return type (<code>Result</code>, <code>Option</code>) <code>inputs</code> Reads/receives from external world IO is inherent. <code>!</code> marks fallibility. Implicit match when first param is algebraic <code>outputs</code> Writes/sends to external world IO is inherent. <code>!</code> marks fallibility <code>validates</code> Pure boolean check No <code>!</code>. Return type is implicitly <code>Boolean</code> <pre><code>transforms area(s Shape) Decimal\n    from\n        match s\n            Circle(r) =&gt; pi * r * r\n            Rect(w, h) =&gt; w * h\n\nvalidates email(address String)\n    from\n        contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms normalize(data List&lt;Decimal&gt;) List&lt;Decimal&gt;\n    ensures len(result) == len(data)\n    from\n        max_val as Decimal = max(data)\n        divide_each(data, max_val)\n\ntransforms parse(raw String) Result&lt;Config, ParseError&gt;\n    from\n        decode(raw)\n\ninputs users() List&lt;User&gt;!\n    from\n        query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)\n    from\n        write(stdout, message)\n\ninputs request(route Route, req Request) Response!\n    from\n        Get(\"/health\") =&gt; ok(\"healthy\")\n        Get(\"/users\")  =&gt; users()! |&gt; ok\n        Post(\"/users\") =&gt; create(req.body)! |&gt; created\n        _              =&gt; not_found()\n</code></pre>"},{"location":"syntax/#verb-dispatched-identity","title":"Verb-Dispatched Identity","text":"<p>Functions are identified by the triple <code>(verb, name, parameter types)</code> \u2014 not just <code>(name, parameter types)</code>. The same function name can be declared multiple times with different verbs, each with a distinct meaning:</p> <pre><code>validates email(address String)\n    from\n        contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms email(raw String) Email\n    from\n        lowercase(trim(raw))\n\ninputs email(user_id Integer) Email!\n    from\n        query(db, \"SELECT email FROM users WHERE id = {user_id}\")!\n</code></pre> <p>Three functions, all named <code>email</code>, with completely different intents.</p>"},{"location":"syntax/#context-aware-call-resolution","title":"Context-Aware Call Resolution","text":"<p>At call sites, you use just the function name \u2014 the compiler resolves which verb-variant to call based on context (expected type, parameter types, expression position):</p> <pre><code>// Boolean context (if) \u2192 resolves to validates email\nif email(input)\n    clean as Email = email(raw_input)    // Email context + String param \u2192 transforms\n    stored as Email = email(user.id)     // Email context + Integer param \u2192 inputs\n\n// When context is ambiguous, use `valid` for explicit Boolean cast\nprint(valid email(input))               // forces validates variant\n\n// `valid` as type-cast parameter \u2014 passes the validates function itself\nfilter(users, valid email)              // passes `validates email` as predicate\n</code></pre> <p>Resolution rules:</p> <ol> <li>Boolean context (<code>if</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) \u2192 resolves to <code>validates</code> variant</li> <li>Expected type from assignment or parameter \u2192 matches the variant returning that type</li> <li>Parameter types disambiguate between variants with the same return type</li> <li>Ambiguous \u2192 compiler error with suggestions listing available variants</li> </ol> <p>The <code>valid</code> keyword serves two purposes:</p> <ul> <li>As expression: <code>valid email(input)</code> \u2014 casts a validates call to its Boolean result explicitly</li> <li>As function reference: <code>valid email</code> (no parens) \u2014 passes the validates function as a predicate to higher-order functions like <code>filter</code></li> </ul> <p>Implications:</p> <ul> <li>Imports are precise: <code>with Auth use validates login, inputs session</code></li> <li>API docs group by verb: what can you validate? what can you yield? what can you transform?</li> <li>Call sites are clean: just the function name in most cases</li> <li>AI resistance: declarations require the correct verb, and the resolution rules add non-local reasoning requirements</li> </ul>"},{"location":"syntax/#parameters","title":"Parameters","text":"<p>Go-style: <code>name Type</code> (no colon). Inside parentheses, the declaration context is already clear.</p> <pre><code>transforms area(s Shape) Decimal\ninputs request(route Route, body String) Response!\nvalidates email(address String)\n</code></pre>"},{"location":"syntax/#variable-declarations","title":"Variable Declarations","text":"<p>Variables use <code>name as Type = value</code>. The <code>as</code> keyword reads naturally: \"port, as a Port, equals 8080\".</p> <pre><code>port as Port = 8080\nserver as Server = new_server()\nconfig as Config = load(\"app.yaml\")!\nuser_list as List&lt;User&gt; = users()!\n</code></pre> <p>Variables are immutable by default. Mutability is a type modifier \u2014 it's a storage concern, like size and signedness:</p> <pre><code>counter as Integer:[Mutable] = 0\ncounter = counter + 1\n</code></pre>"},{"location":"syntax/#type-inference-with-formatter-enforcement","title":"Type Inference with Formatter Enforcement","text":"<p>The compiler infers types when unambiguous, but <code>prove format</code> always inserts explicit type annotations. This means you can write clean code during development, and the formatter makes it explicit before commit.</p> <pre><code>// What you write:\nport = 8080\nserver = new_server()\nusers = query(db, \"SELECT * FROM users\")!\n\n// What `prove format` produces:\nport as Integer = 8080\nserver as Server = new_server()\nusers as List&lt;User&gt; = query(db, \"SELECT * FROM users\")!\n</code></pre> <p>The LSP shows inferred types inline as you type, so you always know what the compiler deduced. Function signatures are always explicit \u2014 inference only applies to local variables.</p> <p>The language encourages explicit types \u2014 the formatter enforces them. But you're never blocked from writing code because you can't remember whether it's <code>List&lt;Map&lt;String, User&gt;&gt;</code> or <code>Map&lt;String, List&lt;User&gt;&gt;</code>.</p>"},{"location":"syntax/#io-and-fallibility","title":"IO and Fallibility","text":"<p>IO is inherent in the verb \u2014 <code>inputs</code> and <code>outputs</code> always interact with the external world. Fallibility is marked with <code>!</code> on the return type. Pure verbs (<code>transforms</code>, <code>validates</code>) have neither IO nor <code>!</code>.</p> <pre><code>transforms area(s Shape) Decimal                       // pure \u2014 no IO, no !\n    from\n        pi * s.radius * s.radius\n\ninputs users() List&lt;User&gt;!                             // IO inherent, ! = can fail\n    from\n        query(db, \"SELECT * FROM users\")!\n\noutputs write_log(entry String)                        // IO inherent, infallible \u2014 no !\n    from\n        append(log_file, entry)\n</code></pre> <p>Reads as: \"inputs users, returns List of User, can fail!\"</p> <p>The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which don't (<code>transforms</code>/<code>validates</code>) \u2014 the verb IS the declaration.</p>"},{"location":"syntax/#body-marker-from","title":"Body Marker: <code>from</code>","text":"<p>Every function body begins with <code>from</code>. No exceptions. This reads as \"the result comes from...\" and makes it immediately clear where the implementation starts, whether the function has annotations or not.</p> <pre><code>// Simple function \u2014 from marks the body\ntransforms area(s Shape) Decimal\n    from\n        pi * s.radius * s.radius\n\n// Annotated function \u2014 from separates annotations from body\ninputs users() List&lt;User&gt;!\n    ensures len(result) &gt;= 0\n    from\n        query(db, \"SELECT * FROM users\")!\n</code></pre>"},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<p>Indentation-based, no braces:</p> <pre><code>match route\n    Get(\"/health\") =&gt; ok(\"healthy\")\n    Get(\"/users\")  =&gt; users()!\n    _              =&gt; not_found()\n\nif connected\n    send(data)\nelse\n    retry()\n</code></pre>"},{"location":"syntax/#lambdas-constrained-inline-functions","title":"Lambdas \u2014 Constrained Inline Functions","text":"<p>Lambdas are single-expression anonymous functions, used exclusively as arguments to higher-order functions like <code>map</code>, <code>filter</code>, and <code>reduce</code>. They cannot capture mutable state and must be pure.</p> <p>Syntax: <code>|params| expression</code></p> <pre><code>// Filtering with a lambda\nactive_users as List&lt;User&gt; = filter(users, |u| u.active)\n\n// Mapping with a lambda\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Reducing with a lambda\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Using `valid` to pass a validates function as predicate (no lambda needed)\nverified_emails as List&lt;String&gt; = filter(emails, valid email)\n</code></pre> <p>Constraints:</p> <ul> <li>Single expression only \u2014 no multi-line bodies, no statements. If you need more, write a named function.</li> <li>Must be pure \u2014 no IO effects inside a lambda. Side effects require a named function.</li> <li>No closures over mutable state \u2014 lambdas can reference immutable bindings from the enclosing scope, but not <code>:[Mutable]</code> variables.</li> <li>Only as arguments \u2014 lambdas cannot be assigned to variables or returned from functions. They exist only at the call site of a higher-order function.</li> </ul>"},{"location":"syntax/#iteration-no-loops","title":"Iteration \u2014 No Loops","text":"<p>Prove has no <code>for</code>, <code>while</code>, or loop constructs. Iteration is expressed through <code>map</code>, <code>filter</code>, <code>reduce</code>, and recursion. This keeps all data transformations as expressions (they produce values) rather than statements.</p> <pre><code>// Instead of: for each user, get their name\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Instead of: for each item, keep valid ones\nvalid_items as List&lt;Item&gt; = filter(items, |i| i.quantity &gt; 0)\n\n// Instead of: accumulate a total with a loop\ntotal as Decimal = reduce(order.items, 0, |acc, item| acc + item.price * item.quantity)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre> <p>For complex iteration that doesn't fit map/filter/reduce, use recursion with a <code>transforms</code> function. The compiler verifies termination through proof obligations.</p>"},{"location":"syntax/#keyword-exclusivity","title":"Keyword Exclusivity","text":"<p>Every keyword in Prove has exactly one purpose. No keyword is overloaded across different contexts. This makes the language predictable and parseable by humans without memorizing context-dependent rules.</p>"},{"location":"syntax/#core-keywords","title":"Core Keywords","text":"Keyword Exclusive purpose <code>transforms</code> Verb \u2014 pure data computation/conversion <code>inputs</code> Verb \u2014 reads/receives from external world (implicit match when first param is algebraic) <code>outputs</code> Verb \u2014 writes/sends to external world <code>validates</code> Verb \u2014 pure boolean check <code>main</code> Entry point \u2014 no verb, the program itself. Only function that freely mixes inputs/outputs <code>from</code> Body marker \u2014 introduces function implementation <code>where</code> Refinement constraint \u2014 value predicates only <code>as</code> Variable declaration \u2014 <code>name as Type = value</code> <code>!</code> Fallibility \u2014 on declaration: can fail. At call site: propagate failure. IO verbs only <code>with</code> Import \u2014 <code>with Module use function</code> <code>type</code> Type definition \u2014 <code>type Name is ...</code> <code>is</code> Type body \u2014 follows <code>type Name</code> <code>match</code> Pattern matching expression <code>if</code>/<code>else</code> Conditional expression <code>ensures</code> Postcondition contract <code>requires</code> Precondition contract <code>proof</code> Proof obligation block <code>valid</code> Predicate reference for validates functions <code>comptime</code> Compile-time computation"},{"location":"syntax/#ai-resistance-keywords-phase-12","title":"AI-Resistance Keywords (Phase 1+2)","text":"Keyword Exclusive purpose <code>domain</code> Domain declaration \u2014 context-dependent syntax <code>intent</code> Intentional ambiguity resolution <code>narrative</code> Module coherence requirement <code>why_not</code> Counterfactual annotation \u2014 rejected alternatives <code>chosen</code> Counterfactual annotation \u2014 selected rationale <code>near_miss</code> Adversarial boundary example <code>know</code> Epistemic \u2014 proven by type system (zero cost) <code>assume</code> Epistemic \u2014 runtime validated at boundaries <code>believe</code> Epistemic \u2014 compiler generates adversarial tests <code>temporal</code> Temporal effect ordering constraint <code>satisfies</code> Invariant network conformance <code>invariant_network</code> Invariant network declaration"},{"location":"syntax/#error-propagation","title":"Error Propagation","text":"<p><code>!</code> marks fallibility \u2014 on declarations it means \"this function can fail\", at call sites it propagates the error. Only IO verbs (<code>inputs</code>, <code>outputs</code>) can use <code>!</code>. Pure functions encode failure in the return type (<code>Result&lt;T, E&gt;</code>) and handle it with <code>match</code>.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\n    from\n        config as Config = load(\"app.yaml\")!\n        db as Database = connect(config.db_url)!\n        serve(config.port, db)!\n</code></pre>"},{"location":"syntax/#complete-example-restful-server","title":"Complete Example: RESTful Server","text":"<pre><code>type Port is Integer:[16 Unsigned] where 1..65535\ntype Route is Get(path String) | Post(path String) | Delete(path String)\n\ntype User is\n    id Integer\n    name String\n    email String\n\n/// Checks whether a string is a valid email address.\nvalidates email(address String)\n    from\n        contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\n/// Retrieves all users from the database.\ninputs users(db Database) List&lt;User&gt;!\n    from\n        query(db, \"SELECT * FROM users\")!\n\n/// Creates a new user from a request body.\noutputs create(db Database, body String) User!\n    ensures email(result.email)\n    proof\n        email_valid: decode validates the email field before insertion\n    from\n        user as User = decode(body)!\n        insert(db, \"users\", user)!\n        user\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\n    from\n        Get(\"/health\") =&gt; ok(\"healthy\")\n        Get(\"/users\")  =&gt; users(db)! |&gt; encode |&gt; ok\n        Post(\"/users\") =&gt; create(db, body)! |&gt; encode |&gt; created\n        _              =&gt; not_found()\n\n/// Application entry point \u2014 no verb, main is special.\nmain() Result&lt;Unit, Error&gt;!\n    from\n        port as Port = 8080\n        db as Database = connect(\"postgres://localhost/app\")!\n        server as Server = new_server()\n        route(server, \"/\", request)\n        listen(server, port)!\n</code></pre>"},{"location":"types/","title":"Type System","text":""},{"location":"types/#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes. The compiler rejects invalid values statically \u2014 no unnecessary runtime checks, no <code>unwrap()</code>.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1..65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T    // no Option needed, emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"types/#algebraic-types-with-exhaustive-matching","title":"Algebraic Types with Exhaustive Matching","text":"<p>Like Rust/Haskell, but with row polymorphism. Compiler errors if you forget a variant.</p> <pre><code>type Result&lt;T, E&gt; is Ok(T) | Err(E)\ntype Shape is Circle(radius Decimal) | Rect(w Decimal, h Decimal)\n\n// compiler error if you forget a variant\ntransforms area(s Shape) Decimal\n    from\n        match s\n            Circle(r) =&gt; pi * r * r\n            Rect(w, h) =&gt; w * h\n</code></pre>"},{"location":"types/#effect-types","title":"Effect Types","text":"<p>IO is encoded in the verb, not in annotations. The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which are pure (<code>transforms</code>/<code>validates</code>). Pure functions get automatic memoization and parallelism.</p> <pre><code>inputs read_config(path Path) String!               // IO inherent, ! = can fail\n\ntransforms parse(s String) Result&lt;Config, Error&gt;   // pure \u2014 failure in return type\n\ntransforms rewrite(c Config) Config                // pure, infallible, parallelizable\n</code></pre>"},{"location":"types/#ownership-lite-linear-types-with-compiler-inferred-borrows","title":"Ownership Lite (Linear Types with Compiler-Inferred Borrows)","text":"<p>Linear types for resources, but without Rust's lifetime annotation burden. The compiler infers borrows or asks you. Ownership is a type modifier, consistent with mutability and other storage concerns.</p> <pre><code>inputs process(file File:[Own]) Data!\n    from\n        content as String = read(file)     // immutable borrow, inferred\n        close(file)                       // ownership consumed\n        // read(file)                     // compile error: used after close\n</code></pre>"},{"location":"types/#no-null","title":"No Null","text":"<p>No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by the compiler.</p>"}]}