{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prove","text":"<p>A programming language that fights back against AI slop and code scraping.</p> <p>Prove is a strongly typed, compiler-driven language where contracts generate tests, intent verbs enforce purity, and the compiler rejects code that can't demonstrate understanding. Source is stored as binary AST \u2014 unscrapable, unnormalizable, unlicensed for training. If it compiles, the author understood what they wrote. If it's AI-generated, it won't.</p> <pre><code>transforms add(a Integer, b Integer) Integer\n  ensures result == a + b\nfrom\n    a + b\n</code></pre> <p>The <code>ensures</code> clause declares hard postconditions \u2014 the compiler enforces them automatically. The <code>transforms</code> verb guarantees purity. None of it can be faked by autocomplete.</p>"},{"location":"#why-prove","title":"Why Prove?","text":"Problem How Prove solves it AI scrapes your code for training Binary AST format + anti-training license + semantic normalization AI slop PRs waste maintainer time Compiler rejects code without explanations and intent Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit Null/nil crashes No null \u2014 <code>Option&lt;T&gt;</code> enforced by compiler \"I forgot an edge case\" Compiler generates edge cases from types Runtime type errors Refinement types catch invalid values at compile time Code without reasoning <code>explain</code> documents each step using controlled natural language \u2014 verified against contracts"},{"location":"#quick-start","title":"Quick Start","text":"<p>Requirements: Python 3.11+, gcc or clang</p> <pre><code># Install\npip install -e \".[dev]\"\n\n# Create a project\nprove new hello\n\n# Build and run\ncd hello\nprove build\n./build/hello\n\n# Type-check only\nprove check\n\n# Run auto-generated tests\nprove test\n</code></pre>"},{"location":"#language-tour","title":"Language Tour","text":""},{"location":"#intent-verbs","title":"Intent Verbs","text":"<p>Every function declares its purpose with a verb. The compiler enforces it. Pure verbs (<code>transforms</code>, <code>validates</code>, <code>reads</code>, <code>creates</code>, <code>matches</code>) cannot perform IO. IO verbs (<code>inputs</code>, <code>outputs</code>) make side effects explicit.</p> <pre><code>matches area(s Shape) Decimal\nfrom\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\nreads get(key String, table Table&lt;V&gt;) Option&lt;V&gt;\nfrom\n    lookup(table, key)\n\ncreates builder() Builder\nfrom\n    allocate_buffer()\n\ninputs users(db Database) List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)\nfrom\n    write(stdout, message)\n</code></pre> <p>The same name can exist with different verbs \u2014 the compiler resolves which to call from context:</p> <pre><code>validates email(address String)           // check if valid\ntransforms email(raw String) Email        // convert to Email type\ninputs email(user_id Integer) Email!      // fetch from database\n</code></pre>"},{"location":"#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1..65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T         // no Option needed \u2014 emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"#contracts","title":"Contracts","text":"<p><code>requires</code> and <code>ensures</code> are hard rules about the function's interface. The compiler enforces them automatically:</p> <pre><code>matches apply_discount(discount Discount, amount Price) Price\n  ensures result &gt;= 0\n  ensures result &lt;= amount\n  requires amount &gt;= 0\nfrom\n        FlatOff(off) =&gt; max(0, amount - off)\n        PercentOff(rate) =&gt; amount * (1 - rate)\n</code></pre> <p><code>explain</code> documents the chain of operations in the <code>from</code> block using controlled natural language. With <code>ensures</code> present (strict mode), the row count must match the <code>from</code> block and references are verified against contracts. Without <code>ensures</code> (loose mode), explain is free-form documentation:</p> <pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\n  explain\n    sum all items.price\n    reduce sub by discount\n    add tax to discounted\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p><code>explain</code> is LSP-suggested, not compiler-required \u2014 but <code>ensures</code> without <code>explain</code> produces a warning, since promises should be documented.</p>"},{"location":"#no-loops-functional-iteration","title":"No Loops \u2014 Functional Iteration","text":"<pre><code>names as List&lt;String&gt; = map(users, |u| u.name)\nactive as List&lt;User&gt; = filter(users, |u| u.active)\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Errors are values. <code>!</code> propagates failures. No exceptions.</p> <pre><code>main()!\nfrom\n    config as Config = load(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"#complete-example","title":"Complete Example","text":"<p>A RESTful inventory service demonstrating the full feature set:</p> <pre><code>module InventoryService\n    narrative: \"\"\"\n    Products are added to inventory with validated stock levels.\n    Orders consume stock. The system ensures stock never goes negative\n    and all monetary calculations use exact decimal arithmetic.\n    \"\"\"\n\ntype Port is Integer:[16 Unsigned] where 1..65535\ntype Price is Decimal:[128 Scale:2] where &gt;= 0\ntype Sku is String where matches(/^[A-Z]{2,4}-[0-9]{4,8}$/)\n\ntype Product is\n    sku Sku\n    name String\n    price Price\n    stock Quantity\n\n/// Checks whether every item in an order can be fulfilled.\nvalidates fulfillable(order Order)\nfrom\n    all(order.items, |item| in_stock(item.product, item.quantity))\n\n/// Places an order: validates stock, calculates total, deducts inventory.\noutputs place_order(db Database, order Order, tax TaxRule) Order!\n  requires fulfillable(order)\n  ensures result.status == Confirmed\nfrom\n    total as Price = calculate_total(order.items, None, tax)\n    confirmed as Order = Order(order.id, order.items, Confirmed, total)\n    insert(db, \"orders\", confirmed)!\n    deduct_stock(all_products(db)!, order.items) |&gt; update_all(db, \"products\")!\n    confirmed\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\nfrom\n    Get(\"/health\")   =&gt; ok(\"healthy\")\n    Get(\"/products\") =&gt; all_products(db)! |&gt; encode |&gt; ok\n    Post(\"/orders\")  =&gt; parse_order(body)! |&gt; place_order(db, tax)! |&gt; encode |&gt; created\n    _                =&gt; not_found()\n\nmain()!\nfrom\n    cfg as Config = load_config(\"inventory.yaml\")!\n    db as Database = connect(cfg.db_url)!\n    server as Server = new_server()\n    route(server, \"/\", request)\n    listen(server, cfg.port)!\n</code></pre>"},{"location":"#compiler-pipeline","title":"Compiler Pipeline","text":"<pre><code>Source (.prv) \u2192 Lexer \u2192 Parser \u2192 Checker \u2192 Prover \u2192 C Emitter \u2192 gcc/clang \u2192 Native Binary\n</code></pre>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>tree-sitter-prove \u2014 Tree-sitter grammar for editor syntax highlighting</li> <li>pygments-prove \u2014 Pygments lexer for MkDocs and Sphinx code rendering</li> <li>chroma-lexer-prove \u2014 Chroma lexer for Gitea/Hugo code rendering</li> </ul>"},{"location":"#status","title":"Status","text":"<p>v0.4 \u2014 pure verb enforcement, binary types, namespaced calls, and channel dispatch are complete. The compiler lexes, parses, type-checks, emits C, and produces native binaries. 394 tests pass across every stage.</p>"},{"location":"#repository","title":"Repository","text":"<p>Source code is hosted at code.botwork.se/Botwork/prove.</p> <p>The Gitea instance is a paid service for issue creators. Developers who want contributor access can reach out to magnusknutas[at]botwork.se.</p>"},{"location":"#license","title":"License","text":"<p>Prove Source License v1.0 \u2014 permissive for developers, prohibits use as AI training data.</p>"},{"location":"ai-resistance/","title":"AI Resistance","text":""},{"location":"ai-resistance/#phase-1-generation-resistance","title":"Phase 1 \u2014 Generation Resistance","text":"<p>AI models generate code by pattern-matching on statistical regularities in training data. To resist AI generation, a language needs correctness to require deep, holistic understanding \u2014 local patterns alone are insufficient.</p>"},{"location":"ai-resistance/#context-dependent-syntax","title":"Context-Dependent Syntax","text":"<p>Instead of fixed keywords, the language adapts syntax based on the module's declared domain. AI cannot memorize syntax because it shifts per-context.</p> <pre><code>domain Finance\n  // \"balance\" is now a keyword, arithmetic operators\n  // follow financial rounding rules\n  total as Balance = sum(ledger.entries)  // compiler enforces Decimal with financial Scale\n\ndomain Physics\n  // \"balance\" is just an identifier again\n  // operators now track units\n  balance as Acceleration = force / mass   // type: Acceleration, not a keyword\n</code></pre>"},{"location":"ai-resistance/#implementation-explanation-as-code","title":"Implementation Explanation as Code","text":"<p><code>explain</code> documents the chain of operations in the <code>from</code> block using controlled natural language. With <code>ensures</code> present, the compiler parses each row for operations (action verbs), connectors, and references to identifiers \u2014 then verifies them against called functions' contracts. Sugar words (\"the\", \"applicable\", etc.) are ignored, keeping explain readable as English while remaining machine-verifiable. AI can generate plausible-looking explanations, but they won't verify \u2014 operations must match real function behaviors, and references must be real identifiers.</p> <pre><code>transforms merge_sort(xs List&lt;T&gt;) Sorted&lt;List&lt;T&gt;&gt;\n  terminates: len(xs)\n  explain\n    split the list at the midpoint\n    recursively sort the first half\n    recursively sort the second half\n    merge both sorted halves preserving order\nfrom\n    halves as Pair&lt;List&lt;T&gt;&gt; = split_at(xs, len(xs) / 2)\n    left as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.first)\n    right as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.second)\n    merge(left, right)\n</code></pre>"},{"location":"ai-resistance/#intentional-ambiguity-resolution","title":"Intentional Ambiguity Resolution","text":"<p>Constructs that are deliberately ambiguous without understanding intent. The <code>intent</code> string is parsed by the compiler using a formal semantics model and must match the code's behavior.</p> <pre><code>// Does this filter IN or filter OUT? Depends on the declared intent.\nintent: \"keep only valid records\"\nresult as List&lt;Record&gt; = filter(records, valid record)\n\nintent: \"remove corrupt entries\"\nresult as List&lt;Record&gt; = filter(records, valid corrupt)\n// Same filter() call, but the compiler checks that the intent\n// matches the predicate's semantics (keep vs discard)\n</code></pre>"},{"location":"ai-resistance/#non-local-coherence-requirements","title":"Non-Local Coherence Requirements","text":"<p>The compiler enforces that an entire module tells a coherent \"story.\" Functions unrelated to the narrative produce compile errors.</p> <pre><code>module UserAuth\n  narrative: \"\"\"\n  Users authenticate with credentials, receive a session token,\n  and the token is validated on each request. Tokens expire\n  after the configured TTL.\n  \"\"\"\n\n  inputs login(creds Credentials) Session!\n  transforms validate(token Token) User\n  outputs expire(session Session)\n  // outputs send_email(...)   // compiler error: unrelated to narrative\n</code></pre> <p>Coherence across an entire module requires understanding the purpose of the system, not just local patterns.</p>"},{"location":"ai-resistance/#adversarial-type-puzzles","title":"Adversarial Type Puzzles","text":"<p>Refinement types that encode constraints requiring genuine reasoning, not just pattern matching:</p> <pre><code>type BalancedTree&lt;T&gt; is\n  Node(left BalancedTree&lt;T&gt;, right BalancedTree&lt;T&gt;)\n  where abs(left.depth - right.depth) &lt;= 1\n\ntransforms insert(tree BalancedTree&lt;T&gt;, val T) BalancedTree&lt;T&gt;\n  // Can't just pattern match \u2014 you need to construct a value\n  // that satisfies the depth constraint, which requires\n  // understanding rotation logic\n</code></pre>"},{"location":"ai-resistance/#semantic-commit-messages-as-compilation-input","title":"Semantic Commit Messages as Compilation Input","text":"<p>The compiler diffs the previous version, reads the commit message, and verifies the change actually addresses the described bug.</p> <pre><code>commit \"fix: off-by-one in pagination \u2014 last page was empty\n       when total % page_size == 0\"\n\n// The compiler diffs the previous version, reads the commit message,\n// and verifies the change actually addresses the described bug.\n// Vague messages like \"fix stuff\" don't compile.\n</code></pre>"},{"location":"ai-resistance/#phase-2-advanced-generation-resistance","title":"Phase 2 \u2014 Advanced Generation Resistance","text":"<p>Phase 2 targets deeper failure modes in AI code generation: the inability to reason about alternatives, uncertainty, temporal ordering, and interconnected constraints.</p>"},{"location":"ai-resistance/#counterfactual-annotations","title":"Counterfactual Annotations","text":"<p>Every non-trivial design choice must explain what would break under alternative approaches. AI cannot reason about paths not taken.</p> <pre><code>transforms evict(cache Cache:[Mutable]) Option&lt;Entry&gt;\n  why_not: \"FIFO would evict still-hot entries under burst traffic\"\n  why_not: \"Random eviction has unbounded worst-case for repeated keys\"\n  chosen: \"LRU because access recency correlates with reuse probability\"\nfrom\n    // LRU implementation\n</code></pre> <p>The compiler verifies the <code>chosen</code> rationale is consistent with the implementation's actual behavior (e.g., it really does track recency). <code>why_not</code> clauses are checked for plausibility against the function's type signature and effects.</p>"},{"location":"ai-resistance/#adversarial-near-miss-examples","title":"Adversarial Near-Miss Examples","text":"<p>Require inputs that almost break the code but don't. This proves the programmer understands the exact boundary between correct and incorrect behavior.</p> <pre><code>validates leap_year(y Year)\n  near_miss: 1900  =&gt; false\n  near_miss: 2000  =&gt; true\n  near_miss: 2100  =&gt; false\nfrom\n    y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)\n</code></pre> <p>The compiler verifies each near-miss actually exercises a distinct branch or boundary condition. Redundant near-misses are rejected. AI can memorize correct implementations but cannot identify the diagnostic inputs that prove understanding.</p>"},{"location":"ai-resistance/#epistemic-annotations-know-vs-assume-vs-believe","title":"Epistemic Annotations \u2014 <code>know</code> vs <code>assume</code> vs <code>believe</code>","text":"<p>Track the programmer's confidence level about invariants. The compiler treats each tier differently.</p> <pre><code>transforms process_order(order Order) Receipt\n  know: len(order.items) &gt; 0            // enforced by NonEmpty type \u2014 zero cost\n  assume: order.total == sum(prices)    // validated at boundary, runtime check inserted\n  believe: order.user.is_verified       // generates aggressive property tests to falsify\nfrom\n    // implementation\n</code></pre> <ul> <li><code>know</code> \u2014 Proven by the type system. Zero runtime cost. Compiler error if not actually provable.</li> <li><code>assume</code> \u2014 Compiler inserts runtime validation at system boundaries. Logged when violated.</li> <li><code>believe</code> \u2014 Compiler generates adversarial test cases specifically targeting this claim.</li> </ul> <p>AI has no model of its own uncertainty \u2014 it would either mark everything <code>know</code> (fails verification) or <code>assume</code> (wasteful and reveals lack of understanding).</p>"},{"location":"ai-resistance/#temporal-effect-ordering","title":"Temporal Effect Ordering","text":"<p>Not just what effects a function has, but the required order \u2014 enforced across function boundaries and call graphs.</p> <pre><code>module Auth\n  temporal: authenticate -&gt; authorize -&gt; access\n\n  inputs authenticate(creds Credentials) Token!\n  transforms authorize(token Token, resource Resource) Permission\n  inputs access(perm Permission, resource Resource) Data!\n\n// Compiler error: access() called before authorize()\ninputs bad_handler(req Request) Response!\nfrom\n    token as Token = authenticate(req.creds)!\n    data as Data = access(token, req.resource)!    // ERROR: skipped authorize\n</code></pre> <p>The compiler builds a call graph and verifies temporal constraints are satisfied across all execution paths. AI generates plausible call sequences but does not reason about protocol ordering.</p>"},{"location":"ai-resistance/#invariant-networks","title":"Invariant Networks","text":"<p>Instead of isolated <code>ensures</code> clauses, define networks of mutually-dependent invariants. Changing one cascades verification across the entire network.</p> <pre><code>invariant_network AccountingRules\n  total_assets == total_liabilities + equity\n  revenue - expenses == net_income\n  net_income flows_to equity\n  every(transaction) preserves total_assets == total_liabilities + equity\n\ntransforms post_transaction(ledger Ledger, tx Transaction) Ledger\n  satisfies AccountingRules\nfrom\n    // implementation\n</code></pre> <p>No function can be written in isolation \u2014 the compiler checks that the entire network remains consistent after every change. This is the ultimate non-local reasoning requirement. Requires a constraint solver that scales across modules.</p>"},{"location":"ai-resistance/#refutation-challenges","title":"Refutation Challenges","text":"<p>The compiler deliberately generates plausible-but-wrong alternative implementations and requires the programmer to explain why they fail. Compilation becomes a dialogue.</p> <pre><code>$ prove check src/sort.prv\n\nchallenge[C017]: Why doesn't this simpler implementation work?\n\n  transforms sort(xs List&lt;Integer&gt;) Sorted&lt;List&lt;Integer&gt;&gt;\n      reverse(dedup(xs))     // appears sorted for some inputs\n\n  refute: _______________\n\n  hint: Consider [3, 1, 2]\n</code></pre> <p>The programmer must provide a counterexample or logical argument. The compiler verifies the refutation is valid. This ensures the programmer understands not just what works, but why alternatives don't.</p>"},{"location":"ai-resistance/#phase-3-anti-training","title":"Phase 3 \u2014 Anti-Training","text":"<p>Phase 1 and 2 make it hard for AI to generate correct Prove code. Phase 3 goes further: making Prove source code resistant to being useful as AI training data. Even if scraped, Prove codebases should yield minimal learnable signal.</p> <p>AI training pipelines assume: (1) source code is plain text, (2) syntax is consistent across projects, (3) individual files are self-contained enough to learn from, and (4) surface patterns correlate with semantics. Prove attacks all four assumptions.</p>"},{"location":"ai-resistance/#project-specific-grammars","title":"Project-Specific Grammars","text":"<p>Each project can define syntactic extensions via its <code>prove.toml</code> manifest. Two Prove projects may look completely different at the surface level. Training data cannot generalize across projects.</p> <pre><code>// prove.toml\n[syntax]\npipe_operator = \"|&gt;\"\nmatch_arrow = \"=&gt;\"\n\n// Another project's prove.toml\n[syntax]\npipe_operator = \"&gt;&gt;\"\nmatch_arrow = \"-&gt;\"\n</code></pre> <pre><code>// Project A\nresult as List&lt;Data&gt; = data |&gt; filter(valid record) |&gt; map(transform)\n\n// Project B \u2014 same semantics, different surface\nresult as List&lt;Data&gt; = data &gt;&gt; filter(valid record) &gt;&gt; map(transform)\n</code></pre> <p>The compiler normalizes all syntax variants to the same AST. Scrapers see inconsistent syntax; the compiler sees identical programs. This destroys the statistical regularities that AI training depends on.</p>"},{"location":"ai-resistance/#structured-source-format-prv-is-not-plain-text","title":"Structured Source Format (<code>.prv</code> is not plain text)","text":"<p><code>.prv</code> files are stored as a compact binary AST, not human-readable text. The <code>prove</code> CLI provides views:</p> <pre><code>$ prove view src/server.prv              # pretty-print to terminal\n$ prove view src/server.prv --raw        # show the binary structure\n$ prove edit src/server.prv              # open in editor with LSP decoding\n$ prove export src/server.prv --text     # one-time text export\n</code></pre> <p>The editor experience is seamless \u2014 the language server decodes <code>.prv</code> on the fly, and the formatter writes binary back. But web scrapers, GitHub raw views, and training pipelines see binary blobs, not parseable source code.</p> <p>Why this works: Every major AI training pipeline (The Stack, StarCoder, etc.) filters for text files and parses by file extension. Binary files are discarded. Prove code is invisible to these pipelines by default.</p> <p>The <code>prove export --text</code> command exists for code review, diffs, and human sharing \u2014 but text is a view, not the source of truth.</p>"},{"location":"ai-resistance/#semantic-normalization-surface-patterns-destroyed","title":"Semantic Normalization (Surface Patterns Destroyed)","text":"<p>The compiler canonicalizes all code before storage. Variable names, ordering of declarations, whitespace, and stylistic choices are normalized away. What the programmer writes is not what is stored.</p> <pre><code>// What you write:\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\nfrom\n    subtotal as Decimal = sum(prices(items))\n    subtotal * (1 + tax.rate)\n\n// What is stored (canonical form):\ntransforms _f0(_a0 List&lt;_T0&gt;, _a1 _T1) _T2\nfrom\n    _v0 as _T3 = _f1(_f2(_a0))\n    _v0 * (1 + _a1._f3)\n\n// What you see (reconstructed with your naming via the LSP):\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\nfrom\n    subtotal as Decimal = sum(prices(items))\n    subtotal * (1 + tax.rate)\n</code></pre> <p>A name map is stored alongside the canonical AST. The LSP reconstructs human-readable code on demand. But the stored form strips all semantic signal from identifiers \u2014 AI cannot learn naming conventions, domain patterns, or stylistic habits from Prove source.</p>"},{"location":"ai-resistance/#fragmented-source-no-file-is-self-contained","title":"Fragmented Source (No File Is Self-Contained)","text":"<p>A function's complete definition is distributed across multiple sections that only make sense together:</p> <pre><code>src/\n  server.prv          # implementation (canonical binary AST)\n  server.explain      # implementation explanations for server.prv\n  server.intent       # intent declarations\n  server.near_miss    # adversarial near-miss examples\n  server.narrative    # module narrative\n</code></pre> <p>A scraper that grabs <code>server.prv</code> alone gets a canonical binary AST with no variable names, no comments, no documentation, and no explanations. The explain file without the implementation is meaningless. The intent file without both is noise.</p> <p>All five files are required to compile. The compiler assembles the complete picture. No single artifact is useful in isolation.</p>"},{"location":"ai-resistance/#identity-bound-compilation","title":"Identity-Bound Compilation","text":"<p>Source files carry a cryptographic signature chain. The compiler verifies authorship.</p> <pre><code>// Embedded in .prv binary header\n[signature]\nauthor = \"alice@example.com\"\nkey_fingerprint = \"A1B2C3...\"\nsigned_at = 2026-02-27T14:30:00Z\nchain = [\"alice@example.com\", \"bob@example.com\"]  // co-authors\n</code></pre> <ul> <li>Unsigned code triggers a compiler warning (or error in strict mode).</li> <li>The signature chain tracks who wrote and reviewed each function.</li> <li>Scraped code with stripped signatures won't compile.</li> <li>The compiler can optionally refuse to build code signed by unknown keys.</li> </ul> <p>This isn't DRM \u2014 it's provenance. The programmer can always export and re-sign. But mass scraping destroys the signature chain, making the code uncompilable.</p>"},{"location":"ai-resistance/#anti-training-license-as-default","title":"Anti-Training License as Default","text":"<p>Every <code>prove new</code> project is initialized with the Prove Source License v1.0 (see <code>LICENSE</code>). It is a permissive MIT-style license with comprehensive AI restrictions covering:</p> <ul> <li>Training, fine-tuning, and distillation (Section 3.1)</li> <li>Dataset inclusion, vector stores, RAG indices, and embedding databases (Section 3.2)</li> <li>Synthetic data generation from the Software (Section 3.3)</li> <li>Sublicensing for AI use \u2014 third parties cannot be granted AI rights (Section 3.4)</li> <li>Downstream propagation \u2014 all redistributors must carry the restrictions forward (Section 3.5)</li> <li>Technical protection circumvention \u2014 bypassing binary format, normalization, or signatures for AI training is a breach (Section 4)</li> </ul> <p>The license explicitly permits using AI tools to write Prove code and building AI-powered applications with Prove \u2014 it only prohibits using Prove source as training data.</p> <p>Design draws from: NON-AI-MIT (base structure), Common Paper (precise LLM language), Authors Guild (sublicensing prohibition), Open RAIL-S (downstream propagation). Should be reviewed by legal counsel before production use.</p> <p>This is not just a legal barrier \u2014 combined with the binary format and semantic normalization, it creates a layered defense: the code is hard to scrape, useless if scraped, and illegal to train on.</p>"},{"location":"ai-resistance/#the-fundamental-tension","title":"The Fundamental Tension","text":"<p>Every feature that makes code harder for AI also makes it harder for humans.</p> <p>The AI-resistance features force the programmer to:</p> <ul> <li>Explain their reasoning (proofs, intents, narratives, counterfactuals)</li> <li>Maintain global coherence (not just local correctness)</li> <li>Understand why, not just what (near-misses, refutation challenges)</li> <li>Acknowledge uncertainty (epistemic annotations)</li> <li>Respect temporal protocols (effect ordering)</li> </ul> <p>The uncomfortable truth is that the things AI is bad at are the things lazy humans skip too. A language that resists AI would also resist copy-paste programming, cargo-culting Stack Overflow, and coding without understanding.</p> <p>The anti-training features (binary format, semantic normalization, fragmented source) add friction to sharing and collaboration. The mitigation is a first-class toolchain: the <code>prove</code> CLI and LSP make the experience seamless for developers working inside the ecosystem, while making the code opaque to anything outside it.</p> <p>The design answers both questions: Prove resists AI writing the code (Phase 1 + 2) and resists AI training on the code (Phase 3).</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>Prove ships a single <code>prove</code> command with subcommands for building, checking, testing, formatting, and debugging.</p> <p>Requirements: Python 3.11+, gcc or clang</p>"},{"location":"cli/#prove-new-name","title":"<code>prove new &lt;name&gt;</code>","text":"<p>Create a new Prove project with scaffolding.</p> <pre><code>prove new hello\n</code></pre> <p>Creates a directory with <code>prove.toml</code>, <code>src/main.prv</code>, and a <code>.gitignore</code>.</p>"},{"location":"cli/#prove-build-path","title":"<code>prove build [path]</code>","text":"<p>Compile a Prove project to a native binary.</p> <pre><code>prove build\nprove build path/to/project\nprove build --mutate\n</code></pre> <p>Runs the full pipeline: lex, parse, check, prove, emit C, compile with gcc/clang.</p> Flag Description <code>--mutate</code> Enable mutation testing after build <p>The project directory must contain a <code>prove.toml</code>. Output binary is placed in <code>build/</code>.</p>"},{"location":"cli/#prove-check-path","title":"<code>prove check [path]</code>","text":"<p>Type-check Prove source without compiling.</p> <pre><code>prove check\nprove check src/main.prv\nprove check docs/tutorial.md --md\n</code></pre> Flag Description <code>--md</code> Also check <code>```prove</code> code blocks in Markdown files <p>When <code>path</code> is a <code>.prv</code> file, checks that single file. When <code>path</code> is a directory, finds <code>prove.toml</code> and checks all files in <code>src/</code>. When <code>path</code> is a <code>.md</code> file (with <code>--md</code>), checks all fenced Prove blocks.</p>"},{"location":"cli/#prove-test-path","title":"<code>prove test [path]</code>","text":"<p>Run contract-based tests generated from <code>ensures</code>, <code>believe</code>, and <code>near_miss</code> annotations.</p> <pre><code>prove test\nprove test --property-rounds 5000\n</code></pre> Flag Description <code>--property-rounds N</code> Override the number of property-test iterations (default: from <code>prove.toml</code>, usually 1000) <p>The compiler parses and checks the source, generates a C test harness from the contracts, compiles it, and executes the tests.</p>"},{"location":"cli/#prove-format-path","title":"<code>prove format [path]</code>","text":"<p>Format Prove source files.</p> <pre><code>prove format\nprove format src/main.prv\nprove format --check\nprove format --stdin &lt; src/main.prv\nprove format docs/ --md\n</code></pre> Flag Description <code>--check</code> Check formatting without modifying files (exit 1 if changes needed) <code>--stdin</code> Read from stdin, write formatted output to stdout <code>--md</code> Also format <code>```prove</code> blocks in Markdown files <p>Reformats all <code>.prv</code> files recursively under the given path. Files with parse errors are skipped.</p>"},{"location":"cli/#prove-lint-path","title":"<code>prove lint [path]</code>","text":"<p>Report formatting mismatches with line-by-line context.</p> <pre><code>prove lint\nprove lint src/\nprove lint --md\n</code></pre> Flag Description <code>--md</code> Also lint <code>```prove</code> blocks in Markdown files <p>Shows a diff-style comparison of actual vs. expected formatting.</p>"},{"location":"cli/#prove-view-file","title":"<code>prove view &lt;file&gt;</code>","text":"<p>Display the AST of a <code>.prv</code> file for debugging.</p> <pre><code>prove view src/main.prv\n</code></pre> <p>Prints a human-readable, indented representation of the parsed AST.</p>"},{"location":"cli/#prove-lsp","title":"<code>prove lsp</code>","text":"<p>Start the Prove language server (LSP protocol).</p> <pre><code>prove lsp\n</code></pre> <p>Used by editor integrations (VS Code, Neovim, etc.) for diagnostics, completions, and hover information. Communicates over stdio.</p>"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Error (compilation failed, check failed, tests failed, or formatting mismatch with <code>--check</code>)"},{"location":"compiler/","title":"Compiler Features","text":""},{"location":"compiler/#pipeline","title":"Pipeline","text":"<p>Prove compiles <code>.prv</code> source files to native binaries through a six-stage pipeline:</p> <pre><code>Source (.prv) \u2192 Lexer \u2192 Parser \u2192 Checker \u2192 Prover \u2192 C Emitter \u2192 gcc/clang \u2192 Native Binary\n</code></pre> Stage Input Output Key responsibility Lexer Source text Token stream Indent/dedent tracking, string interpolation, regex disambiguation Parser Token stream AST Pratt expression parsing, recursive descent for declarations Checker AST Typed AST + symbol table Type inference, verb enforcement, match exhaustiveness Prover AST + contracts Diagnostics Proof obligation verification, contract consistency C Emitter Typed AST C source Type mapping, name mangling, lambda hoisting, reference counting gcc/clang C source Native binary Optimization, linking with C runtime"},{"location":"compiler/#provetoml-configuration","title":"<code>prove.toml</code> Configuration","text":"<p>Every Prove project has a <code>prove.toml</code> at its root. The <code>prove new</code> command generates one with sensible defaults.</p> <pre><code>[package]\nname = \"hello\"\nversion = \"0.1.0\"\nauthors = []\nlicense = \"\"\n\n[build]\ntarget = \"native\"\noptimize = false\n\n[test]\nproperty_rounds = 1000\n\n[style]\nline_length = 90\n</code></pre> Section Key Default Effect <code>[package]</code> <code>name</code> <code>\"untitled\"</code> Package name, used for the output binary <code>version</code> <code>\"0.0.0\"</code> Semantic version <code>authors</code> <code>[]</code> Author names <code>license</code> <code>\"\"</code> License identifier <code>[build]</code> <code>target</code> <code>\"native\"</code> Build target <code>optimize</code> <code>false</code> Enable compiler optimizations <code>[test]</code> <code>property_rounds</code> <code>1000</code> Number of random inputs per property test (overridable with <code>--property-rounds</code>) <code>[style]</code> <code>line_length</code> <code>90</code> Maximum line length for the formatter"},{"location":"compiler/#conversational-errors","title":"Conversational Errors","text":"<p>Diagnostics are suggestions, not walls. Every error includes the source location, an explanation, and often a concrete fix:</p> <pre><code>error[E042]: `port` may exceed type bound\n  --&gt; server.prv:12:5\n   |\n12 |   port as Port = get_integer(config, \"port\")\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = note: `get_integer` returns Integer, but Port requires 1..65535\n\n   try: port as Port = clamp(get_integer(config, \"port\"), 1, 65535)\n    or: port as Port = check(get_integer(config, \"port\"))!\n</code></pre> <p>The compiler uses Rust-style diagnostic rendering with ANSI colors, span highlighting, and multi-line context.</p> <p>See Diagnostic Codes for the full list of error and warning codes.</p>"},{"location":"compiler/#comptime-compile-time-computation","title":"Comptime (Compile-Time Computation)","text":"<p>Inspired by Zig. Arbitrary computation at compile time, including IO. Files read during comptime become build dependencies \u2014 if the file changes, the module is recompiled.</p> <pre><code>MAX_CONNECTIONS as Integer = comptime\n  match cfg.target\n    \"embedded\" =&gt; 16\n    _ =&gt; 1024\n\nLOOKUP_TABLE as List&lt;Integer:[32 Unsigned]&gt; = comptime\n  collect(map(0..256, crc32_step))\n\nROUTES as List&lt;Route&gt; = comptime\n  decode(read(\"routes.json\"))         // IO allowed \u2014 routes.json becomes a build dep\n</code></pre>"},{"location":"compiler/#verb-enforcement","title":"Verb Enforcement","text":"<p>The compiler enforces purity rules based on the function's verb. Pure verbs (<code>transforms</code>, <code>validates</code>, <code>reads</code>, <code>creates</code>, <code>matches</code>) cannot perform side effects:</p> <ul> <li>Cannot call built-in IO functions like <code>println</code> or <code>read_file</code> (E362)</li> <li>Cannot call user-defined functions with IO verbs <code>inputs</code> or <code>outputs</code> (E363)</li> <li>Cannot be failable with <code>!</code> (E361)</li> </ul> <p>IO verbs (<code>inputs</code>, <code>outputs</code>) have no such restrictions.</p> <p>See Diagnostic Codes for details on each enforcement error.</p>"},{"location":"contracts/","title":"Contracts &amp; Testing","text":""},{"location":"contracts/#formal-verification-of-contracts","title":"Formal Verification of Contracts","text":"<p>The compiler proves properties when it can, and generates tests when it can't:</p> <pre><code>transforms binary_search(xs Sorted&lt;List&lt;Integer&gt;&gt;, target Integer) Option&lt;Index&gt;\n  ensures is_some(result) implies xs[unwrap(result)] == target\n  ensures is_none(result) implies target not_in xs\n</code></pre>"},{"location":"contracts/#contracts-by-example-why-this-matters","title":"Contracts by Example \u2014 Why This Matters","text":"<p>Prove's contract system is not syntactic sugar for assertions. It is a fundamentally different relationship between programmer intent and compiler enforcement. To see why, compare the same function \u2014 <code>calculate_total</code> \u2014 across four languages.</p>"},{"location":"contracts/#prove","title":"Prove","text":"<pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p>Two things happen at compile time:</p> <ul> <li><code>requires</code> \u2014 The compiler rejects any call site that cannot prove <code>len(items) &gt; 0</code>. This is not a runtime check. If your list might be empty, the code does not compile.</li> <li><code>ensures</code> \u2014 The compiler verifies that every code path produces <code>result &gt;= 0</code>. If it cannot prove this statically, it generates property tests that exercise thousands of inputs.</li> </ul> <p>These are hard rules \u2014 the compiler enforces them automatically.</p> <p>When the implementation has multiple steps, <code>explain</code> documents the chain of operations using controlled natural language. With <code>ensures</code> present (strict mode), the row count must match the <code>from</code> block and the compiler verifies references against contracts:</p> <pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\n  explain\n    sum all items.price\n    reduce sub by discount\n    add tax to discounted\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p><code>requires</code> and <code>ensures</code> are about the function's interface. <code>explain</code> is about the function's implementation \u2014 it documents how each step satisfies the promises.</p> <p><code>explain</code> is LSP-suggested, not compiler-required. Simple functions with <code>ensures</code> don't need it \u2014 the LSP suggests it when complexity warrants documentation. However, <code>ensures</code> without <code>explain</code> produces a warning: if you promise, explain how.</p>"},{"location":"contracts/#python","title":"Python","text":"<pre><code>def calculate_total(items: list[OrderItem], discount: Discount, tax: TaxRule) -&gt; Price:\n    \"\"\"Calculate order total after discount and tax.\n\n    Args:\n        items: must be non-empty\n        discount: discount to apply\n        tax: tax rule to apply\n\n    Returns:\n        total price, always &gt;= 0\n    \"\"\"\n    assert len(items) &gt; 0  # only checked if -O is not set\n    sub = subtotal(items)\n    discounted = apply_discount(discount, sub)\n    result = apply_tax(tax, discounted)\n    assert result &gt;= 0  # also stripped by -O\n    return result\n</code></pre> <ul> <li>Preconditions \u2014 <code>assert</code> statements, stripped by <code>python -O</code>. The type hint <code>list[OrderItem]</code> says nothing about length. An empty list passes type checking and reaches runtime.</li> <li>Postconditions \u2014 Another <code>assert</code>, also stripped in production. The docstring says \"always &gt;= 0\" but nothing enforces it.</li> <li>Proof \u2014 Does not exist. The docstring is a comment. Tests are a separate file written by a separate person at a separate time.</li> </ul>"},{"location":"contracts/#haskell","title":"Haskell","text":"<pre><code>calculateTotal :: NonEmpty OrderItem -&gt; Discount -&gt; TaxRule -&gt; Price\n-- | Precondition: items is non-empty (enforced by NonEmpty type)\n-- | Postcondition: result &gt;= 0 (NOT enforced \u2014 Price is just a newtype)\ncalculateTotal items discount tax =\n  let sub = subtotal (toList items)\n      discounted = applyDiscount discount sub\n  in applyTax tax discounted\n</code></pre> <ul> <li>Preconditions \u2014 <code>NonEmpty</code> enforces non-emptiness at the type level. This is genuinely good. But most preconditions (\"discount is valid\", \"tax rate is between 0 and 1\") require dependent types that Haskell does not have.</li> <li>Postconditions \u2014 Comments. The type <code>Price</code> does not carry the invariant <code>&gt;= 0</code> unless you build a custom smart constructor, and even then the compiler does not verify that <code>applyTax</code> preserves it.</li> <li>Proof \u2014 Does not exist in the language. QuickCheck can test properties, but it is a library, it is opt-in, and the properties are written in test files separate from the function.</li> </ul>"},{"location":"contracts/#rust","title":"Rust","text":"<pre><code>fn calculate_total(items: &amp;[OrderItem], discount: &amp;Discount, tax: &amp;TaxRule) -&gt; Price {\n    debug_assert!(!items.is_empty(), \"items must be non-empty\");\n    let sub = subtotal(items);\n    let discounted = apply_discount(discount, sub);\n    let result = apply_tax(tax, discounted);\n    debug_assert!(result &gt;= Price::ZERO, \"result must be non-negative\");\n    result\n}\n</code></pre> <ul> <li>Preconditions \u2014 <code>debug_assert!</code>, compiled out in release builds. The slice type <code>&amp;[OrderItem]</code> permits empty slices. A <code>NonEmpty</code> wrapper exists in crates but is not standard.</li> <li>Postconditions \u2014 Another <code>debug_assert!</code>, also absent in release. The type system enforces memory safety but says nothing about business logic invariants.</li> <li>Proof \u2014 Does not exist. Tests are in a <code>#[cfg(test)]</code> module. Property testing requires <code>proptest</code> or <code>quickcheck</code> crates, and properties are written manually in test files.</li> </ul>"},{"location":"contracts/#summary","title":"Summary","text":"Capability Prove Python Haskell Rust Preconditions <code>requires</code> \u2014 compile-time enforced <code>assert</code> \u2014 runtime, strippable Types cover some; rest are comments <code>debug_assert!</code> \u2014 stripped in release Postconditions <code>ensures</code> \u2014 compiler-verified or auto-tested <code>assert</code> \u2014 runtime, strippable Comments or smart constructors (manual) <code>debug_assert!</code> \u2014 stripped in release Implementation reasoning <code>explain</code> \u2014 checked by compiler Does not exist Does not exist Does not exist Test generation Automatic from contracts Manual (pytest, hypothesis) Manual (QuickCheck) Manual (proptest) Contracts are... Part of the function signature, compiler-enforced Optional, easily ignored Convention, not enforced Convention, not enforced <p>The gap is not about syntax. Python, Haskell, and Rust all have mechanisms for expressing some of these ideas. The difference is that in Prove, contracts are compiler-enforced and self-testing. You cannot write a function that silently ignores its own guarantees.</p>"},{"location":"contracts/#auto-testing","title":"Auto-Testing","text":"<p>Testing is not a separate activity. It is woven into the language \u2014 contracts are mandatory and the compiler enforces them.</p>"},{"location":"contracts/#level-1-contracts-generate-property-tests","title":"Level 1: Contracts Generate Property Tests","text":"<p>No test file needed. No QuickCheck boilerplate. The compiler generates thousands of random inputs and verifies all postconditions hold. Contracts are mandatory \u2014 every function declares what it guarantees.</p> <pre><code>transforms sort(xs List&lt;T&gt;) List&lt;T&gt;\n  ensures len(result) == len(xs)\n  ensures is_sorted(result)\n  ensures is_permutation_of(result, xs)\nfrom\n    // implementation\n</code></pre>"},{"location":"contracts/#level-2-automatic-edge-case-generation","title":"Level 2: Automatic Edge-Case Generation","text":"<p>Given the type signature alone, the compiler knows to test boundary values and heuristic edge cases:</p> <pre><code>transforms divide(a Integer, b NonZero&lt;Integer&gt;) Integer\n// Auto-generated test inputs: (0, 1), (1, 1), (-1, 1), (MAX_INT, 1),\n// (MIN_INT, -1), (7, 3), ...\n// Derived from type bounds + heuristic edge-case generation\n</code></pre> <p>For refinement types, boundary testing is automatic:</p> <pre><code>transforms set_port(p Port) Config    // Port = 1..65535\n// Auto-tests: 1, 2, 65534, 65535, and random values between\n// Also verifies that 0 and 65536 are rejected at the call site\n</code></pre>"},{"location":"contracts/#level-3-near_miss-boundary-witnesses","title":"Level 3: <code>near_miss</code> \u2014 Boundary Witnesses","text":"<p>A <code>near_miss</code> declares an input that should fail a contract. The compiler verifies that the function's <code>requires</code> or <code>validates</code> clauses actually reject it. This catches contracts that are too permissive.</p> <pre><code>transforms leap_year(y Integer) Boolean\n  requires y &gt; 0\n  near_miss 0 =&gt; rejected       // not a valid year\n  near_miss -1 =&gt; rejected      // negative year\nfrom\n    (y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0\n</code></pre> <p>The compiler generates tests that pass each <code>near_miss</code> input to the function and confirms it is rejected by the preconditions. If a <code>near_miss</code> input is accidentally accepted, the test fails \u2014 the contract has a gap.</p>"},{"location":"contracts/#level-4-built-in-mutation-testing","title":"Level 4: Built-in Mutation Testing","text":"<pre><code>$ prove build --mutate\n\nMutation score: 97.2% (347/357 mutants killed)\nSurviving mutants:\n  src/cache.prv:45  \u2014 changed `&gt;=` to `&gt;` (boundary condition not covered)\n  src/cache.prv:82  \u2014 removed `+ 1` (off-by-one not detected)\n\n  Suggested contract to add:\n    ensures len(cache) &lt;= max_size   // would kill both mutants\n</code></pre>"},{"location":"contracts/#verification-chain","title":"Verification Chain","text":"<p><code>ensures</code> requirements propagate through the call graph. If function A has <code>ensures</code> and calls function B, the compiler needs B's contracts to verify A's postconditions. If B has no <code>ensures</code>, the verification has a gap \u2014 the compiler warns.</p> <pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p>If <code>subtotal</code> has <code>ensures result &gt;= 0</code>, the compiler can verify the chain. If it doesn't, the compiler warns that <code>calculate_total</code>'s verification depends on an unverified function.</p>"},{"location":"contracts/#when-ensures-is-expected","title":"When <code>ensures</code> is expected","text":"<p>The compiler warns when <code>ensures</code> is missing on:</p> <ul> <li>Functions in a verification chain \u2014 called by a function that has <code>ensures</code></li> <li>IO functions (<code>inputs</code>/<code>outputs</code>) \u2014 API boundaries where contracts matter</li> <li>Exported functions \u2014 callers outside the module need guarantees</li> </ul> <p>Functions outside any verification chain \u2014 trivial helpers, internal plumbing \u2014 are fine without annotations.</p>"},{"location":"contracts/#trusted-explicit-opt-out","title":"<code>trusted</code> \u2014 explicit opt-out","text":"<p>When a function is in a verification chain but you don't want to add contracts yet, <code>trusted</code> acknowledges the gap:</p> <pre><code>transforms subtotal(items List&lt;OrderItem&gt;) Price\n  trusted: \"sum of non-negative prices is non-negative\"\nfrom\n    reduce(items, 0, |acc, item| acc + item.price)\n</code></pre> <p>The compiler stops warning. <code>prove check</code> reports trusted functions in its verification coverage summary.</p>"},{"location":"contracts/#near_miss-lsp-suggested-for-validators","title":"<code>near_miss</code> \u2014 LSP-suggested for validators","text":"<p>The LSP suggests <code>near_miss</code> for <code>validates</code> functions with compound logic \u2014 multiple <code>&amp;&amp;</code>/<code>||</code>, modular arithmetic, negation. Trivial validators (single field access, simple equality) get no suggestion. <code>near_miss</code> proves the programmer understands the exact boundary between valid and invalid inputs.</p>"},{"location":"design/","title":"Design Decisions &amp; Trade-offs","text":""},{"location":"design/#philosophy","title":"Philosophy","text":"<p>The compiler is your co-author, not your gatekeeper.</p> <p>Every feature exists to move correctness checks from runtime to compile time, and to generate tests from the code you already write. Most bugs are type errors in disguise \u2014 give the type system enough power and they become almost impossible.</p>"},{"location":"design/#implementation-decisions","title":"Implementation Decisions","text":""},{"location":"design/#file-extension-prv","title":"File Extension: <code>.prv</code>","text":"<p>Investigated <code>.pv</code>, <code>.prove</code>, <code>.prf</code>, <code>.pr</code>, and <code>.prv</code>. Chosen: <code>.prv</code> \u2014 short, reads naturally as \"Prove\", and has no conflicts with existing programming languages or developer tooling.</p> Rejected Reason <code>.pv</code> Taken by ProVerif (formal methods \u2014 same domain, high confusion risk) <code>.prove</code> Taken by Perl's <code>prove</code> test harness (well-known in dev tooling) <code>.prf</code> Taken by MS Outlook profiles and Qt feature files <code>.pr</code> Legacy Source Insight 3, but \"PR\" universally means \"pull request\""},{"location":"design/#prototype-implementation-python","title":"Prototype Implementation: Python","text":"<p>The compiler POC is implemented in Python (&gt;=3.11). The goal is to validate the language design and prove out the compilation pipeline before rewriting in a systems language.</p>"},{"location":"design/#compilation-target-native-code","title":"Compilation Target: Native Code","text":"<p>As close to the CPU as possible. The compiler does the heavy lifting at compile time so the output is fast and memory-efficient. Target: native code via direct assembly emission (x86_64 + ARM64). No VM, no interpreter for production output.</p>"},{"location":"design/#first-poc-self-hosting-compiler","title":"First POC: Self-Hosting Compiler","text":"<p>The first program written in Prove will be the Prove compiler itself. The bootstrap path: (1) write a complete compiler in Python, (2) use it to compile a Prove compiler written in Prove. This exercises the type system (AST node types, token variants), verb system (transforms for pure passes, inputs for file reading, outputs for code emission), pattern matching (exhaustive over AST nodes), and algebraic types \u2014 proving the language works by compiling itself. Self-hosting is the strongest possible validation: if Prove can express its own compiler, it can express anything.</p>"},{"location":"design/#ai-resistance-fundamental","title":"AI-Resistance: Fundamental","text":"<p>AI-resistance features (implementation explanations, intent declarations, narrative coherence, context-dependent syntax, semantic commits) are mandatory and fundamental to the language identity, not optional extras. <code>requires</code> and <code>ensures</code> are hard rules the compiler enforces automatically. <code>explain</code> documents the chain of operations in the implementation using controlled natural language \u2014 with <code>ensures</code> present, references are verified against contracts and row count must match the <code>from</code> block.</p>"},{"location":"design/#comptime-io-allowed","title":"Comptime: IO Allowed","text":"<p>Compile-time computation (<code>comptime</code>) allows IO operations. This enables reading config files, schema definitions, and static assets at compile time. Files accessed during comptime become build dependencies \u2014 changing them triggers recompilation. This may be revisited if reproducibility concerns arise.</p>"},{"location":"design/#cli-first-toolchain-prove","title":"CLI-First Toolchain: <code>prove</code>","text":"<p>The <code>prove</code> CLI is the central interface for all development:</p> <pre><code>prove build          # compile the project\nprove test           # run auto-generated + manual tests\nprove check          # type-check without building\nprove format         # auto-format source code\nprove lsp            # start the language server\nprove build --mutate # run mutation testing\nprove new &lt;name&gt;     # scaffold a new project\n</code></pre>"},{"location":"design/#syntax-philosophy","title":"Syntax Philosophy","text":"<p>No shorthands. No abbreviations. Full words everywhere. The language reads like English prose where possible. Since it is inherently a hard-to-learn language (refinement types, implementation explanations, effect tracking), simplicity is maximized wherever possible. If something can be simple, it must be. The compiler works for the programmer, not the other way around.</p>"},{"location":"design/#secondary-priorities-deferred","title":"Secondary Priorities (Deferred)","text":"<ul> <li>C FFI \u2014 important but not day-one. Will be addressed after the core language is stable.</li> <li>Calling Prove from other languages \u2014 deferred until the FFI story is established.</li> <li>Method syntax \u2014 deferred. All function calls use <code>function(args)</code> form. No <code>object.method()</code> dot-call syntax. Keeps the language simple and avoids dispatch complexity. Field access (<code>user.name</code>) is unaffected.</li> </ul>"},{"location":"design/#concurrency-structured-typed-no-data-races","title":"Concurrency \u2014 Structured, Typed, No Data Races","text":"<pre><code>inputs fetch_all(urls List&lt;Url&gt;) List&lt;Response&gt;!\nfrom\n    par_map(urls, fetch)\n</code></pre> <p>The ownership system and effect types combine to eliminate data races at compile time.</p>"},{"location":"design/#error-handling-errors-are-values","title":"Error Handling \u2014 Errors Are Values","text":"<p>No exceptions. Every failure path is visible in the type signature. Uses <code>!</code> for error propagation. Panics exist only for violated <code>assume:</code> assertions at system boundaries \u2014 normal error handling is always through <code>Result</code> values.</p> <pre><code>main()!\nfrom\n    config as Config = read_config(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"design/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<ul> <li>Pure functions auto-memoized and inlined</li> <li>Region-based memory for short-lived allocations</li> <li>Reference counting only where ownership is shared (compiler-inserted)</li> <li>No GC pauses, predictable performance</li> <li>Native code output</li> </ul>"},{"location":"design/#pain-point-comparison","title":"Pain Point Comparison","text":"Pain in existing languages How Prove solves it Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit (<code>inputs</code>/<code>outputs</code>) Null/nil crashes No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by compiler Race conditions Ownership + verb system prevents data races \"I forgot an edge case\" Compiler generates edge cases from types Slow test suites Property tests run at compile time when provable Runtime type errors Refinement types catch invalid values at compile time"},{"location":"design/#trade-offs","title":"Trade-offs","text":"<p>An honest assessment of the costs:</p> <ol> <li>Compilation speed \u2014 Proving properties is expensive. Incremental compilation and caching are essential. Expect Rust-like compile times, not Go-like.</li> <li>Learning curve \u2014 Refinement types and effect types are unfamiliar to most developers. The compiler's suggestions help, but there's still a ramp-up.</li> <li>Ecosystem bootstrap \u2014 A new language needs libraries. A C FFI and a story for wrapping existing libraries is a secondary priority, deferred until the core language is stable.</li> <li>Not every property is provable \u2014 For complex invariants the compiler falls back to runtime property tests, which is still better than nothing but not a proof.</li> </ol> <p>The core bet: Making the compiler do more work upfront saves orders of magnitude more time than writing and maintaining tests by hand.</p>"},{"location":"diagnostics/","title":"Diagnostic Codes","text":"<p>The Prove compiler emits errors and warnings with unique codes. Each diagnostic includes the source location, an explanation, and often a suggestion for how to fix it.</p>"},{"location":"diagnostics/#verb-enforcement-e360-e364","title":"Verb Enforcement (E360-E364)","text":"<p>These errors enforce the purity rules of the verb system. Pure verbs (<code>transforms</code>, <code>validates</code>, <code>reads</code>, <code>creates</code>, <code>matches</code>) cannot perform side effects.</p>"},{"location":"diagnostics/#e360-validates-has-implicit-boolean-return","title":"E360 \u2014 <code>validates</code> has implicit Boolean return","text":"<p>A <code>validates</code> function always returns <code>Boolean</code>. Declaring an explicit return type is an error.</p> <pre><code>validates is_active(u User) Boolean\nfrom\n    u.active\n\nvalidates is_active(u User)\nfrom\n    u.active\n</code></pre>"},{"location":"diagnostics/#e361-pure-function-cannot-be-failable","title":"E361 \u2014 Pure function cannot be failable","text":"<p>Functions with pure verbs cannot use the <code>!</code> fail marker. Pure functions do not perform IO and therefore cannot fail.</p> <pre><code>transforms double(x Integer) Integer!\nfrom\n    x * 2\n\ntransforms double(x Integer) Integer\nfrom\n    x * 2\n</code></pre>"},{"location":"diagnostics/#e362-pure-function-cannot-call-io-builtin","title":"E362 \u2014 Pure function cannot call IO builtin","text":"<p>A function with a pure verb cannot call built-in IO functions such as <code>println</code>, <code>print</code>, <code>readln</code>, <code>read_file</code>, <code>write_file</code>, <code>open</code>, <code>close</code>, <code>flush</code>, or <code>sleep</code>.</p> <pre><code>transforms greet(name String) String\nfrom\n    println(\"Hello\")\n    name\n\noutputs greet(name String)\nfrom\n    println(f\"Hello, {name}\")\n</code></pre>"},{"location":"diagnostics/#e363-pure-function-cannot-call-user-defined-io-function","title":"E363 \u2014 Pure function cannot call user-defined IO function","text":"<p>A function with a pure verb cannot call a user-defined function that uses an IO verb (<code>inputs</code> or <code>outputs</code>).</p> <pre><code>outputs save(data String)\nfrom\n    write_file(\"out.txt\", data)\n\ntransforms process(data String) String\nfrom\n    save(data)\n    data\n</code></pre>"},{"location":"diagnostics/#e364-lambda-captures-variable-closures-not-supported","title":"E364 \u2014 Lambda captures variable (closures not supported)","text":"<p>Lambdas cannot reference variables from an enclosing scope. All values must be passed as arguments.</p> <pre><code>transforms scale_all(xs List&lt;Integer&gt;, factor Integer) List&lt;Integer&gt;\nfrom\n    map(xs, |x| x * factor)\n</code></pre>"},{"location":"diagnostics/#e365-ambiguous-io-verb-declaration","title":"E365 \u2014 Ambiguous IO verb declaration","text":"<p>Two IO verbs (<code>inputs</code> and <code>outputs</code>) cannot declare functions with the same name and parameter types. If the compiler can't disambiguate, neither can the programmer.</p> <pre><code>// Wrong \u2014 same name, same params, both IO\ninputs sync(data Data, server Server) Data!       // E365\noutputs sync(data Data, server Server) Data!\n\n// Correct \u2014 use distinct names\ninputs fetch_sync(data Data, server Server) Data!\noutputs push_sync(data Data, server Server) Data!\n</code></pre>"},{"location":"diagnostics/#e366-recursive-function-missing-terminates","title":"E366 \u2014 Recursive function missing <code>terminates</code>","text":"<p>Every recursive function must declare a <code>terminates</code> measure expression. The compiler uses this to verify that the recursion converges.</p> <pre><code>transforms factorial(n Integer) Integer\nfrom\n    match n\n        0 =&gt; 1\n        _ =&gt; n * factorial(n - 1)\n\ntransforms factorial(n Integer) Integer\n  terminates: n\nfrom\n    match n\n        0 =&gt; 1\n        _ =&gt; n * factorial(n - 1)\n</code></pre>"},{"location":"diagnostics/#explain-contract-verification-e390-e394","title":"Explain &amp; Contract Verification (E390-E394)","text":"<p>These diagnostics enforce the relationship between contracts (<code>ensures</code>, <code>requires</code>, <code>believe</code>) and implementation explanations.</p>"},{"location":"diagnostics/#e390-explain-row-count-mismatch","title":"E390 \u2014 <code>explain</code> row count mismatch","text":"<p>When <code>explain</code> is present alongside <code>ensures</code> (strict mode), the number of explain rows must exactly match the number of lines in the <code>from</code> block. A mismatch is a compiler error.</p> <pre><code>// Wrong \u2014 2 explain rows but 3 from lines\ntransforms clamp(x Integer, lo Integer, hi Integer) Integer\n  ensures result &gt;= lo\n  ensures result &lt;= hi\n  explain\n    bound the value from below                     // E390 \u2014 2 rows, 3 lines\n    bound the value from above\nfrom\n    clamped_low as Integer = max(lo, x)\n    clamped as Integer = min(clamped_low, hi)\n    clamped\n\n// Correct \u2014 3 explain rows match 3 from lines\ntransforms clamp(x Integer, lo Integer, hi Integer) Integer\n  ensures result &gt;= lo\n  ensures result &lt;= hi\n  explain\n    bound value from below using lo\n    bound clamped_low from above using hi\n    return the clamped result\nfrom\n    clamped_low as Integer = max(lo, x)\n    clamped as Integer = min(clamped_low, hi)\n    clamped\n</code></pre> <p>Note: <code>ensures</code> without <code>explain</code> is a warning, not an error \u2014 the LSP suggests adding explain to document how the postconditions are satisfied. Similarly, <code>explain</code> without <code>ensures</code> produces a warning: the explain is unverifiable without contracts to check against.</p>"},{"location":"diagnostics/#e391-duplicate-explain-row","title":"E391 \u2014 Duplicate explain row","text":"<p>Each explain row must be distinct. Duplicate rows indicate copy-paste errors.</p> <pre><code>transforms abs(x Integer) Integer\n  ensures result &gt;= 0\n  explain\n    take the maximum of x and negated x\n    take the maximum of x and negated x            // E391 \u2014 duplicate\nfrom\n    candidate as Integer = 0 - x\n    max(x, candidate)\n</code></pre>"},{"location":"diagnostics/#e392-explain-reference-not-found","title":"E392 \u2014 <code>explain</code> reference not found","text":"<p>In strict mode (with <code>ensures</code>), the compiler verifies that references in explain rows correspond to real identifiers in the function. An unrecognized reference that isn't a sugar word triggers this error.</p> <pre><code>transforms double(x Integer) Integer\n  ensures result == x * 2\n  explain\n    multiply foo by two                            // E392 \u2014 `foo` not found\nfrom\n    x * 2\n</code></pre>"},{"location":"diagnostics/#e393-believe-without-ensures","title":"E393 \u2014 <code>believe</code> without <code>ensures</code>","text":"<p>The <code>believe</code> keyword is a weaker assertion that still requires <code>ensures</code> to be present on the function.</p> <pre><code>// Wrong \u2014 believe without ensures\ntransforms add(a Integer, b Integer) Integer\n  believe result &gt; 0                               // E393\nfrom\n    a + b\n\n// Correct\ntransforms add(a Integer, b Integer) Integer\n  ensures result == a + b\n  believe result &gt; 0\nfrom\n    a + b\n</code></pre>"},{"location":"diagnostics/#e394-explain-operation-not-recognized","title":"E394 \u2014 <code>explain</code> operation not recognized","text":"<p>In strict mode (with <code>ensures</code>), the compiler parses each explain row for a known operation (action verb). If no recognized operation is found and the word isn't in the custom vocabulary, this error is emitted.</p> <pre><code>transforms abs(x Integer) Integer\n  ensures result &gt;= 0\n  explain\n    frobulate x into a positive value              // E394 \u2014 `frobulate` not a known operation\nfrom\n    max(x, 0 - x)\n</code></pre> <p>Custom operations can be declared in <code>prove.toml</code> under <code>[explain].operations</code>.</p>"},{"location":"diagnostics/#warnings","title":"Warnings","text":""},{"location":"diagnostics/#w321-explain-text-missing-concept-references","title":"W321 \u2014 <code>explain</code> text missing concept references","text":"<p>An explain row should reference at least one concept from the function \u2014 a parameter name, a variable, or <code>result</code>. Rows that reference none of these are likely too vague to be useful.</p> <pre><code>transforms double(x Integer) Integer\n  ensures result == x * 2\n  explain\n    this is obvious                                // W321 \u2014 doesn't mention x, result, or double\nfrom\n    x * 2\n</code></pre>"},{"location":"diagnostics/#w322-duplicate-near-miss-input","title":"W322 \u2014 Duplicate near-miss input","text":"<p>Two <code>near_miss</code> declarations on the same function have identical input expressions.</p> <pre><code>transforms parse_port(s String) Option&lt;Port&gt;\n  near_miss \"\" =&gt; None\n  near_miss \"\" =&gt; None                             // W322\nfrom\n    // ...\n</code></pre>"},{"location":"diagnostics/#w323-ensures-without-explain","title":"W323 \u2014 <code>ensures</code> without <code>explain</code>","text":"<p>A function has postconditions but no <code>explain</code> block. If you promise, explain how. The LSP will suggest adding explain.</p> <pre><code>transforms clamp(x Integer, lo Integer, hi Integer) Integer\n  ensures result &gt;= lo\n  ensures result &lt;= hi\nfrom\n    max(lo, min(x, hi))\n</code></pre>"},{"location":"diagnostics/#w324-ensures-without-requires","title":"W324 \u2014 <code>ensures</code> without <code>requires</code>","text":"<p>A function has postconditions but no preconditions. This is a warning, not an error \u2014 it may be intentional, but often indicates missing input constraints.</p> <pre><code>transforms head(xs List&lt;T&gt;) T\n  ensures result == xs[0]\nfrom\n    xs[0]\n</code></pre>"},{"location":"diagnostics/#w325-explain-without-ensures","title":"W325 \u2014 <code>explain</code> without <code>ensures</code>","text":"<p>An <code>explain</code> block is present but there are no <code>ensures</code> clauses. Without contracts to check against, the explain is unverifiable \u2014 it serves as documentation only.</p> <pre><code>transforms double(x Integer) Integer\n  explain\n    multiply x by two                              // W325 \u2014 no ensures to verify against\nfrom\n    x * 2\n</code></pre>"},{"location":"diagnostics/#w326-recursion-depth-may-be-unbounded","title":"W326 \u2014 Recursion depth may be unbounded","text":"<p>A recursive function's <code>terminates</code> measure decreases by a constant amount per call, suggesting O(n) call depth. Consider using <code>map</code>, <code>filter</code>, or <code>reduce</code> via the pipe operator instead.</p> <pre><code>transforms sum_all(xs List&lt;Integer&gt;) Integer\n  terminates: len(xs)                              // W326 \u2014 O(n) depth\nfrom\n    match xs\n        [] =&gt; 0\n        [head, ...tail] =&gt; head + sum_all(tail)\n\n// Preferred: use reduce\ntransforms sum_all(xs List&lt;Integer&gt;) Integer\nfrom\n    reduce(xs, 0, |acc, x| acc + x)\n</code></pre>"},{"location":"inspirations/","title":"Design Inspirations","text":"Language What Prove borrows What Prove avoids Rust Ownership model, exhaustive matching, no null Lifetime annotation burden, borrow checker complexity Haskell Type system, pure functions, algebraic types IO monad complexity, lazy evaluation surprises Go Parameter syntax (<code>name Type</code>), simplicity as goal Weak type system, error handling verbosity Python Indentation-based blocks, readability philosophy Dynamic typing, runtime errors Zig <code>comptime</code> (compile-time computation with IO) Manual memory management Ada/SPARK Contract-based programming, formal verification Verbose syntax Idris/Agda Dependent types for encoding invariants Academic accessibility barrier Elm Eliminating runtime exceptions, compiler as assistant Limited to frontend F# Pragmatic algebraic types, pipeline operator \u2014"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#version-history","title":"Version History","text":"Version Status Description v0.1 Complete Core pipeline \u2014 lexer, parser, checker, prover, C emitter, native binaries v0.2 Complete (archived) ASM backend reference implementation (x86_64) v0.3 Complete Legacy stdlib cleanup, <code>List</code> module v0.4 Complete Pure verbs, binary types, namespaced calls, channel dispatch \u2014 394 tests v0.5 Planned Turbo runtime \u2014 arena allocator, fast hash, string intern v0.6 Planned Core stdlib \u2014 Character, Text, Table v0.7 Planned IO extensions and Parse v1.0 Planned Self-hosting compiler"},{"location":"roadmap/#planned-versions","title":"Planned Versions","text":""},{"location":"roadmap/#v05-turbo-runtime","title":"v0.5 \u2014 Turbo Runtime","text":"<p>High-performance C runtime primitives that the stdlib builds on:</p> <ul> <li>Arena allocator \u2014 bump-pointer allocation, eliminates per-object malloc and reference counting in hot paths.</li> <li>Fast hash \u2014 hardware CRC32 hash (x86_64 + ARM64 with software fallback) for hash tables and string interning.</li> <li>String intern table \u2014 string deduplication so that string comparisons become pointer equality.</li> </ul>"},{"location":"roadmap/#v06-core-stdlib","title":"v0.6 \u2014 Core Stdlib","text":"<p>The three data modules the self-hosted compiler needs most:</p> <ul> <li>Character \u2014 character classification (<code>alpha</code>, <code>digit</code>, <code>space</code>, etc.) and indexed access into strings.</li> <li>Text \u2014 string querying (<code>contains</code>, <code>starts_with</code>, <code>index_of</code>), transformation (<code>split</code>, <code>join</code>, <code>trim</code>, <code>replace</code>), and <code>Builder</code> for efficient string construction.</li> <li>Table \u2014 hash map from <code>String</code> keys to values. Uses the turbo runtime's fast hash internally.</li> </ul>"},{"location":"roadmap/#v07-io-extensions-and-parse","title":"v0.7 \u2014 IO Extensions and Parse","text":"<p>Extend <code>InputOutput</code> with the channels the compiler needs, and add structured format parsing:</p> <ul> <li>InputOutput extensions \u2014 <code>system</code> (process execution via fork/exec), <code>dir</code> (directory listing and creation), <code>process</code> (command-line arguments), and <code>validates</code> verbs for existence checks on all channels.</li> <li>Parse \u2014 format codecs with a two-function pattern: <code>creates toml(source)</code> decodes, <code>reads toml(value)</code> encodes. Same for JSON. Additional formats follow the same pattern.</li> </ul>"},{"location":"roadmap/#v10-self-hosting","title":"v1.0 \u2014 Self-Hosting","text":"<p>Rewrite the Prove compiler in Prove and compile it with the Python bootstrap compiler:</p> <ol> <li>Python compiler compiles compiler <code>.prv</code> source to a native binary.</li> <li>That binary compiles the same source again.</li> <li>If both produce identical output, the compiler is self-hosting.</li> </ol> <p>The Python compiler remains as the bootstrap. Estimated at ~5,900 lines of Prove (vs ~10,800 lines of Python) thanks to algebraic types and pattern matching replacing <code>isinstance</code> dispatch.</p>"},{"location":"roadmap/#ecosystem","title":"Ecosystem","text":"Project Description tree-sitter-prove Tree-sitter grammar for editor syntax highlighting pygments-prove Pygments lexer for MkDocs and Sphinx code rendering chroma-lexer-prove Chroma lexer for Gitea and Hugo code rendering"},{"location":"stdlib/","title":"Standard Library","text":"<p>The Prove standard library is a set of modules that ship with the compiler. Each module is a <code>.prv</code> file declaring types and function signatures, backed by a C implementation that the compiler links into the final binary.</p>"},{"location":"stdlib/#design-pattern","title":"Design Pattern","text":"<p>Stdlib modules follow a consistent pattern:</p> <ol> <li>One cohesive domain per module \u2014 don't mix unrelated concerns.</li> <li>Function name = the noun \u2014 the thing being operated on.</li> <li>Verb = the action \u2014 what you do with it.</li> <li>Same name + different verb = channel dispatch \u2014 the compiler resolves which function to call based on the verb at the call site.</li> </ol>"},{"location":"stdlib/#verb-families","title":"Verb Families","text":"<p>Verbs fall into two families. Pure verbs have no side effects \u2014 the compiler enforces this:</p> Verb Intent Example <code>transforms</code> Convert data from one form to another <code>transforms trim(s String) String</code> <code>validates</code> Check a condition, return Boolean <code>validates has(key String, table Table&lt;V&gt;)</code> <code>reads</code> Extract or query data without changing it <code>reads get(key String, table Table&lt;V&gt;) Option&lt;V&gt;</code> <code>creates</code> Construct a new value from scratch <code>creates builder() Builder</code> IO verbs interact with the outside world: Verb Intent Example <code>inputs</code> Read from an external source <code>inputs file(path String) String!</code> <code>outputs</code> Write to an external destination <code>outputs file(path String, content String)!</code> <p>The distinction matters: pure verbs cannot call IO functions, cannot use <code>!</code>, and are safe to memoize, inline, or reorder. IO verbs make side effects explicit in the function signature.</p>"},{"location":"stdlib/#channel-dispatch","title":"Channel Dispatch","text":"<p>For example, <code>InputOutput</code> is organized by channels. The <code>file</code> channel has three verbs:</p> <pre><code>inputs file(path String) String!          // read a file\noutputs file(path String, content String)! // write a file\nvalidates file(path String)               // check if file exists\n</code></pre> <p>The caller's verb determines which function is invoked. This is channel dispatch \u2014 one name, multiple intents.</p>"},{"location":"stdlib/#inputoutput","title":"InputOutput","text":"<p>Module: <code>InputOutput</code> \u2014 handles IO operations.</p>"},{"location":"stdlib/#console-channel","title":"Console Channel","text":"<p>Console input and output.</p> Verb Signature Description <code>outputs</code> <code>console(text String)</code> Print text to stdout <code>inputs</code> <code>console() String</code> Read a line from stdin <pre><code>InputOutput outputs console, inputs console\n\noutputs greet()\nfrom\n    InputOutput.console(\"What is your name?\")\n    name as String = InputOutput.console()\n    InputOutput.console(f\"Hello, {name}!\")\n</code></pre>"},{"location":"stdlib/#file-channel","title":"File Channel","text":"<p>Read and write files. File operations are failable \u2014 use <code>!</code> to propagate errors.</p> Verb Signature Description <code>inputs</code> <code>file(path String) String!</code> Read file contents <code>outputs</code> <code>file(path String, content String)!</code> Write file contents <pre><code>InputOutput inputs file, outputs file\n\ninputs load_config(path String) String!\nfrom\n    InputOutput.file(path)!\n</code></pre>"},{"location":"stdlib/#upcoming-modules","title":"Upcoming Modules","text":"<p>The standard library grows with each release. Modules are added when the self-hosted compiler needs them.</p> Version Module Purpose v0.6 Character Character classification (<code>alpha</code>, <code>digit</code>, <code>space</code>, etc.) and string-to-char access v0.6 Text String operations (<code>slice</code>, <code>contains</code>, <code>split</code>, <code>join</code>, <code>trim</code>, <code>replace</code>) and <code>Builder</code> for efficient string construction v0.6 Table Hash map <code>Table&lt;V&gt;</code> with <code>creates new</code>, <code>reads get</code>, <code>transforms add</code>, <code>validates has</code> v0.7 InputOutput (ext) New channels: <code>system</code> (process execution), <code>dir</code> (directory operations), <code>process</code> (command-line arguments) v0.7 Parse Format codecs \u2014 <code>creates toml(source)</code> to decode, <code>reads toml(value)</code> to encode. Same pattern for JSON"},{"location":"syntax/","title":"Syntax Reference","text":""},{"location":"syntax/#naming","title":"Naming","text":"<ul> <li>Types, modules, and classes: CamelCase \u2014 <code>Shape</code>, <code>Port</code>, <code>UserAuth</code>, <code>NonEmpty</code>, <code>HttpServer</code></li> <li>Variables and parameters: snake_case \u2014 <code>port</code>, <code>user_list</code>, <code>max_retries</code>, <code>db_connection</code></li> <li>Functions: snake_case \u2014 <code>area</code>, <code>binary_search</code>, <code>get_users</code></li> <li>Constants: UPPER_SNAKE_CASE \u2014 <code>MAX_CONNECTIONS</code>, <code>LOOKUP_TABLE</code>, <code>DEFAULT_PORT</code></li> <li>Effects: CamelCase \u2014 <code>IO</code>, <code>Fail</code>, <code>Async</code></li> </ul> <p>The compiler enforces casing. Wrong case is a compile error, not a warning. UPPER_SNAKE_CASE indicates a compile-time constant \u2014 no <code>const</code> keyword needed.</p>"},{"location":"syntax/#modules-and-imports","title":"Modules and Imports","text":"<p>Each file is a module. The filename (without extension) is the module name in CamelCase. The <code>module</code> block is mandatory and contains all declarations/metadata: narrative, imports, types, constants, and invariant networks. Functions remain top-level:</p> <pre><code>module InventoryService\n  narrative: \"\"\"Products are added to inventory...\"\"\"\n  String contains length\n  Auth validates login, transforms login\n  Http inputs request session\n\n  type Product is\n    sku Sku\n    name String\n\n  MAX_CONNECTIONS as Integer = 1024\n\n  invariant_network Accounting\n    total &gt;= 0\n</code></pre> <p>A verb applies to all space-separated names that follow it. Commas separate verb groups. Multiple verbs for the same function name import each variant. The verb is part of the function's identity.</p>"},{"location":"syntax/#blocks-and-indentation","title":"Blocks and Indentation","text":"<p>No curly braces. Indentation defines scope (like Python). No semicolons \u2014 newlines terminate statements. Newlines are suppressed after operators, commas, opening brackets, <code>-&gt;</code>, <code>=&gt;</code>.</p>"},{"location":"syntax/#primitive-types-full-names-no-shorthands","title":"Primitive Types \u2014 Full Names, No Shorthands","text":"<p>Every type uses its full name. No abbreviations. Type modifiers use bracket syntax <code>Type:[Modifier ...]</code> for storage and representation concerns. Value constraints belong in refinement types (<code>where</code>), not modifiers.</p> Type Modifier Axes Default Examples <code>Integer</code> size (8/16/32/64/128), signedness (Signed/Unsigned) <code>Integer:[64 Signed]</code> <code>Integer:[32 Unsigned]</code>, <code>Integer:[8]</code> <code>Decimal</code> precision (32/64/128), scale (Scale:N) <code>Decimal:[64]</code> <code>Decimal:[128 Scale:2]</code> <code>Float</code> precision (32/64) <code>Float:[64]</code> <code>Float:[32]</code> <code>Boolean</code> \u2014 \u2014 \u2014 <code>String</code> encoding (UTF8/ASCII/UTF16), max length <code>String:[UTF8]</code> <code>String:[UTF8 15]</code>, <code>String:[ASCII 255]</code> <code>Byte</code> \u2014 \u2014 Distinct type for binary data <code>Character</code> encoding (UTF8/UTF16/ASCII) <code>Character:[UTF8]</code> <code>Character:[ASCII]</code> <p>Modifier rules: - Modifiers are order-independent \u2014 <code>Integer:[Signed 64]</code> and <code>Integer:[64 Signed]</code> are identical. The compiler normalizes internally. - Each modifier occupies a distinct axis. Two modifiers on the same axis is a compile error: <code>Integer:[32 64]</code> \u2192 ERROR: conflicting size modifiers. - Positional modifiers when unambiguous by kind. Named modifiers (<code>Key:Value</code>) when a bare value could be confused: <code>Decimal:[128 Scale:2]</code>. - Bare type name uses sensible defaults: <code>Integer</code> means <code>Integer:[64 Signed]</code>, <code>String</code> means <code>String:[UTF8]</code>, <code>Decimal</code> means <code>Decimal:[64]</code>. - <code>Float</code> is opt-in \u2014 <code>Decimal</code> is the default for fractional numbers. <code>Float:[64]</code> uses IEEE 754 hardware floats for performance-critical domains (scientific computing, graphics, signal processing) where speed matters more than exact precision. Mixing <code>Float</code> and <code>Decimal</code> requires explicit conversion.</p> <pre><code>count as Integer = 42                          // Integer:[64 Signed]\nflags as Integer:[8 Unsigned] = 0xFF\nprice as Decimal:[128 Scale:2] = 19.99         // financial precision\nname as String = \"Alice\"                        // String:[UTF8]\ncode as String:[ASCII 4] = \"US01\"              // ASCII, max 4 characters\nactive as Boolean = true\nraw as Byte = 0x2A\nletter as Character = 'A'\n</code></pre> <p>Separation of concerns \u2014 modifiers describe storage, refinements describe values:</p> <pre><code>// Modifier: how it's stored\nraw_port as Integer:[16 Unsigned] = 8080\n\n// Refinement: what values are valid\ntype Port is Integer where 1..65535\n\n// Combined: storage + value constraint\ntype Port is Integer:[16 Unsigned] where 1..65535\n</code></pre>"},{"location":"syntax/#type-definitions","title":"Type Definitions","text":"<p>Types live inside the <code>module</code> block, defined with <code>type Name is</code>:</p> <pre><code>module Main\n  type Shape is\n    Circle(radius Decimal)\n    | Rect(w Decimal, h Decimal)\n\n  type Port is Integer:[16 Unsigned] where 1 .. 65535\n\n  type Result&lt;T, E&gt; is Ok(T) | Err(E)\n\n  type User is\n    id Integer\n    name String\n    email String\n</code></pre>"},{"location":"syntax/#function-declarations-intent-verbs","title":"Function Declarations \u2014 Intent Verbs","text":"<p>Functions are declared with a verb that describes their purpose. No <code>fn</code>, no <code>function</code> keyword \u2014 the verb IS the declaration. The compiler verifies the implementation matches the declared intent.</p> <p>Verbs are divided into two families: pure (no side effects) and IO (interacts with the outside world).</p> <p>Pure verbs:</p> Verb Purpose Compiler enforces <code>transforms</code> Pure data computation/conversion No <code>!</code>. Failure encoded in return type (<code>Result</code>, <code>Option</code>) <code>validates</code> Pure boolean check No <code>!</code>. Return type is implicitly <code>Boolean</code> <code>reads</code> Non-mutating access to data No <code>!</code>. Extracts or queries without changing anything <code>creates</code> Constructs a new value No <code>!</code>. Returns a freshly allocated value <code>matches</code> Pure match dispatch on algebraic type No <code>!</code>. First parameter must be algebraic. <code>from</code> block is implicitly a match \u2014 no <code>match x</code> needed <p>IO verbs:</p> Verb Purpose Compiler enforces <code>inputs</code> Reads/receives from external world IO is inherent. <code>!</code> marks fallibility. Implicit match when first param is algebraic <code>outputs</code> Writes/sends to external world IO is inherent. <code>!</code> marks fallibility <pre><code>matches area(s Shape) Decimal\nfrom\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms normalize(data List&lt;Decimal&gt;) List&lt;Decimal&gt;\n  ensures len(result) == len(data)\nfrom\n    max_val as Decimal = max(data)\n    divide_each(data, max_val)\n\ntransforms parse(raw String) Result&lt;Config, ParseError&gt;\nfrom\n    decode(raw)\n\ninputs users() List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)\nfrom\n    write(stdout, message)\n\nreads length(s String) Integer\nfrom\n    count_bytes(s)\n\ncreates builder() Builder\nfrom\n    allocate_buffer()\n\ninputs request(route Route, body String, db Database) Response!\nfrom\n        Get(/health) =&gt; ok(\"healthy\")\n        Get(/users) =&gt; users(db)! |&gt; encode |&gt; ok\n        Post(/users) =&gt; create(db, body)! |&gt; encode |&gt; created\n        _ =&gt; not_found()\n</code></pre>"},{"location":"syntax/#verb-dispatched-identity","title":"Verb-Dispatched Identity","text":"<p>Functions are identified by the triple <code>(verb, name, parameter types)</code> \u2014 not just <code>(name, parameter types)</code>. The same function name can be declared multiple times with different verbs, each with a distinct meaning:</p> <pre><code>validates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms email(raw String) Email\nfrom\n    lowercase(trim(raw))\n\ninputs email(user_id Integer) Email!\nfrom\n    query(db, \"SELECT email FROM users WHERE id = {user_id}\")!\n</code></pre> <p>Three functions, all named <code>email</code>, with completely different intents.</p>"},{"location":"syntax/#context-aware-call-resolution","title":"Context-Aware Call Resolution","text":"<p>At call sites, you use just the function name \u2014 the compiler resolves which verb-variant to call based on context (expected type, parameter types, expression position):</p> <pre><code>// Predicate context \u2192 resolves to validates email\nclean_list as List&lt;Email&gt; = filter(inputs, valid email)\n\n// Email context + String param \u2192 resolves to transforms email\nclean as Email = email(raw_input)\n\n// Email context + Integer param \u2192 resolves to inputs email\nstored as Email = email(user.id)\n\n// When context is ambiguous, use `valid` for explicit Boolean cast\nprint(valid email(input))               // forces validates variant\n\n// `valid` as type-cast parameter \u2014 passes the validates function itself\nfilter(users, valid email)              // passes `validates email` as predicate\n</code></pre> <p>Resolution rules: 1. Boolean context (<code>match</code> on Boolean, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) \u2192 resolves to <code>validates</code> variant 2. Expected type from assignment or parameter \u2192 matches the variant returning that type 3. Parameter types disambiguate between variants with the same return type 4. Ambiguous \u2192 compiler error with suggestions listing available variants</p> <p>The <code>valid</code> keyword serves two purposes: - As expression: <code>valid email(input)</code> \u2014 casts a validates call to its Boolean result explicitly - As function reference: <code>valid email</code> (no parens) \u2014 passes the validates function as a predicate to higher-order functions like <code>filter</code></p> <p>Implications:</p> <ul> <li>Imports are precise: <code>Auth validates login, inputs session</code></li> <li>API docs group by verb: what can you validate? what can you yield? what can you transform?</li> <li>Call sites are clean: just the function name in most cases</li> <li>AI resistance: declarations require the correct verb, and the resolution rules add non-local reasoning requirements</li> </ul>"},{"location":"syntax/#parameters","title":"Parameters","text":"<p>Go-style: <code>name Type</code> (no colon). Inside parentheses, the declaration context is already clear.</p> <pre><code>transforms area(s Shape) Decimal\ninputs request(route Route, body String) Response!\nvalidates email(address String)\n</code></pre>"},{"location":"syntax/#variable-declarations","title":"Variable Declarations","text":"<p>Variables use <code>name as Type = value</code>. The <code>as</code> keyword reads naturally: \"port, as a Port, equals 8080\".</p> <pre><code>port as Port = 8080\nserver as Server = new_server()\nconfig as Config = load(\"app.yaml\")!\nuser_list as List&lt;User&gt; = users()!\n</code></pre> <p>Variables are immutable by default. Mutability is a type modifier \u2014 it's a storage concern, like size and signedness:</p> <pre><code>counter as Integer:[Mutable] = 0\ncounter = counter + 1\n</code></pre>"},{"location":"syntax/#type-inference-with-formatter-enforcement","title":"Type Inference with Formatter Enforcement","text":"<p>The compiler infers types when unambiguous, but <code>prove format</code> always inserts explicit type annotations. This means you can write clean code during development, and the formatter makes it explicit before commit.</p> <pre><code>// What you write:\nport = 8080\nserver = new_server()\nusers = query(db, \"SELECT * FROM users\")!\n\n// What `prove format` produces:\nport as Integer = 8080\nserver as Server = new_server()\nusers as List&lt;User&gt; = query(db, \"SELECT * FROM users\")!\n</code></pre> <p>The LSP shows inferred types inline as you type, so you always know what the compiler deduced. Function signatures are always explicit \u2014 inference only applies to local variables.</p> <p>The language encourages explicit types \u2014 the formatter enforces them. But you're never blocked from writing code because you can't remember whether it's <code>List&lt;Map&lt;String, User&gt;&gt;</code> or <code>Map&lt;String, List&lt;User&gt;&gt;</code>.</p>"},{"location":"syntax/#io-and-fallibility","title":"IO and Fallibility","text":"<p>IO is inherent in the verb \u2014 <code>inputs</code> and <code>outputs</code> always interact with the external world. Fallibility is marked with <code>!</code> on the return type. Pure verbs (<code>transforms</code>, <code>validates</code>, <code>reads</code>, <code>creates</code>, <code>matches</code>) have neither IO nor <code>!</code>.</p> <pre><code>transforms area(s Shape) Decimal\nfrom\n    pi * s.radius * s.radius\n\ninputs users() List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs write_log(entry String)\nfrom\n    append(log_file, entry)\n</code></pre> <p>Reads as: \"inputs users, returns List of User, can fail!\"</p> <p>The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which don't (<code>transforms</code>/<code>validates</code>) \u2014 the verb IS the declaration.</p>"},{"location":"syntax/#body-marker-from","title":"Body Marker: <code>from</code>","text":"<p>Every function body begins with <code>from</code>. No exceptions. This reads as \"the result comes from...\" and makes it immediately clear where the implementation starts, whether the function has annotations or not.</p> <pre><code>transforms area(s Shape) Decimal\nfrom\n    pi * s.radius * s.radius\n\ninputs users() List&lt;User&gt;!\n  ensures len(result) &gt;= 0\nfrom\n    query(db, \"SELECT * FROM users\")!\n</code></pre>"},{"location":"syntax/#pattern-matching-the-only-way-to-branch","title":"Pattern Matching \u2014 The Only Way to Branch","text":"<p>Prove has no <code>if</code>/<code>else</code>. All branching is done through <code>match</code> \u2014 and good Prove code rarely matches on booleans at all.</p> <pre><code>match route\n    Get(\"/health\") =&gt; ok(\"healthy\")\n    Get(\"/users\")  =&gt; users()!\n    _              =&gt; not_found()\n\nmatch discount\n    FlatOff(off) =&gt; max(0, amount - off)\n    PercentOff(rate) =&gt; amount * (1 - rate)\n\nMAX_CONNECTIONS as Integer = comptime\n    match cfg.target\n        \"embedded\" =&gt; 16\n        _ =&gt; 1024\n</code></pre> <p>This is not an omission. It is a deliberate design choice.</p>"},{"location":"syntax/#why-no-if","title":"Why No <code>if</code>","text":"<p>1. Types replace booleans.</p> <p>When you reach for <code>if connected then send(data) else retry()</code>, the real question is: what kind of connection state are you in? Model it as a type and the branching becomes meaningful:</p> <pre><code>type Connection is Active(socket Socket) | Disconnected(reason String)\n\nmatch connection\n    Active(socket) =&gt; send(socket, data)\n    Disconnected(reason) =&gt; retry(reason)\n</code></pre> <p>Each arm names what it handles. No <code>true</code>/<code>false</code> to mentally decode. The compiler enforces that every variant is covered \u2014 add a <code>Reconnecting</code> state later and the compiler tells you everywhere you need to handle it.</p> <p>2. <code>if</code> hides missing cases.</p> <p>An <code>if</code> without <code>else</code> silently does nothing on the false branch. The programmer may have forgotten it. With types, there's no such escape \u2014 every variant must be handled.</p> <p>3. One construct is simpler than two.</p> <p><code>if</code>/<code>else</code> adds no expressive power over <code>match</code>. It only adds surface area to the language, the parser, the type checker, the emitter, and every tool that processes Prove code. One construct means less to learn and fewer ways to express the same thing.</p> <p>4. Contracts replace conditional logic.</p> <p>Where other languages use <code>if</code> to decide whether to run code, Prove uses validation. Consider:</p> <pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p>There is no <code>if discount &gt; 0 then apply_discount(...)</code>. The <code>requires</code> clause on <code>apply_discount</code> ensures the compiler has already proven the discount is valid before the call happens. The \"branching\" lives in the type system and contracts, not in boolean conditions.</p> <p>5. Boolean matching is a code smell.</p> <p><code>match x &gt; 0 / true =&gt; ... / false =&gt; ...</code> is technically valid but signals that you should model your domain better. Instead of branching on <code>amount &gt; 0</code>, define <code>type Positive is Integer where &gt; 0</code> and let the type system handle it. The branching disappears into the type \u2014 where the compiler can prove things about it.</p>"},{"location":"syntax/#the-rule","title":"The Rule","text":"<p>Branch on what something is, not on whether something is true. Types and contracts handle the rest \u2014 <code>requires</code> guards preconditions, <code>ensures</code> guarantees postconditions, and <code>explain</code> documents the reasoning. No boolean branch needed.</p>"},{"location":"syntax/#lambdas-constrained-inline-functions","title":"Lambdas \u2014 Constrained Inline Functions","text":"<p>Lambdas are single-expression anonymous functions, used exclusively as arguments to higher-order functions like <code>map</code>, <code>filter</code>, and <code>reduce</code>. They cannot capture mutable state and must be pure.</p> <p>Syntax: <code>|params| expression</code></p> <pre><code>// Filtering with a lambda\nactive_users as List&lt;User&gt; = filter(users, |u| u.active)\n\n// Mapping with a lambda\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Reducing with a lambda\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Using `valid` to pass a validates function as predicate (no lambda needed)\nverified_emails as List&lt;String&gt; = filter(emails, valid email)\n</code></pre> <p>Constraints: - Single expression only \u2014 no multi-line bodies, no statements. If you need more, write a named function. - Must be pure \u2014 no IO effects inside a lambda. Side effects require a named function. - No closures \u2014 lambdas cannot reference variables from the enclosing scope. All values must be passed as arguments or accessed through the lambda's own parameters. - Only as arguments \u2014 lambdas cannot be assigned to variables or returned from functions. They exist only at the call site of a higher-order function.</p>"},{"location":"syntax/#iteration-no-loops","title":"Iteration \u2014 No Loops","text":"<p>Prove has no <code>for</code>, <code>while</code>, or loop constructs. Iteration is expressed through <code>map</code>, <code>filter</code>, <code>reduce</code>, and recursion. This keeps all data transformations as expressions (they produce values) rather than statements.</p> <pre><code>// Instead of: for each user, get their name\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Instead of: for each item, keep valid ones\nvalid_items as List&lt;Item&gt; = filter(items, |i| i.quantity &gt; 0)\n\n// Instead of: accumulate a total with a loop\ntotal as Decimal = reduce(order.items, 0, |acc, item| acc + item.price * item.quantity)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre> <p>For complex iteration that doesn't fit map/filter/reduce, use recursion with a <code>transforms</code> function.</p>"},{"location":"syntax/#keyword-exclusivity","title":"Keyword Exclusivity","text":"<p>Every keyword in Prove has exactly one purpose. No keyword is overloaded across different contexts. This makes the language predictable and parseable by humans without memorizing context-dependent rules.</p> <p>Core keywords:</p> Keyword What it does <code>transforms</code> Declares a pure function \u2014 no side effects, just data in, data out <code>validates</code> Declares a function that returns true or false <code>reads</code> Declares a pure function that extracts or queries data without changing it <code>creates</code> Declares a pure function that constructs a new value <code>inputs</code> Declares a function that reads from the outside world (database, file, network) <code>outputs</code> Declares a function that writes to the outside world <code>main</code> The program's entry point \u2014 can freely mix reading and writing <code>from</code> Marks where the function body starts \u2014 \"the result comes from...\" <code>where</code> Adds a value constraint to a type \u2014 <code>Integer where 1..65535</code> <code>as</code> / <code>is</code> <code>as</code> declares a variable \u2014 <code>port as Port = 8080</code> (what it's treated as). <code>is</code> defines a type \u2014 <code>type Port is Integer</code> (what it is) <code>type</code> Starts a type definition \u2014 <code>type Port is Integer where 1..65535</code> <code>match</code> Branches on a value \u2014 the only way to do conditional logic <code>ensures</code> States what a function guarantees about its result \u2014 a hard postcondition <code>requires</code> States what must be true before calling a function \u2014 a hard precondition <code>matches</code> Declares a pure function that dispatches on an algebraic first parameter <code>explain</code> Documents each step in the <code>from</code> block using controlled natural language. Strict (with <code>ensures</code>): row count must match <code>from</code>, references verified against contracts. Loose (without <code>ensures</code>): free-form text, documentation only. LSP-suggested, not compiler-required <code>terminates</code> Required for recursive functions \u2014 declares a measure expression that decreases on each call. Compiler error if omitted <code>trusted</code> Explicitly marks a function as unverified \u2014 acknowledges the gap when <code>ensures</code> would otherwise be expected <code>valid</code> References a <code>validates</code> function as a predicate <code>comptime</code> Runs code at compile time instead of runtime"},{"location":"syntax/#interface-contracts-requires-ensures","title":"Interface Contracts: <code>requires</code>, <code>ensures</code>","text":"<p><code>requires</code> and <code>ensures</code> are hard rules about the function's interface. The compiler enforces them automatically.</p> <pre><code>type Clamped is Integer where low .. high\n\ntransforms clamp(value Integer, low Integer, high Integer) Clamped\n  requires low &lt;= high\n  ensures result &gt;= low\n  ensures result &lt;= high\nfrom\n    max(low, min(value, high))\n</code></pre> <p><code>requires</code> states what must be true before calling the function \u2014 the compiler rejects call sites that can't prove it. <code>ensures</code> states what the function guarantees about its result \u2014 the compiler verifies every code path or generates property tests. Here, the refinement type <code>Clamped</code> does the heavy lifting.</p>"},{"location":"syntax/#implementation-explanation-explain","title":"Implementation Explanation: <code>explain</code>","text":"<p><code>explain</code> documents the chain of operations in the <code>from</code> block using controlled natural language. It is LSP-suggested, not compiler-required \u2014 the LSP recommends adding it when a function has enough complexity to warrant documentation.</p> <p>Two strictness modes:</p> <p>Strict mode (function has <code>ensures</code>): Each explain row corresponds to a top-level statement in the <code>from</code> block \u2014 a binding, a final expression, or a match arm. Multi-line expressions (pipe chains, multi-line arms) count as one. The count must match exactly (mismatch is a compiler error). The compiler warns if a single arm grows complex enough to warrant extraction into a named function.</p> <p>The compiler parses each row for an operation (action verb), connectors (prepositions like <code>by</code>, <code>to</code>, <code>all</code>), and references (identifiers from the function). Operations are verified against called functions' contracts \u2014 if the called function has no contracts supporting the claimed operation, the compiler warns. References must be real identifiers. Sugar words (\"the\", \"applicable\", etc.) are ignored \u2014 keeping explain readable as natural English while remaining machine-verifiable.</p> <pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\n  explain\n    sum all items.price\n    reduce sub by discount\n    add tax to discounted\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p>Sugar words keep it readable \u2014 the compiler sees the same thing:</p> <pre><code>  explain\n    sum all the items.price\n    reduce the sub by discount\n    add applicable tax to the discounted total\n</code></pre> <p>Compiler parses: <code>sum</code> (operation) + <code>all</code> (connector) + <code>items.price</code> (reference), ignoring \"the\". Both forms are equivalent.</p> <p>Loose mode (no <code>ensures</code>): Row count is flexible. Free-form text. Documentation value only.</p> <pre><code>transforms merge_sort(xs List&lt;T&gt;) Sorted&lt;List&lt;T&gt;&gt;\n  terminates: len(xs)\n  explain\n    split the list at the midpoint\n    recursively sort both halves\n    merge the sorted halves back together\nfrom\n    halves as Pair&lt;List&lt;T&gt;&gt; = split_at(xs, len(xs) / 2)\n    left as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.first)\n    right as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.second)\n    merge(left, right)\n</code></pre> <p>Warning pairs:</p> <ul> <li><code>ensures</code> without <code>explain</code> \u2192 warning: add explain to document how ensures are satisfied</li> <li><code>explain</code> without <code>ensures</code> \u2192 warning: explain is unverifiable without contracts to check against</li> </ul> <p>Bare functions are fine. Trivial code needs no annotations:</p> <pre><code>validates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n</code></pre> <p>No explain needed \u2014 the implementation is self-evident. The LSP suggests explain only when complexity warrants it.</p> <p>For <code>matches</code> functions, each explain row corresponds to one arm. The LSP suggests per-arm explain for complex dispatch:</p> <pre><code>matches apply_discount(discount Discount, amount Price) Price\n  ensures result &gt;= 0\n  ensures result &lt;= amount\n  explain\n    clamp the difference to zero\n    scale amount by complement of rate\n    subtract bulk discount from amount\nfrom\n    FlatOff(off) =&gt; max(0, amount - off)\n    PercentOff(rate) =&gt; amount * (1 - rate)\n    BuyNGetFree(buy, free) =&gt;\n        sets as Integer = len(items) / (buy + free)\n        amount - sets * cheapest_price(items)\n</code></pre> <p>Custom vocabulary for operations and connectors can be declared at module level or in <code>prove.toml</code>:</p> <pre><code># prove.toml\n[explain]\noperations = [\"amortize\", \"interpolate\", \"normalize\"]\nconnectors = [\"across\", \"between\", \"within\"]\n</code></pre> <p><code>explain</code> is independent of <code>requires</code> and <code>ensures</code>. A function can have any combination \u2014 though the strictness mode depends on whether <code>ensures</code> is present.</p>"},{"location":"syntax/#termination-terminates","title":"Termination: <code>terminates</code>","text":"<p>Recursive functions must declare <code>terminates</code> with a measure expression \u2014 an expression that strictly decreases on each recursive call. Omitting <code>terminates</code> on a recursive function is a compiler error.</p> <pre><code>transforms merge_sort(xs List&lt;T&gt;) Sorted&lt;List&lt;T&gt;&gt;\n  terminates: len(xs)\n  explain\n    split the list at the midpoint\n    recursively sort the first half\n    recursively sort the second half\n    merge both sorted halves preserving order\nfrom\n    halves as Pair&lt;List&lt;T&gt;&gt; = split_at(xs, len(xs) / 2)\n    left as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.first)\n    right as Sorted&lt;List&lt;T&gt;&gt; = merge_sort(halves.second)\n    merge(left, right)\n</code></pre> <p>The compiler verifies that <code>len(halves.first) &lt; len(xs)</code> and <code>len(halves.second) &lt; len(xs)</code> at both recursive call sites.</p>"},{"location":"syntax/#annotation-ordering","title":"Annotation Ordering","text":"<p>All annotations appear between the verb line and <code>from</code>. The compiler accepts any order. The formatter normalizes to this canonical order:</p> <ol> <li><code>requires</code> \u2014 preconditions</li> <li><code>ensures</code> \u2014 postconditions</li> <li><code>terminates</code> \u2014 recursion measure</li> <li><code>trusted</code> \u2014 explicit verification opt-out</li> <li><code>know</code> / <code>assume</code> / <code>believe</code> \u2014 confidence levels</li> <li><code>why_not</code> / <code>chosen</code> \u2014 design reasoning</li> <li><code>near_miss</code> \u2014 boundary examples</li> <li><code>satisfies</code> \u2014 invariant networks</li> <li><code>explain</code> \u2014 implementation documentation (adjacent to <code>from</code>)</li> </ol> <p>AI-Resistance keywords (Phase 1+2):</p>"},{"location":"syntax/#module-level-narrative-domain-temporal","title":"Module-level: <code>narrative</code>, <code>domain</code>, <code>temporal</code>","text":"<pre><code>module PaymentService\n  narrative: \"\"\"\n  Customers submit payments. Each payment is validated,\n  charged through the gateway, and recorded in the ledger.\n  \"\"\"\n  domain Finance\n  temporal: validate -&gt; charge -&gt; record\n</code></pre> <p><code>narrative</code> is required \u2014 it describes the module's purpose in plain language. <code>domain</code> tags the module's problem domain. <code>temporal</code> declares the expected ordering of operations. These are currently documentation keywords \u2014 the compiler requires <code>narrative</code> but does not yet verify semantic coherence. Compiler verification (rejecting unrelated functions, enforcing domain-specific rules, checking temporal ordering) is planned for a future release.</p>"},{"location":"syntax/#function-level-why_not-chosen-near_miss","title":"Function-level: <code>why_not</code>, <code>chosen</code>, <code>near_miss</code>","text":"<pre><code>transforms select_gateway(amount Price, region Region) Gateway\n  why_not: \"Round-robin ignores regional latency differences\"\n  why_not: \"Cheapest-first causes thundering herd on one provider\"\n  chosen: \"Latency-weighted routing balances cost and speed per region\"\nfrom\n    closest_by_latency(region, available_gateways())\n\nvalidates leap_year(y Year)\n  near_miss: 1900  =&gt; false\n  near_miss: 2000  =&gt; true\n  near_miss: 2100  =&gt; false\nfrom\n    y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)\n</code></pre> <p><code>why_not</code> documents rejected alternatives. <code>chosen</code> explains the selected approach. These are currently documentation keywords \u2014 compiler verification of rationale consistency is planned. <code>near_miss</code> provides inputs that almost break the code \u2014 the compiler verifies each near-miss exercises a distinct boundary condition.</p>"},{"location":"syntax/#confidence-know-assume-believe","title":"Confidence: <code>know</code>, <code>assume</code>, <code>believe</code>","text":"<pre><code>transforms process_order(order Order) Receipt\n  know: len(order.items) &gt; 0            // proven by NonEmpty type \u2014 zero cost\n  assume: order.total == sum(prices)    // runtime check inserted at boundaries\n  believe: order.user.is_verified       // compiler generates tests to disprove this\nfrom\n    // implementation\n</code></pre> <p><code>know</code> = the compiler can prove it (free). <code>assume</code> = the compiler adds a runtime check. <code>believe</code> = the compiler tries to break it with generated tests.</p>"},{"location":"syntax/#verification-chain-trusted","title":"Verification Chain: <code>trusted</code>","text":"<p><code>ensures</code> requirements propagate through the call graph. If function A has <code>ensures</code> and calls function B, the compiler needs B's contracts to verify A's postconditions. If B has no <code>ensures</code>, the compiler warns \u2014 A's verification is incomplete.</p> <p><code>trusted</code> is the explicit opt-out. It acknowledges that a function is unverified and silences the warning:</p> <pre><code>transforms subtotal(items List&lt;OrderItem&gt;) Price\n  trusted: \"sum of non-negative prices is non-negative\"\nfrom\n    reduce(items, 0, |acc, item| acc + item.price)\n</code></pre> <p>The compiler also warns when IO functions (<code>inputs</code>/<code>outputs</code>) or exported functions lack <code>ensures</code> \u2014 these are API boundaries where contracts matter most.</p> <p><code>prove check</code> reports verification coverage:</p> <pre><code>$ prove check\n\nVerification:\n  \u2713 42 functions with ensures (property tests)\n  \u2713 11 validators with near_miss (boundary tests)\n  \u26a0 3 functions trusted\n  \u2717 1 unverified in chain \u2192 add ensures or trusted\n\nCoverage: 89%\n</code></pre> <p>Functions outside any verification chain and with no callers that have <code>ensures</code> are fine without annotations \u2014 nobody depends on them contractually. The LSP suggests <code>near_miss</code> for <code>validates</code> functions with compound logic (multiple <code>&amp;&amp;</code>/<code>||</code>, modular arithmetic, negation). Trivial validators like <code>user.active</code> get no suggestion.</p>"},{"location":"syntax/#intent-intent","title":"Intent: <code>intent</code>","text":"<pre><code>intent: \"keep only valid records\"\nresult as List&lt;Record&gt; = filter(records, valid record)\n\nintent: \"remove corrupt entries\"\nresult as List&lt;Record&gt; = filter(records, valid corrupt)\n</code></pre> <p><code>intent</code> annotates a statement with its purpose. Currently a documentation keyword \u2014 the compiler records it but does not yet verify that the intent matches the code's behavior. Verification using controlled natural language (similar to <code>explain</code>) is planned for a future release.</p>"},{"location":"syntax/#invariants-invariant_network-satisfies","title":"Invariants: <code>invariant_network</code>, <code>satisfies</code>","text":"<pre><code>invariant_network AccountingRules\n  total_assets == total_liabilities + equity\n  revenue - expenses == net_income\n  every(transaction) preserves total_assets == total_liabilities + equity\n\ntransforms post_transaction(ledger Ledger, tx Transaction) Ledger\n  satisfies AccountingRules\nfrom\n    // implementation \u2014 compiler verifies the rules hold after every change\n</code></pre> <p><code>invariant_network</code> defines rules that must always hold together. <code>satisfies</code> declares that a function obeys those rules.</p>"},{"location":"syntax/#error-propagation","title":"Error Propagation","text":"<p><code>!</code> marks fallibility \u2014 on declarations it means \"this function can fail\", at call sites it propagates the error upward. Only IO verbs (<code>inputs</code>, <code>outputs</code>) can use <code>!</code>. There is one <code>Error</code> type \u2014 errors are program-ending, not flow control. <code>!</code> errors propagate up the call chain until they reach <code>main</code>, which exits with an error message. There is no try/catch.</p> <p>Pure functions that need to represent expected failure cases use <code>Result&lt;T, E&gt;</code> and handle them with <code>match</code> \u2014 these are values, not errors.</p> <pre><code>main()!\nfrom\n    config as Config = load(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"syntax/#complete-example-restful-server","title":"Complete Example: RESTful Server","text":"<pre><code>type Port is Integer:[16 Unsigned] where 1 .. 65535\ntype Route is Get(path String) | Post(path String) | Delete(path String)\n\ntype User is\n  id Integer\n  name String\n  email String\n\n/// Checks whether a string is a valid email address.\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\n/// Retrieves all users from the database.\ninputs users(db Database) List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\n/// Creates a new user from a request body.\noutputs create(db Database, body String) User!\n  ensures email(result.email)\nfrom\n    user as User = decode(body)!\n    insert(db, \"users\", user)!\n    user\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\nfrom\n    Get(\"/health\") =&gt; ok(\"healthy\")\n    Get(\"/users\")  =&gt; users(db)! |&gt; encode |&gt; ok\n    Post(\"/users\") =&gt; create(db, body)! |&gt; encode |&gt; created\n    _              =&gt; not_found()\n\n/// Application entry point \u2014 no verb, main is special.\nmain()!\nfrom\n    port as Port = 8080\n    db as Database = connect(\"postgres://localhost/app\")!\n    server as Server = new_server()\n    route(server, \"/\", request)\n    listen(server, port)!\n</code></pre>"},{"location":"types/","title":"Type System","text":""},{"location":"types/#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes. The compiler rejects invalid values statically \u2014 no unnecessary runtime checks, no <code>unwrap()</code>.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1 .. 65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T    // no Option needed, emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"types/#algebraic-types-with-exhaustive-matching","title":"Algebraic Types with Exhaustive Matching","text":"<p>Like Rust/Haskell, but with row polymorphism. Compiler errors if you forget a variant.</p> <pre><code>type Result&lt;T, E&gt; is Ok(T) | Err(E)\ntype Shape is Circle(radius Decimal) | Rect(w Decimal, h Decimal)\n\n// compiler error if you forget a variant\ntransforms area(s Shape) Decimal\nfrom\n    match s\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n</code></pre>"},{"location":"types/#effect-types","title":"Effect Types","text":"<p>IO is encoded in the verb, not in annotations. The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which are pure (<code>transforms</code>/<code>validates</code>). Pure functions get automatic memoization and parallelism.</p> <pre><code>inputs read_config(path Path) String!               // IO inherent, ! = can fail\n\ntransforms parse(s String) Result&lt;Config, Error&gt;   // pure \u2014 failure in return type\n\ntransforms rewrite(c Config) Config                // pure, infallible, parallelizable\n</code></pre>"},{"location":"types/#ownership-lite-linear-types-with-compiler-inferred-borrows","title":"Ownership Lite (Linear Types with Compiler-Inferred Borrows)","text":"<p>Linear types for resources, but without Rust's lifetime annotation burden. The compiler infers borrows or asks you. Ownership is a type modifier, consistent with mutability and other storage concerns.</p> <pre><code>inputs process(file File:[Own]) Data!\nfrom\n    content as String = read(file)\n    close(file)\n</code></pre>"},{"location":"types/#no-null","title":"No Null","text":"<p>No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by the compiler.</p>"}]}