{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prove","text":"<p>A programming language that fights back against AI slop and code scraping.</p> <p>Prove is a strongly typed, compiler-driven language where contracts generate tests, intent verbs enforce purity, and the compiler rejects code that can't demonstrate understanding. Source is stored as binary AST \u2014 unscrapable, unnormalizable, unlicensed for training. If it compiles, the author understood what they wrote. If it's AI-generated, it won't.</p> <pre><code>transforms add(a Integer, b Integer) Integer\n  ensures result == a + b\n  proof\n    correctness: result is the sum of a and b\nfrom\n    a + b\n</code></pre> <p>The <code>ensures</code> clause declares guarantees. The <code>proof</code> block explains why they hold. The <code>transforms</code> verb guarantees purity. The compiler enforces every contract \u2014 and none of it can be faked by autocomplete.</p>"},{"location":"#why-prove","title":"Why Prove?","text":"Problem How Prove solves it AI scrapes your code for training Binary AST format + anti-training license + semantic normalization AI slop PRs waste maintainer time Compiler rejects code without proof obligations and intent Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit Null/nil crashes No null \u2014 <code>Option&lt;T&gt;</code> enforced by compiler \"I forgot an edge case\" Compiler generates edge cases from types Runtime type errors Refinement types catch invalid values at compile time Contracts without proof <code>ensures</code> without <code>proof</code> is a compile error (E390)"},{"location":"#quick-start","title":"Quick Start","text":"<p>Requirements: Python 3.11+, gcc or clang</p> <pre><code># Install\npip install -e \".[dev]\"\n\n# Create a project\nprove new hello\n\n# Build and run\ncd hello\nprove build\n./build/hello\n\n# Type-check only\nprove check\n\n# Run auto-generated tests\nprove test\n</code></pre>"},{"location":"#language-tour","title":"Language Tour","text":""},{"location":"#intent-verbs","title":"Intent Verbs","text":"<p>Every function declares its purpose. The compiler enforces it.</p> <pre><code>transforms area(s Shape) Decimal\nfrom\n    match s\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ninputs users(db Database) List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)\nfrom\n    write(stdout, message)\n</code></pre> <p>The same name can exist with different verbs \u2014 the compiler resolves which to call from context:</p> <pre><code>validates email(address String)           // check if valid\ntransforms email(raw String) Email        // convert to Email type\ninputs email(user_id Integer) Email!      // fetch from database\n</code></pre>"},{"location":"#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1..65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T         // no Option needed \u2014 emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"#contracts-and-proofs","title":"Contracts and Proofs","text":"<p>Functions declare what they guarantee. The compiler verifies or tests it.</p> <pre><code>transforms apply_discount(discount Discount, amount Price) Price\n  ensures result &gt;= 0\n  ensures result &lt;= amount\n  proof\n    non_negative: FlatOff is clamped to zero , PercentOff rate is 0 .. 1\n    bounded: every discount path subtracts from amount , never adds\nfrom\n    match discount\n        FlatOff(off) =&gt; max(0, amount - off)\n        PercentOff(rate) =&gt; amount * (1 - rate)\n</code></pre>"},{"location":"#no-loops-functional-iteration","title":"No Loops \u2014 Functional Iteration","text":"<pre><code>names as List&lt;String&gt; = map(users, |u| u.name)\nactive as List&lt;User&gt; = filter(users, |u| u.active)\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>Errors are values. <code>!</code> propagates failures. No exceptions.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\nfrom\n    config as Config = load(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"#complete-example","title":"Complete Example","text":"<p>A RESTful inventory service demonstrating the full feature set:</p> <pre><code>module InventoryService\n    narrative: \"\"\"\n    Products are added to inventory with validated stock levels.\n    Orders consume stock. The system ensures stock never goes negative\n    and all monetary calculations use exact decimal arithmetic.\n    \"\"\"\n\ntype Port is Integer:[16 Unsigned] where 1..65535\ntype Price is Decimal:[128 Scale:2] where &gt;= 0\ntype Sku is String where matches(/^[A-Z]{2,4}-[0-9]{4,8}$/)\n\ntype Product is\n    sku Sku\n    name String\n    price Price\n    stock Quantity\n\n/// Checks whether every item in an order can be fulfilled.\nvalidates fulfillable(order Order)\nfrom\n    all(order.items, |item| in_stock(item.product, item.quantity))\n\n/// Places an order: validates stock, calculates total, deducts inventory.\noutputs place_order(db Database, order Order, tax TaxRule) Order!\n  requires fulfillable(order)\n  ensures result.status == Confirmed\n  proof\n    fulfillment: requires clause guarantees stock sufficiency\n                 before deduction, so stock never goes negative\nfrom\n    total as Price = calculate_total(order.items, None, tax)\n    confirmed as Order = Order(order.id, order.items, Confirmed, total)\n    insert(db, \"orders\", confirmed)!\n    deduct_stock(all_products(db)!, order.items) |&gt; update_all(db, \"products\")!\n    confirmed\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\nfrom\n    Get(\"/health\")   =&gt; ok(\"healthy\")\n    Get(\"/products\") =&gt; all_products(db)! |&gt; encode |&gt; ok\n    Post(\"/orders\")  =&gt; parse_order(body)! |&gt; place_order(db, tax)! |&gt; encode |&gt; created\n    _                =&gt; not_found()\n\nmain() Result&lt;Unit, Error&gt;!\nfrom\n    cfg as Config = load_config(\"inventory.yaml\")!\n    db as Database = connect(cfg.db_url)!\n    server as Server = new_server()\n    route(server, \"/\", request)\n    listen(server, cfg.port)!\n</code></pre>"},{"location":"#compiler-pipeline","title":"Compiler Pipeline","text":"<pre><code>Source (.prv) \u2192 Lexer \u2192 Parser \u2192 Checker \u2192 Prover \u2192 C Emitter \u2192 gcc/clang \u2192 Native Binary\n</code></pre>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>tree-sitter-prove \u2014 Tree-sitter grammar for editor syntax highlighting</li> <li>chroma-lexer-prove \u2014 Chroma lexer for Gitea/Hugo code rendering</li> </ul>"},{"location":"#status","title":"Status","text":"<p>v0.1.0 \u2014 the core compilation pipeline works end-to-end. The compiler lexes, parses, type-checks, verifies proof obligations, emits C, and produces native binaries. 326 tests pass across every stage.</p>"},{"location":"#repository","title":"Repository","text":"<p>Source code is hosted at code.botwork.se/Botwork/prove.</p> <p>The Gitea instance is a paid service for issue creators. Developers who want contributor access can reach out to magnusknutas[at]botwork.se.</p>"},{"location":"#license","title":"License","text":"<p>Prove Source License v1.0 \u2014 permissive for developers, prohibits use as AI training data.</p>"},{"location":"ai-resistance/","title":"AI Resistance","text":""},{"location":"ai-resistance/#phase-1-generation-resistance","title":"Phase 1 \u2014 Generation Resistance","text":"<p>AI models generate code by pattern-matching on statistical regularities in training data. To resist AI generation, a language needs correctness to require deep, holistic understanding \u2014 local patterns alone are insufficient.</p>"},{"location":"ai-resistance/#context-dependent-syntax","title":"Context-Dependent Syntax","text":"<p>Instead of fixed keywords, the language adapts syntax based on the module's declared domain. AI cannot memorize syntax because it shifts per-context.</p> <pre><code>domain Finance\n  // \"balance\" is now a keyword, arithmetic operators\n  // follow financial rounding rules\n  total as Balance = sum(ledger.entries)  // compiler enforces Decimal with financial Scale\n\ndomain Physics\n  // \"balance\" is just an identifier again\n  // operators now track units\n  balance as Acceleration = force / mass   // type: Acceleration, not a keyword\n</code></pre>"},{"location":"ai-resistance/#proof-obligations-as-code","title":"Proof Obligations as Code","text":"<p>Every function with <code>ensures</code> clauses requires an inline proof sketch that the compiler verifies. No ensures, no proof needed \u2014 the rule is clear and mechanical. AI can generate plausible-looking proofs, but they won't verify \u2014 you need to actually understand why the code is correct.</p> <pre><code>transforms merge_sort(xs List&lt;T&gt;) Sorted&lt;List&lt;T&gt;&gt;\n  proof\n    base: len(xs) &lt;= 1 implies already sorted\n    split: halves are strictly smaller (terminates)\n    merge: merging two sorted halves preserves ordering\n           by induction on combined length\nfrom\n    // implementation\n</code></pre>"},{"location":"ai-resistance/#intentional-ambiguity-resolution","title":"Intentional Ambiguity Resolution","text":"<p>Constructs that are deliberately ambiguous without understanding intent. The <code>intent</code> string is parsed by the compiler using a formal semantics model and must match the code's behavior.</p> <pre><code>// Does this filter IN or filter OUT? Depends on the declared intent.\nintent: \"keep only valid records\"\nresult as List&lt;Record&gt; = filter(records, valid record)\n\nintent: \"remove corrupt entries\"\nresult as List&lt;Record&gt; = filter(records, valid corrupt)\n// Same filter() call, but the compiler checks that the intent\n// matches the predicate's semantics (keep vs discard)\n</code></pre>"},{"location":"ai-resistance/#non-local-coherence-requirements","title":"Non-Local Coherence Requirements","text":"<p>The compiler enforces that an entire module tells a coherent \"story.\" Functions unrelated to the narrative produce compile errors.</p> <pre><code>module UserAuth\n  narrative: \"\"\"\n  Users authenticate with credentials, receive a session token,\n  and the token is validated on each request. Tokens expire\n  after the configured TTL.\n  \"\"\"\n\n  inputs login(creds Credentials) Session!\n  transforms validate(token Token) User\n  outputs expire(session Session)\n  // outputs send_email(...)   // compiler error: unrelated to narrative\n</code></pre> <p>Coherence across an entire module requires understanding the purpose of the system, not just local patterns.</p>"},{"location":"ai-resistance/#adversarial-type-puzzles","title":"Adversarial Type Puzzles","text":"<p>Refinement types that encode constraints requiring genuine reasoning, not just pattern matching:</p> <pre><code>type BalancedTree&lt;T&gt; is\n  Node(left BalancedTree&lt;T&gt;, right BalancedTree&lt;T&gt;)\n  where abs(left.depth - right.depth) &lt;= 1\n\ntransforms insert(tree BalancedTree&lt;T&gt;, val T) BalancedTree&lt;T&gt;\n  // Can't just pattern match \u2014 you need to construct a value\n  // that satisfies the depth constraint, which requires\n  // understanding rotation logic\n</code></pre>"},{"location":"ai-resistance/#semantic-commit-messages-as-compilation-input","title":"Semantic Commit Messages as Compilation Input","text":"<p>The compiler diffs the previous version, reads the commit message, and verifies the change actually addresses the described bug.</p> <pre><code>commit \"fix: off-by-one in pagination \u2014 last page was empty\n       when total % page_size == 0\"\n\n// The compiler diffs the previous version, reads the commit message,\n// and verifies the change actually addresses the described bug.\n// Vague messages like \"fix stuff\" don't compile.\n</code></pre>"},{"location":"ai-resistance/#phase-2-advanced-generation-resistance","title":"Phase 2 \u2014 Advanced Generation Resistance","text":"<p>Phase 2 targets deeper failure modes in AI code generation: the inability to reason about alternatives, uncertainty, temporal ordering, and interconnected constraints.</p>"},{"location":"ai-resistance/#counterfactual-annotations","title":"Counterfactual Annotations","text":"<p>Every non-trivial design choice must explain what would break under alternative approaches. AI cannot reason about paths not taken.</p> <pre><code>transforms evict(cache Cache:[Mutable]) Option&lt;Entry&gt;\n  why_not: \"FIFO would evict still-hot entries under burst traffic\"\n  why_not: \"Random eviction has unbounded worst-case for repeated keys\"\n  chosen: \"LRU because access recency correlates with reuse probability\"\nfrom\n    // LRU implementation\n</code></pre> <p>The compiler verifies the <code>chosen</code> rationale is consistent with the implementation's actual behavior (e.g., it really does track recency). <code>why_not</code> clauses are checked for plausibility against the function's type signature and effects.</p>"},{"location":"ai-resistance/#adversarial-near-miss-examples","title":"Adversarial Near-Miss Examples","text":"<p>Require inputs that almost break the code but don't. This proves the programmer understands the exact boundary between correct and incorrect behavior.</p> <pre><code>validates leap_year(y Year)\n  near_miss: 1900  =&gt; false\n  near_miss: 2000  =&gt; true\n  near_miss: 2100  =&gt; false\nfrom\n    y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)\n</code></pre> <p>The compiler verifies each near-miss actually exercises a distinct branch or boundary condition. Redundant near-misses are rejected. AI can memorize correct implementations but cannot identify the diagnostic inputs that prove understanding.</p>"},{"location":"ai-resistance/#epistemic-annotations-know-vs-assume-vs-believe","title":"Epistemic Annotations \u2014 <code>know</code> vs <code>assume</code> vs <code>believe</code>","text":"<p>Track the programmer's confidence level about invariants. The compiler treats each tier differently.</p> <pre><code>transforms process_order(order Order) Receipt\n  know: len(order.items) &gt; 0            // enforced by NonEmpty type \u2014 zero cost\n  assume: order.total == sum(prices)    // validated at boundary, runtime check inserted\n  believe: order.user.is_verified       // generates aggressive property tests to falsify\nfrom\n    // implementation\n</code></pre> <ul> <li><code>know</code> \u2014 Proven by the type system. Zero runtime cost. Compiler error if not actually provable.</li> <li><code>assume</code> \u2014 Compiler inserts runtime validation at system boundaries. Logged when violated.</li> <li><code>believe</code> \u2014 Compiler generates adversarial test cases specifically targeting this claim.</li> </ul> <p>AI has no model of its own uncertainty \u2014 it would either mark everything <code>know</code> (fails verification) or <code>assume</code> (wasteful and reveals lack of understanding).</p>"},{"location":"ai-resistance/#temporal-effect-ordering","title":"Temporal Effect Ordering","text":"<p>Not just what effects a function has, but the required order \u2014 enforced across function boundaries and call graphs.</p> <pre><code>module Auth\n  temporal: authenticate -&gt; authorize -&gt; access\n\n  inputs authenticate(creds Credentials) Token!\n  transforms authorize(token Token, resource Resource) Permission\n  inputs access(perm Permission, resource Resource) Data!\n\n// Compiler error: access() called before authorize()\ninputs bad_handler(req Request) Response!\nfrom\n    token as Token = authenticate(req.creds)!\n    data as Data = access(token, req.resource)!    // ERROR: skipped authorize\n</code></pre> <p>The compiler builds a call graph and verifies temporal constraints are satisfied across all execution paths. AI generates plausible call sequences but does not reason about protocol ordering.</p>"},{"location":"ai-resistance/#invariant-networks","title":"Invariant Networks","text":"<p>Instead of isolated <code>ensures</code> clauses, define networks of mutually-dependent invariants. Changing one cascades verification across the entire network.</p> <pre><code>invariant_network AccountingRules\n  total_assets == total_liabilities + equity\n  revenue - expenses == net_income\n  net_income flows_to equity\n  every(transaction) preserves total_assets == total_liabilities + equity\n\ntransforms post_transaction(ledger Ledger, tx Transaction) Ledger\n  satisfies AccountingRules\nfrom\n    // implementation\n</code></pre> <p>No function can be written in isolation \u2014 the compiler checks that the entire network remains consistent after every change. This is the ultimate non-local reasoning requirement. Requires a constraint solver that scales across modules.</p>"},{"location":"ai-resistance/#refutation-challenges","title":"Refutation Challenges","text":"<p>The compiler deliberately generates plausible-but-wrong alternative implementations and requires the programmer to explain why they fail. Compilation becomes a dialogue.</p> <pre><code>$ prove check src/sort.prv\n\nchallenge[C017]: Why doesn't this simpler implementation work?\n\n  transforms sort(xs List&lt;Integer&gt;) Sorted&lt;List&lt;Integer&gt;&gt;\n      reverse(dedup(xs))     // appears sorted for some inputs\n\n  refute: _______________\n\n  hint: Consider [3, 1, 2]\n</code></pre> <p>The programmer must provide a counterexample or logical argument. The compiler verifies the refutation is valid. This ensures the programmer understands not just what works, but why alternatives don't.</p>"},{"location":"ai-resistance/#phase-3-anti-training","title":"Phase 3 \u2014 Anti-Training","text":"<p>Phase 1 and 2 make it hard for AI to generate correct Prove code. Phase 3 goes further: making Prove source code resistant to being useful as AI training data. Even if scraped, Prove codebases should yield minimal learnable signal.</p> <p>AI training pipelines assume: (1) source code is plain text, (2) syntax is consistent across projects, (3) individual files are self-contained enough to learn from, and (4) surface patterns correlate with semantics. Prove attacks all four assumptions.</p>"},{"location":"ai-resistance/#project-specific-grammars","title":"Project-Specific Grammars","text":"<p>Each project can define syntactic extensions via its <code>prove.toml</code> manifest. Two Prove projects may look completely different at the surface level. Training data cannot generalize across projects.</p> <pre><code>// prove.toml\n[syntax]\npipe_operator = \"|&gt;\"\nmatch_arrow = \"=&gt;\"\n\n// Another project's prove.toml\n[syntax]\npipe_operator = \"&gt;&gt;\"\nmatch_arrow = \"-&gt;\"\n</code></pre> <pre><code>// Project A\nresult as List&lt;Data&gt; = data |&gt; filter(valid record) |&gt; map(transform)\n\n// Project B \u2014 same semantics, different surface\nresult as List&lt;Data&gt; = data &gt;&gt; filter(valid record) &gt;&gt; map(transform)\n</code></pre> <p>The compiler normalizes all syntax variants to the same AST. Scrapers see inconsistent syntax; the compiler sees identical programs. This destroys the statistical regularities that AI training depends on.</p>"},{"location":"ai-resistance/#structured-source-format-prv-is-not-plain-text","title":"Structured Source Format (<code>.prv</code> is not plain text)","text":"<p><code>.prv</code> files are stored as a compact binary AST, not human-readable text. The <code>prove</code> CLI provides views:</p> <pre><code>$ prove view src/server.prv              # pretty-print to terminal\n$ prove view src/server.prv --raw        # show the binary structure\n$ prove edit src/server.prv              # open in editor with LSP decoding\n$ prove export src/server.prv --text     # one-time text export\n</code></pre> <p>The editor experience is seamless \u2014 the language server decodes <code>.prv</code> on the fly, and the formatter writes binary back. But web scrapers, GitHub raw views, and training pipelines see binary blobs, not parseable source code.</p> <p>Why this works: Every major AI training pipeline (The Stack, StarCoder, etc.) filters for text files and parses by file extension. Binary files are discarded. Prove code is invisible to these pipelines by default.</p> <p>The <code>prove export --text</code> command exists for code review, diffs, and human sharing \u2014 but text is a view, not the source of truth.</p>"},{"location":"ai-resistance/#semantic-normalization-surface-patterns-destroyed","title":"Semantic Normalization (Surface Patterns Destroyed)","text":"<p>The compiler canonicalizes all code before storage. Variable names, ordering of declarations, whitespace, and stylistic choices are normalized away. What the programmer writes is not what is stored.</p> <pre><code>// What you write:\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\nfrom\n    subtotal as Decimal = sum(prices(items))\n    subtotal * (1 + tax.rate)\n\n// What is stored (canonical form):\ntransforms _f0(_a0 List&lt;_T0&gt;, _a1 _T1) _T2\nfrom\n    _v0 as _T3 = _f1(_f2(_a0))\n    _v0 * (1 + _a1._f3)\n\n// What you see (reconstructed with your naming via the LSP):\ntransforms calculate_total_price(items List&lt;Item&gt;, tax TaxRate) Price\nfrom\n    subtotal as Decimal = sum(prices(items))\n    subtotal * (1 + tax.rate)\n</code></pre> <p>A name map is stored alongside the canonical AST. The LSP reconstructs human-readable code on demand. But the stored form strips all semantic signal from identifiers \u2014 AI cannot learn naming conventions, domain patterns, or stylistic habits from Prove source.</p>"},{"location":"ai-resistance/#fragmented-source-no-file-is-self-contained","title":"Fragmented Source (No File Is Self-Contained)","text":"<p>A function's complete definition is distributed across multiple sections that only make sense together:</p> <pre><code>src/\n  server.prv          # implementation (canonical binary AST)\n  server.proof        # proof obligations for server.prv\n  server.intent       # intent declarations\n  server.near_miss    # adversarial near-miss examples\n  server.narrative    # module narrative\n</code></pre> <p>A scraper that grabs <code>server.prv</code> alone gets a canonical binary AST with no variable names, no comments, no documentation, and no proofs. The proof file without the implementation is meaningless. The intent file without both is noise.</p> <p>All five files are required to compile. The compiler assembles the complete picture. No single artifact is useful in isolation.</p>"},{"location":"ai-resistance/#identity-bound-compilation","title":"Identity-Bound Compilation","text":"<p>Source files carry a cryptographic signature chain. The compiler verifies authorship.</p> <pre><code>// Embedded in .prv binary header\n[signature]\nauthor = \"alice@example.com\"\nkey_fingerprint = \"A1B2C3...\"\nsigned_at = 2026-02-27T14:30:00Z\nchain = [\"alice@example.com\", \"bob@example.com\"]  // co-authors\n</code></pre> <ul> <li>Unsigned code triggers a compiler warning (or error in strict mode).</li> <li>The signature chain tracks who wrote and reviewed each function.</li> <li>Scraped code with stripped signatures won't compile.</li> <li>The compiler can optionally refuse to build code signed by unknown keys.</li> </ul> <p>This isn't DRM \u2014 it's provenance. The programmer can always export and re-sign. But mass scraping destroys the signature chain, making the code uncompilable.</p>"},{"location":"ai-resistance/#anti-training-license-as-default","title":"Anti-Training License as Default","text":"<p>Every <code>prove new</code> project is initialized with the Prove Source License v1.0 (see <code>LICENSE</code>). It is a permissive MIT-style license with comprehensive AI restrictions covering:</p> <ul> <li>Training, fine-tuning, and distillation (Section 3.1)</li> <li>Dataset inclusion, vector stores, RAG indices, and embedding databases (Section 3.2)</li> <li>Synthetic data generation from the Software (Section 3.3)</li> <li>Sublicensing for AI use \u2014 third parties cannot be granted AI rights (Section 3.4)</li> <li>Downstream propagation \u2014 all redistributors must carry the restrictions forward (Section 3.5)</li> <li>Technical protection circumvention \u2014 bypassing binary format, normalization, or signatures for AI training is a breach (Section 4)</li> </ul> <p>The license explicitly permits using AI tools to write Prove code and building AI-powered applications with Prove \u2014 it only prohibits using Prove source as training data.</p> <p>Design draws from: NON-AI-MIT (base structure), Common Paper (precise LLM language), Authors Guild (sublicensing prohibition), Open RAIL-S (downstream propagation). Should be reviewed by legal counsel before production use.</p> <p>This is not just a legal barrier \u2014 combined with the binary format and semantic normalization, it creates a layered defense: the code is hard to scrape, useless if scraped, and illegal to train on.</p>"},{"location":"ai-resistance/#the-fundamental-tension","title":"The Fundamental Tension","text":"<p>Every feature that makes code harder for AI also makes it harder for humans.</p> <p>The AI-resistance features force the programmer to:</p> <ul> <li>Explain their reasoning (proofs, intents, narratives, counterfactuals)</li> <li>Maintain global coherence (not just local correctness)</li> <li>Understand why, not just what (near-misses, refutation challenges)</li> <li>Acknowledge uncertainty (epistemic annotations)</li> <li>Respect temporal protocols (effect ordering)</li> </ul> <p>The uncomfortable truth is that the things AI is bad at are the things lazy humans skip too. A language that resists AI would also resist copy-paste programming, cargo-culting Stack Overflow, and coding without understanding.</p> <p>The anti-training features (binary format, semantic normalization, fragmented source) add friction to sharing and collaboration. The mitigation is a first-class toolchain: the <code>prove</code> CLI and LSP make the experience seamless for developers working inside the ecosystem, while making the code opaque to anything outside it.</p> <p>The design answers both questions: Prove resists AI writing the code (Phase 1 + 2) and resists AI training on the code (Phase 3).</p>"},{"location":"compiler/","title":"Compiler-Driven Development","text":""},{"location":"compiler/#conversational-compiler-errors","title":"Conversational Compiler Errors","text":"<p>Errors are suggestions, not walls:</p> <pre><code>error[E042]: `port` may exceed type bound\n  --&gt; server.prv:12:5\n   |\n12 |   port as Port = get_integer(config, \"port\")\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   = note: `get_integer` returns Integer, but Port requires 1..65535\n\n   try: port as Port = clamp(get_integer(config, \"port\"), 1, 65535)\n    or: port as Port = check(get_integer(config, \"port\"))!\n</code></pre>"},{"location":"compiler/#comptime-compile-time-computation","title":"Comptime (Compile-Time Computation)","text":"<p>Inspired by Zig. Arbitrary computation at compile time, including IO. Files read during comptime become build dependencies.</p> <pre><code>MAX_CONNECTIONS as Integer = comptime\n  match cfg.target\n    \"embedded\" =&gt; 16\n    _ =&gt; 1024\n\nLOOKUP_TABLE as List&lt;Integer:[32 Unsigned]&gt; = comptime\n  collect(map(0..256, crc32_step))\n\nROUTES as List&lt;Route&gt; = comptime\n  decode(read(\"routes.json\"))                   // IO allowed \u2014 routes.json becomes a build dep\n</code></pre>"},{"location":"contracts/","title":"Contracts &amp; Testing","text":""},{"location":"contracts/#formal-verification-of-contracts","title":"Formal Verification of Contracts","text":"<p>The compiler proves properties when it can, and generates tests when it can't:</p> <pre><code>transforms binary_search(xs Sorted&lt;List&lt;Integer&gt;&gt;, target Integer) Option&lt;Index&gt;\n  ensures is_some(result) implies xs[unwrap(result)] == target\n  ensures is_none(result) implies target not_in xs\n</code></pre>"},{"location":"contracts/#contracts-by-example-why-this-matters","title":"Contracts by Example \u2014 Why This Matters","text":"<p>Prove's contract system is not syntactic sugar for assertions. It is a fundamentally different relationship between programmer intent and compiler enforcement. To see why, compare the same function \u2014 <code>calculate_total</code> \u2014 across four languages.</p>"},{"location":"contracts/#prove","title":"Prove","text":"<pre><code>transforms calculate_total(items List&lt;OrderItem&gt;, discount Discount, tax TaxRule) Price\n  ensures result &gt;= 0\n  requires len(items) &gt; 0\n  proof\n    subtotal: sums the items Price\n    apply_discount: deduct discount if &gt; 0\n    apply_tax: adds tax if tax &gt; 0\nfrom\n    sub as Price = subtotal(items)\n    discounted as Price = apply_discount(discount, sub)\n    apply_tax(tax, discounted)\n</code></pre> <p>Three things happen at compile time:</p> <ul> <li><code>requires</code> \u2014 The compiler rejects any call site that cannot prove <code>len(items) &gt; 0</code>. This is not a runtime check. If your list might be empty, the code does not compile.</li> <li><code>ensures</code> \u2014 The compiler verifies that every code path produces <code>result &gt;= 0</code>. If it cannot prove this statically, it generates property tests that exercise thousands of inputs.</li> <li><code>proof</code> \u2014 The programmer explains why the postconditions hold. The compiler uses these proof hints to guide its verification. If the proof is wrong, the compiler says so.</li> </ul> <p>All three are mandatory. You cannot ship a function without declaring what it requires and what it guarantees.</p>"},{"location":"contracts/#python","title":"Python","text":"<pre><code>def calculate_total(items: list[OrderItem], discount: Discount, tax: TaxRule) -&gt; Price:\n    \"\"\"Calculate order total after discount and tax.\n\n    Args:\n        items: must be non-empty\n        discount: discount to apply\n        tax: tax rule to apply\n\n    Returns:\n        total price, always &gt;= 0\n    \"\"\"\n    assert len(items) &gt; 0  # only checked if -O is not set\n    sub = subtotal(items)\n    discounted = apply_discount(discount, sub)\n    result = apply_tax(tax, discounted)\n    assert result &gt;= 0  # also stripped by -O\n    return result\n</code></pre> <ul> <li>Preconditions \u2014 <code>assert</code> statements, stripped by <code>python -O</code>. The type hint <code>list[OrderItem]</code> says nothing about length. An empty list passes type checking and reaches runtime.</li> <li>Postconditions \u2014 Another <code>assert</code>, also stripped in production. The docstring says \"always &gt;= 0\" but nothing enforces it.</li> <li>Proof \u2014 Does not exist. The docstring is a comment. Tests are a separate file written by a separate person at a separate time.</li> </ul>"},{"location":"contracts/#haskell","title":"Haskell","text":"<pre><code>calculateTotal :: NonEmpty OrderItem -&gt; Discount -&gt; TaxRule -&gt; Price\n-- | Precondition: items is non-empty (enforced by NonEmpty type)\n-- | Postcondition: result &gt;= 0 (NOT enforced \u2014 Price is just a newtype)\ncalculateTotal items discount tax =\n  let sub = subtotal (toList items)\n      discounted = applyDiscount discount sub\n  in applyTax tax discounted\n</code></pre> <ul> <li>Preconditions \u2014 <code>NonEmpty</code> enforces non-emptiness at the type level. This is genuinely good. But most preconditions (\"discount is valid\", \"tax rate is between 0 and 1\") require dependent types that Haskell does not have.</li> <li>Postconditions \u2014 Comments. The type <code>Price</code> does not carry the invariant <code>&gt;= 0</code> unless you build a custom smart constructor, and even then the compiler does not verify that <code>applyTax</code> preserves it.</li> <li>Proof \u2014 Does not exist in the language. QuickCheck can test properties, but it is a library, it is opt-in, and the properties are written in test files separate from the function.</li> </ul>"},{"location":"contracts/#rust","title":"Rust","text":"<pre><code>fn calculate_total(items: &amp;[OrderItem], discount: &amp;Discount, tax: &amp;TaxRule) -&gt; Price {\n    debug_assert!(!items.is_empty(), \"items must be non-empty\");\n    let sub = subtotal(items);\n    let discounted = apply_discount(discount, sub);\n    let result = apply_tax(tax, discounted);\n    debug_assert!(result &gt;= Price::ZERO, \"result must be non-negative\");\n    result\n}\n</code></pre> <ul> <li>Preconditions \u2014 <code>debug_assert!</code>, compiled out in release builds. The slice type <code>&amp;[OrderItem]</code> permits empty slices. A <code>NonEmpty</code> wrapper exists in crates but is not standard.</li> <li>Postconditions \u2014 Another <code>debug_assert!</code>, also absent in release. The type system enforces memory safety but says nothing about business logic invariants.</li> <li>Proof \u2014 Does not exist. Tests are in a <code>#[cfg(test)]</code> module. Property testing requires <code>proptest</code> or <code>quickcheck</code> crates, and properties are written manually in test files.</li> </ul>"},{"location":"contracts/#summary","title":"Summary","text":"Capability Prove Python Haskell Rust Preconditions <code>requires</code> \u2014 compile-time enforced <code>assert</code> \u2014 runtime, strippable Types cover some; rest are comments <code>debug_assert!</code> \u2014 stripped in release Postconditions <code>ensures</code> \u2014 compiler-verified or auto-tested <code>assert</code> \u2014 runtime, strippable Comments or smart constructors (manual) <code>debug_assert!</code> \u2014 stripped in release Proof of correctness <code>proof</code> \u2014 checked by compiler Does not exist Does not exist Does not exist Test generation Automatic from contracts Manual (pytest, hypothesis) Manual (QuickCheck) Manual (proptest) Contracts are... Mandatory, part of the function signature Optional, easily ignored Convention, not enforced Convention, not enforced <p>The gap is not about syntax. Python, Haskell, and Rust all have mechanisms for expressing some of these ideas. The difference is that in Prove, contracts are mandatory, compiler-enforced, and self-testing. You cannot write a function that silently ignores its own guarantees.</p>"},{"location":"contracts/#auto-testing","title":"Auto-Testing","text":"<p>Testing is not a separate activity. It is woven into the language \u2014 contracts are mandatory and the compiler enforces them.</p>"},{"location":"contracts/#level-1-contracts-generate-property-tests","title":"Level 1: Contracts Generate Property Tests","text":"<p>No test file needed. No QuickCheck boilerplate. The compiler generates thousands of random inputs and verifies all postconditions hold. Contracts are mandatory \u2014 every function declares what it guarantees.</p> <pre><code>transforms sort(xs List&lt;T&gt;) List&lt;T&gt;\n  ensures len(result) == len(xs)\n  ensures is_sorted(result)\n  ensures is_permutation_of(result, xs)\nfrom\n    // implementation\n</code></pre>"},{"location":"contracts/#level-2-automatic-edge-case-generation","title":"Level 2: Automatic Edge-Case Generation","text":"<p>Given the type signature alone, the compiler knows to test boundary values and heuristic edge cases:</p> <pre><code>transforms divide(a Integer, b NonZero&lt;Integer&gt;) Integer\n// Auto-generated test inputs: (0, 1), (1, 1), (-1, 1), (MAX_INT, 1),\n// (MIN_INT, -1), (7, 3), ...\n// Derived from type bounds + heuristic edge-case generation\n</code></pre> <p>For refinement types, boundary testing is automatic:</p> <pre><code>transforms set_port(p Port) Config    // Port = 1..65535\n// Auto-tests: 1, 2, 65534, 65535, and random values between\n// Also verifies that 0 and 65536 are rejected at the call site\n</code></pre>"},{"location":"contracts/#level-4-built-in-mutation-testing","title":"Level 4: Built-in Mutation Testing","text":"<pre><code>$ prove build --mutate\n\nMutation score: 97.2% (347/357 mutants killed)\nSurviving mutants:\n  src/cache.prv:45  \u2014 changed `&gt;=` to `&gt;` (boundary condition not covered)\n  src/cache.prv:82  \u2014 removed `+ 1` (off-by-one not detected)\n\n  Suggested contract to add:\n    ensures len(cache) &lt;= max_size   // would kill both mutants\n</code></pre>"},{"location":"design/","title":"Design Decisions &amp; Trade-offs","text":""},{"location":"design/#philosophy","title":"Philosophy","text":"<p>The compiler is your co-author, not your gatekeeper.</p> <p>Every feature exists to move correctness checks from runtime to compile time, and to generate tests from the code you already write. Most bugs are type errors in disguise \u2014 give the type system enough power and they become almost impossible.</p>"},{"location":"design/#implementation-decisions","title":"Implementation Decisions","text":""},{"location":"design/#file-extension-prv","title":"File Extension: <code>.prv</code>","text":"<p>Investigated <code>.pv</code>, <code>.prove</code>, <code>.prf</code>, <code>.pr</code>, and <code>.prv</code>. Chosen: <code>.prv</code> \u2014 short, reads naturally as \"Prove\", and has no conflicts with existing programming languages or developer tooling.</p> Rejected Reason <code>.pv</code> Taken by ProVerif (formal methods \u2014 same domain, high confusion risk) <code>.prove</code> Taken by Perl's <code>prove</code> test harness (well-known in dev tooling) <code>.prf</code> Taken by MS Outlook profiles and Qt feature files <code>.pr</code> Legacy Source Insight 3, but \"PR\" universally means \"pull request\""},{"location":"design/#prototype-implementation-python","title":"Prototype Implementation: Python","text":"<p>The compiler POC is implemented in Python (&gt;=3.11). The goal is to validate the language design and prove out the compilation pipeline before rewriting in a systems language.</p>"},{"location":"design/#compilation-target-native-code","title":"Compilation Target: Native Code","text":"<p>As close to the CPU as possible. The compiler does the heavy lifting at compile time so the output is fast and memory-efficient. Target: native code via direct assembly emission (x86_64 + ARM64). No VM, no interpreter for production output.</p>"},{"location":"design/#first-poc-self-hosting-compiler","title":"First POC: Self-Hosting Compiler","text":"<p>The first program written in Prove will be the Prove compiler itself. The bootstrap path: (1) write a complete compiler in Python, (2) use it to compile a Prove compiler written in Prove. This exercises the type system (AST node types, token variants), verb system (transforms for pure passes, inputs for file reading, outputs for code emission), pattern matching (exhaustive over AST nodes), and algebraic types \u2014 proving the language works by compiling itself. Self-hosting is the strongest possible validation: if Prove can express its own compiler, it can express anything.</p>"},{"location":"design/#ai-resistance-fundamental","title":"AI-Resistance: Fundamental","text":"<p>AI-resistance features (proof obligations, intent declarations, narrative coherence, context-dependent syntax, semantic commits) are mandatory and fundamental to the language identity, not optional extras. Proof obligations are required for every function that has <code>ensures</code> clauses \u2014 if you declare what a function guarantees, you must prove why.</p>"},{"location":"design/#comptime-io-allowed","title":"Comptime: IO Allowed","text":"<p>Compile-time computation (<code>comptime</code>) allows IO operations. This enables reading config files, schema definitions, and static assets at compile time. Files accessed during comptime become build dependencies \u2014 changing them triggers recompilation. This may be revisited if reproducibility concerns arise.</p>"},{"location":"design/#cli-first-toolchain-prove","title":"CLI-First Toolchain: <code>prove</code>","text":"<p>The <code>prove</code> CLI is the central interface for all development:</p> <pre><code>prove build          # compile the project\nprove test           # run auto-generated + manual tests\nprove check          # type-check without building\nprove format         # auto-format source code\nprove lsp            # start the language server\nprove build --mutate # run mutation testing\nprove new &lt;name&gt;     # scaffold a new project\n</code></pre>"},{"location":"design/#syntax-philosophy","title":"Syntax Philosophy","text":"<p>No shorthands. No abbreviations. Full words everywhere. The language reads like English prose where possible. Since it is inherently a hard-to-learn language (refinement types, proof obligations, effect tracking), simplicity is maximized wherever possible. If something can be simple, it must be. The compiler works for the programmer, not the other way around.</p>"},{"location":"design/#secondary-priorities-deferred","title":"Secondary Priorities (Deferred)","text":"<ul> <li>C FFI \u2014 important but not day-one. Will be addressed after the core language is stable.</li> <li>Calling Prove from other languages \u2014 deferred until the FFI story is established.</li> <li>Method syntax \u2014 deferred. All function calls use <code>function(args)</code> form. No <code>object.method()</code> dot-call syntax. Keeps the language simple and avoids dispatch complexity. Field access (<code>user.name</code>) is unaffected.</li> </ul>"},{"location":"design/#concurrency-structured-typed-no-data-races","title":"Concurrency \u2014 Structured, Typed, No Data Races","text":"<pre><code>inputs fetch_all(urls List&lt;Url&gt;) List&lt;Response&gt;!\nfrom\n    par_map(urls, fetch)\n</code></pre> <p>The ownership system and effect types combine to eliminate data races at compile time.</p>"},{"location":"design/#error-handling-errors-are-values","title":"Error Handling \u2014 Errors Are Values","text":"<p>No exceptions. Every failure path is visible in the type signature. Uses <code>!</code> for error propagation. Panics exist only for violated <code>assume:</code> assertions at system boundaries \u2014 normal error handling is always through <code>Result</code> values.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\nfrom\n    config as Config = read_config(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"design/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<ul> <li>Pure functions auto-memoized and inlined</li> <li>Region-based memory for short-lived allocations</li> <li>Reference counting only where ownership is shared (compiler-inserted)</li> <li>No GC pauses, predictable performance</li> <li>Native code output</li> </ul>"},{"location":"design/#pain-point-comparison","title":"Pain Point Comparison","text":"Pain in existing languages How Prove solves it Tests are separate from code Testing is part of the definition \u2014 <code>ensures</code>, <code>requires</code>, <code>near_miss</code> \"Works on my machine\" Verb system makes IO explicit (<code>inputs</code>/<code>outputs</code>) Null/nil crashes No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by compiler Race conditions Ownership + verb system prevents data races \"I forgot an edge case\" Compiler generates edge cases from types Slow test suites Property tests run at compile time when provable Runtime type errors Refinement types catch invalid values at compile time"},{"location":"design/#trade-offs","title":"Trade-offs","text":"<p>An honest assessment of the costs:</p> <ol> <li>Compilation speed \u2014 Proving properties is expensive. Incremental compilation and caching are essential. Expect Rust-like compile times, not Go-like.</li> <li>Learning curve \u2014 Refinement types and effect types are unfamiliar to most developers. The compiler's suggestions help, but there's still a ramp-up.</li> <li>Ecosystem bootstrap \u2014 A new language needs libraries. A C FFI and a story for wrapping existing libraries is a secondary priority, deferred until the core language is stable.</li> <li>Not every property is provable \u2014 For complex invariants the compiler falls back to runtime property tests, which is still better than nothing but not a proof.</li> </ol> <p>The core bet: Making the compiler do more work upfront saves orders of magnitude more time than writing and maintaining tests by hand.</p>"},{"location":"inspirations/","title":"Design Inspirations","text":"Language What Prove borrows What Prove avoids Rust Ownership model, exhaustive matching, no null Lifetime annotation burden, borrow checker complexity Haskell Type system, pure functions, algebraic types IO monad complexity, lazy evaluation surprises Go Parameter syntax (<code>name Type</code>), simplicity as goal Weak type system, error handling verbosity Python Indentation-based blocks, readability philosophy Dynamic typing, runtime errors Zig <code>comptime</code> (compile-time computation with IO) Manual memory management Ada/SPARK Contract-based programming, formal verification Verbose syntax Idris/Agda Dependent types for encoding invariants Academic accessibility barrier Elm Eliminating runtime exceptions, compiler as assistant Limited to frontend F# Pragmatic algebraic types, pipeline operator \u2014"},{"location":"syntax/","title":"Syntax Reference","text":""},{"location":"syntax/#naming","title":"Naming","text":"<ul> <li>Types, modules, and classes: CamelCase \u2014 <code>Shape</code>, <code>Port</code>, <code>UserAuth</code>, <code>NonEmpty</code>, <code>HttpServer</code></li> <li>Variables and parameters: snake_case \u2014 <code>port</code>, <code>user_list</code>, <code>max_retries</code>, <code>db_connection</code></li> <li>Functions: snake_case \u2014 <code>area</code>, <code>binary_search</code>, <code>get_users</code></li> <li>Constants: UPPER_SNAKE_CASE \u2014 <code>MAX_CONNECTIONS</code>, <code>LOOKUP_TABLE</code>, <code>DEFAULT_PORT</code></li> <li>Effects: CamelCase \u2014 <code>IO</code>, <code>Fail</code>, <code>Async</code></li> </ul> <p>The compiler enforces casing. Wrong case is a compile error, not a warning. UPPER_SNAKE_CASE indicates a compile-time constant \u2014 no <code>const</code> keyword needed.</p>"},{"location":"syntax/#modules-and-imports","title":"Modules and Imports","text":"<p>Each file is a module. The filename (without extension) is the module name in CamelCase. The <code>module</code> block is mandatory and contains all declarations/metadata: narrative, imports, types, constants, and invariant networks. Functions remain top-level:</p> <pre><code>module InventoryService\n  narrative: \"\"\"Products are added to inventory...\"\"\"\n  String contains length\n  Auth validates login, transforms login\n  Http inputs request session\n\n  type Product is\n    sku Sku\n    name String\n\n  MAX_CONNECTIONS as Integer = 1024\n\n  invariant_network Accounting\n    total &gt;= 0\n</code></pre> <p>A verb applies to all space-separated names that follow it. Commas separate verb groups. Multiple verbs for the same function name import each variant. The verb is part of the function's identity.</p>"},{"location":"syntax/#blocks-and-indentation","title":"Blocks and Indentation","text":"<p>No curly braces. Indentation defines scope (like Python). No semicolons \u2014 newlines terminate statements. Newlines are suppressed after operators, commas, opening brackets, <code>-&gt;</code>, <code>=&gt;</code>.</p>"},{"location":"syntax/#primitive-types-full-names-no-shorthands","title":"Primitive Types \u2014 Full Names, No Shorthands","text":"<p>Every type uses its full name. No abbreviations. Type modifiers use bracket syntax <code>Type:[Modifier ...]</code> for storage and representation concerns. Value constraints belong in refinement types (<code>where</code>), not modifiers.</p> Type Modifier Axes Default Examples <code>Integer</code> size (8/16/32/64/128), signedness (Signed/Unsigned) <code>Integer:[64 Signed]</code> <code>Integer:[32 Unsigned]</code>, <code>Integer:[8]</code> <code>Decimal</code> precision (32/64/128), scale (Scale:N) <code>Decimal:[64]</code> <code>Decimal:[128 Scale:2]</code> <code>Float</code> precision (32/64) <code>Float:[64]</code> <code>Float:[32]</code> <code>Boolean</code> \u2014 \u2014 \u2014 <code>String</code> encoding (UTF8/ASCII/UTF16), max length <code>String:[UTF8]</code> <code>String:[UTF8 15]</code>, <code>String:[ASCII 255]</code> <code>Byte</code> \u2014 \u2014 Distinct type for binary data <code>Character</code> encoding (UTF8/UTF16/ASCII) <code>Character:[UTF8]</code> <code>Character:[ASCII]</code> <p>Modifier rules: - Modifiers are order-independent \u2014 <code>Integer:[Signed 64]</code> and <code>Integer:[64 Signed]</code> are identical. The compiler normalizes internally. - Each modifier occupies a distinct axis. Two modifiers on the same axis is a compile error: <code>Integer:[32 64]</code> \u2192 ERROR: conflicting size modifiers. - Positional modifiers when unambiguous by kind. Named modifiers (<code>Key:Value</code>) when a bare value could be confused: <code>Decimal:[128 Scale:2]</code>. - Bare type name uses sensible defaults: <code>Integer</code> means <code>Integer:[64 Signed]</code>, <code>String</code> means <code>String:[UTF8]</code>, <code>Decimal</code> means <code>Decimal:[64]</code>. - <code>Float</code> is opt-in \u2014 <code>Decimal</code> is the default for fractional numbers. <code>Float:[64]</code> uses IEEE 754 hardware floats for performance-critical domains (scientific computing, graphics, signal processing) where speed matters more than exact precision. Mixing <code>Float</code> and <code>Decimal</code> requires explicit conversion.</p> <pre><code>count as Integer = 42                          // Integer:[64 Signed]\nflags as Integer:[8 Unsigned] = 0xFF\nprice as Decimal:[128 Scale:2] = 19.99         // financial precision\nname as String = \"Alice\"                        // String:[UTF8]\ncode as String:[ASCII 4] = \"US01\"              // ASCII, max 4 characters\nactive as Boolean = true\nraw as Byte = 0x2A\nletter as Character = 'A'\n</code></pre> <p>Separation of concerns \u2014 modifiers describe storage, refinements describe values:</p> <pre><code>// Modifier: how it's stored\nraw_port as Integer:[16 Unsigned] = 8080\n\n// Refinement: what values are valid\ntype Port is Integer where 1..65535\n\n// Combined: storage + value constraint\ntype Port is Integer:[16 Unsigned] where 1..65535\n</code></pre>"},{"location":"syntax/#type-definitions","title":"Type Definitions","text":"<p>Types live inside the <code>module</code> block, defined with <code>type Name is</code>:</p> <pre><code>module Main\n  type Shape is\n    Circle(radius Decimal)\n    | Rect(w Decimal, h Decimal)\n\n  type Port is Integer:[16 Unsigned] where 1 .. 65535\n\n  type Result&lt;T, E&gt; is Ok(T) | Err(E)\n\n  type User is\n    id Integer\n    name String\n    email String\n</code></pre>"},{"location":"syntax/#function-declarations-intent-verbs","title":"Function Declarations \u2014 Intent Verbs","text":"<p>Functions are declared with a verb that describes their purpose. No <code>fn</code>, no <code>function</code> keyword \u2014 the verb IS the declaration. The compiler verifies the implementation matches the declared intent.</p> Verb Purpose Compiler enforces <code>transforms</code> Pure data computation/conversion No <code>!</code>. Failure encoded in return type (<code>Result</code>, <code>Option</code>) <code>inputs</code> Reads/receives from external world IO is inherent. <code>!</code> marks fallibility. Implicit match when first param is algebraic <code>outputs</code> Writes/sends to external world IO is inherent. <code>!</code> marks fallibility <code>validates</code> Pure boolean check No <code>!</code>. Return type is implicitly <code>Boolean</code> <pre><code>transforms area(s Shape) Decimal\nfrom\n    match s\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms normalize(data List&lt;Decimal&gt;) List&lt;Decimal&gt;\n  ensures len(result) == len(data)\nfrom\n    max_val as Decimal = max(data)\n    divide_each(data, max_val)\n\ntransforms parse(raw String) Result&lt;Config, ParseError&gt;\nfrom\n    decode(raw)\n\ninputs users() List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs log(message String)\nfrom\n    write(stdout, message)\n\ninputs request(route Route, req Request) Response!\nfrom\n        Get(/health) =&gt; ok(\"healthy\")\n        Get(/users) =&gt; users()! |&gt; ok\n        Post(/users) =&gt; create(req.body)! |&gt; created\n        _ =&gt; not_found()\n</code></pre>"},{"location":"syntax/#verb-dispatched-identity","title":"Verb-Dispatched Identity","text":"<p>Functions are identified by the triple <code>(verb, name, parameter types)</code> \u2014 not just <code>(name, parameter types)</code>. The same function name can be declared multiple times with different verbs, each with a distinct meaning:</p> <pre><code>validates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\ntransforms email(raw String) Email\nfrom\n    lowercase(trim(raw))\n\ninputs email(user_id Integer) Email!\nfrom\n    query(db, \"SELECT email FROM users WHERE id = {user_id}\")!\n</code></pre> <p>Three functions, all named <code>email</code>, with completely different intents.</p>"},{"location":"syntax/#context-aware-call-resolution","title":"Context-Aware Call Resolution","text":"<p>At call sites, you use just the function name \u2014 the compiler resolves which verb-variant to call based on context (expected type, parameter types, expression position):</p> <pre><code>// Boolean context (match on Boolean) \u2192 resolves to validates email\nmatch email(input)\n    true =&gt;\n        clean as Email = email(raw_input)    // Email context + String param \u2192 transforms\n        stored as Email = email(user.id)     // Email context + Integer param \u2192 inputs\n    false =&gt; handle_invalid()\n\n// When context is ambiguous, use `valid` for explicit Boolean cast\nprint(valid email(input))               // forces validates variant\n\n// `valid` as type-cast parameter \u2014 passes the validates function itself\nfilter(users, valid email)              // passes `validates email` as predicate\n</code></pre> <p>Resolution rules: 1. Boolean context (<code>match</code> on Boolean, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) \u2192 resolves to <code>validates</code> variant 2. Expected type from assignment or parameter \u2192 matches the variant returning that type 3. Parameter types disambiguate between variants with the same return type 4. Ambiguous \u2192 compiler error with suggestions listing available variants</p> <p>The <code>valid</code> keyword serves two purposes: - As expression: <code>valid email(input)</code> \u2014 casts a validates call to its Boolean result explicitly - As function reference: <code>valid email</code> (no parens) \u2014 passes the validates function as a predicate to higher-order functions like <code>filter</code></p> <p>Implications:</p> <ul> <li>Imports are precise: <code>Auth validates login, inputs session</code></li> <li>API docs group by verb: what can you validate? what can you yield? what can you transform?</li> <li>Call sites are clean: just the function name in most cases</li> <li>AI resistance: declarations require the correct verb, and the resolution rules add non-local reasoning requirements</li> </ul>"},{"location":"syntax/#parameters","title":"Parameters","text":"<p>Go-style: <code>name Type</code> (no colon). Inside parentheses, the declaration context is already clear.</p> <pre><code>transforms area(s Shape) Decimal\ninputs request(route Route, body String) Response!\nvalidates email(address String)\n</code></pre>"},{"location":"syntax/#variable-declarations","title":"Variable Declarations","text":"<p>Variables use <code>name as Type = value</code>. The <code>as</code> keyword reads naturally: \"port, as a Port, equals 8080\".</p> <pre><code>port as Port = 8080\nserver as Server = new_server()\nconfig as Config = load(\"app.yaml\")!\nuser_list as List&lt;User&gt; = users()!\n</code></pre> <p>Variables are immutable by default. Mutability is a type modifier \u2014 it's a storage concern, like size and signedness:</p> <pre><code>counter as Integer:[Mutable] = 0\ncounter = counter + 1\n</code></pre>"},{"location":"syntax/#type-inference-with-formatter-enforcement","title":"Type Inference with Formatter Enforcement","text":"<p>The compiler infers types when unambiguous, but <code>prove format</code> always inserts explicit type annotations. This means you can write clean code during development, and the formatter makes it explicit before commit.</p> <pre><code>// What you write:\nport = 8080\nserver = new_server()\nusers = query(db, \"SELECT * FROM users\")!\n\n// What `prove format` produces:\nport as Integer = 8080\nserver as Server = new_server()\nusers as List&lt;User&gt; = query(db, \"SELECT * FROM users\")!\n</code></pre> <p>The LSP shows inferred types inline as you type, so you always know what the compiler deduced. Function signatures are always explicit \u2014 inference only applies to local variables.</p> <p>The language encourages explicit types \u2014 the formatter enforces them. But you're never blocked from writing code because you can't remember whether it's <code>List&lt;Map&lt;String, User&gt;&gt;</code> or <code>Map&lt;String, List&lt;User&gt;&gt;</code>.</p>"},{"location":"syntax/#io-and-fallibility","title":"IO and Fallibility","text":"<p>IO is inherent in the verb \u2014 <code>inputs</code> and <code>outputs</code> always interact with the external world. Fallibility is marked with <code>!</code> on the return type. Pure verbs (<code>transforms</code>, <code>validates</code>) have neither IO nor <code>!</code>.</p> <pre><code>transforms area(s Shape) Decimal\nfrom\n    pi * s.radius * s.radius\n\ninputs users() List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\noutputs write_log(entry String)\nfrom\n    append(log_file, entry)\n</code></pre> <p>Reads as: \"inputs users, returns List of User, can fail!\"</p> <p>The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which don't (<code>transforms</code>/<code>validates</code>) \u2014 the verb IS the declaration.</p>"},{"location":"syntax/#body-marker-from","title":"Body Marker: <code>from</code>","text":"<p>Every function body begins with <code>from</code>. No exceptions. This reads as \"the result comes from...\" and makes it immediately clear where the implementation starts, whether the function has annotations or not.</p> <pre><code>transforms area(s Shape) Decimal\nfrom\n    pi * s.radius * s.radius\n\ninputs users() List&lt;User&gt;!\n  ensures len(result) &gt;= 0\nfrom\n    query(db, \"SELECT * FROM users\")!\n</code></pre>"},{"location":"syntax/#pattern-matching-the-only-way-to-branch","title":"Pattern Matching \u2014 The Only Way to Branch","text":"<p>Prove has no <code>if</code>/<code>else</code>. All branching is done through <code>match</code>.</p> <pre><code>match route\n    Get(\"/health\") =&gt; ok(\"healthy\")\n    Get(\"/users\")  =&gt; users()!\n    _              =&gt; not_found()\n\nmatch connected\n    true  =&gt; send(data)\n    false =&gt; retry()\n\nMAX_CONNECTIONS as Integer = comptime\n    match cfg.target\n        \"embedded\" =&gt; 16\n        _ =&gt; 1024\n</code></pre> <p>This is not an omission. It is a deliberate design choice with consequences for correctness, verification, and code quality.</p>"},{"location":"syntax/#why-no-if","title":"Why No <code>if</code>","text":"<p>1. <code>match</code> is exhaustive. <code>if</code> is not.</p> <p>An <code>if</code> without <code>else</code> silently does nothing on the false branch. The programmer may not have intended this \u2014 they may have forgotten the other case. In Prove, <code>match</code> on a Boolean requires both <code>true =&gt;</code> and <code>false =&gt;</code> arms. The compiler rejects incomplete branching.</p> <pre><code>// This is a compile error \u2014 you must handle both cases:\nmatch connected\n    true =&gt; send(data)\n// error: non-exhaustive match \u2014 missing 'false' arm\n</code></pre> <p>Every branch point in the program explicitly states what happens in every case. There are no invisible default paths.</p> <p>2. <code>if</code> obscures what you are branching on.</p> <p>An <code>if</code> condition is an expression floating in the middle of a function body. A <code>match</code> names its subject and structurally enumerates the possibilities. When conditions get complex, <code>if</code>/<code>else if</code>/<code>else</code> chains become hard to follow. A <code>match</code> block is always a flat table: subject at the top, one arm per case, every arm visible.</p> <p>3. One construct is simpler than two.</p> <p>Every <code>if</code>/<code>else</code> is isomorphic to <code>match condition / true =&gt; ... / false =&gt; ...</code>. Having both constructs adds no expressive power \u2014 it only adds surface area to the language, the parser, the type checker, the emitter, the formatter, and every tool that processes Prove code. Removing <code>if</code> means less to learn, less to implement, and fewer ways to express the same thing.</p> <p>4. <code>if</code> encourages guard-style early returns.</p> <p>In many languages, <code>if</code> is used for guard clauses:</p> <pre><code>if !valid(input)\n    return error(\"bad input\")\n// continue with the happy path\n</code></pre> <p>This pattern breaks the principle that a function body is a single expression tree that produces a value. It introduces invisible control flow \u2014 the reader must mentally track which conditions have been checked at each point in the function. In Prove, the same logic is a <code>match</code>:</p> <pre><code>match valid input\n    false =&gt; error(\"bad input\")\n    true =&gt;\n        // happy path \u2014 structurally inside the arm\n</code></pre> <p>Both branches are explicitly scoped. There is no ambiguity about which code runs when.</p> <p>5. Contracts need visible branches.</p> <p>Prove's compiler verifies <code>ensures</code> postconditions across all code paths. With <code>match</code>, every arm is structurally enumerable \u2014 the compiler (and the programmer writing <code>proof</code> blocks) can see every branch and reason about each one. An <code>if</code> without <code>else</code> has an implicit branch that returns <code>Unit</code>, which is invisible to both the programmer and the verifier. Making all branches explicit makes contracts easier to write, easier to verify, and harder to get wrong.</p>"},{"location":"syntax/#the-rule","title":"The Rule","text":"<p>All conditional logic in Prove is expressed through <code>match</code>. Boolean conditions, algebraic type dispatch, literal comparison, and exhaustive enumeration all use the same construct with the same guarantees.</p>"},{"location":"syntax/#lambdas-constrained-inline-functions","title":"Lambdas \u2014 Constrained Inline Functions","text":"<p>Lambdas are single-expression anonymous functions, used exclusively as arguments to higher-order functions like <code>map</code>, <code>filter</code>, and <code>reduce</code>. They cannot capture mutable state and must be pure.</p> <p>Syntax: <code>|params| expression</code></p> <pre><code>// Filtering with a lambda\nactive_users as List&lt;User&gt; = filter(users, |u| u.active)\n\n// Mapping with a lambda\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Reducing with a lambda\ntotal as Decimal = reduce(prices, 0, |acc, p| acc + p)\n\n// Using `valid` to pass a validates function as predicate (no lambda needed)\nverified_emails as List&lt;String&gt; = filter(emails, valid email)\n</code></pre> <p>Constraints: - Single expression only \u2014 no multi-line bodies, no statements. If you need more, write a named function. - Must be pure \u2014 no IO effects inside a lambda. Side effects require a named function. - No closures over mutable state \u2014 lambdas can reference immutable bindings from the enclosing scope, but not <code>:[Mutable]</code> variables. - Only as arguments \u2014 lambdas cannot be assigned to variables or returned from functions. They exist only at the call site of a higher-order function.</p>"},{"location":"syntax/#iteration-no-loops","title":"Iteration \u2014 No Loops","text":"<p>Prove has no <code>for</code>, <code>while</code>, or loop constructs. Iteration is expressed through <code>map</code>, <code>filter</code>, <code>reduce</code>, and recursion. This keeps all data transformations as expressions (they produce values) rather than statements.</p> <pre><code>// Instead of: for each user, get their name\nnames as List&lt;String&gt; = map(users, |u| u.name)\n\n// Instead of: for each item, keep valid ones\nvalid_items as List&lt;Item&gt; = filter(items, |i| i.quantity &gt; 0)\n\n// Instead of: accumulate a total with a loop\ntotal as Decimal = reduce(order.items, 0, |acc, item| acc + item.price * item.quantity)\n\n// Chaining with pipe operator\nresult as List&lt;String&gt; = users\n    |&gt; filter(|u| u.active)\n    |&gt; map(|u| u.email)\n    |&gt; filter(valid email)\n</code></pre> <p>For complex iteration that doesn't fit map/filter/reduce, use recursion with a <code>transforms</code> function. The compiler verifies termination through proof obligations.</p>"},{"location":"syntax/#keyword-exclusivity","title":"Keyword Exclusivity","text":"<p>Every keyword in Prove has exactly one purpose. No keyword is overloaded across different contexts. This makes the language predictable and parseable by humans without memorizing context-dependent rules.</p> <p>Core keywords:</p> Keyword What it does <code>transforms</code> Declares a pure function \u2014 no side effects, just data in, data out <code>inputs</code> Declares a function that reads from the outside world (database, file, network) <code>outputs</code> Declares a function that writes to the outside world <code>validates</code> Declares a function that returns true or false <code>main</code> The program's entry point \u2014 can freely mix reading and writing <code>from</code> Marks where the function body starts \u2014 \"the result comes from...\" <code>where</code> Adds a value constraint to a type \u2014 <code>Integer where 1..65535</code> <code>as</code> Declares a variable \u2014 <code>name as Type = value</code> <code>type</code> Defines a new type \u2014 <code>type Port is Integer where 1..65535</code> <code>match</code> Branches on a value \u2014 the only way to do conditional logic <code>ensures</code> States what a function guarantees about its result <code>requires</code> States what must be true before calling a function <code>proof</code> Explains why the guarantees hold \u2014 checked by the compiler <code>valid</code> References a <code>validates</code> function as a predicate <code>comptime</code> Runs code at compile time instead of runtime <p>AI-Resistance keywords (Phase 1+2):</p> Keyword What it does <code>domain</code> Sets the module's domain \u2014 syntax adapts to the context <code>intent</code> Declares what a piece of code is meant to do \u2014 compiler checks it matches <code>narrative</code> Describes the module's purpose \u2014 unrelated functions are rejected <code>why_not</code> Documents a rejected alternative \u2014 \"we didn't do X because...\" <code>chosen</code> Documents the chosen approach \u2014 \"we did Y because...\" <code>near_miss</code> An input that almost breaks the code but doesn't \u2014 proves you understand the boundary <code>know</code> \"I'm certain\" \u2014 the compiler can prove this, no runtime cost <code>assume</code> \"I expect this\" \u2014 the compiler adds a runtime check at boundaries <code>believe</code> \"I think this\" \u2014 the compiler generates tests trying to disprove it <code>temporal</code> Enforces the order things must happen \u2014 e.g. authenticate before access <code>satisfies</code> Declares that a function obeys a set of rules <code>invariant_network</code> Defines a set of rules that must always hold together"},{"location":"syntax/#error-propagation","title":"Error Propagation","text":"<p><code>!</code> marks fallibility \u2014 on declarations it means \"this function can fail\", at call sites it propagates the error. Only IO verbs (<code>inputs</code>, <code>outputs</code>) can use <code>!</code>. Pure functions encode failure in the return type (<code>Result&lt;T, E&gt;</code>) and handle it with <code>match</code>.</p> <pre><code>main() Result&lt;Unit, Error&gt;!\nfrom\n    config as Config = load(\"app.yaml\")!\n    db as Database = connect(config.db_url)!\n    serve(config.port, db)!\n</code></pre>"},{"location":"syntax/#complete-example-restful-server","title":"Complete Example: RESTful Server","text":"<pre><code>type Port is Integer:[16 Unsigned] where 1 .. 65535\ntype Route is Get(path String) | Post(path String) | Delete(path String)\n\ntype User is\n  id Integer\n  name String\n  email String\n\n/// Checks whether a string is a valid email address.\nvalidates email(address String)\nfrom\n    contains(address, \"@\") &amp;&amp; contains(address, \".\")\n\n/// Retrieves all users from the database.\ninputs users(db Database) List&lt;User&gt;!\nfrom\n    query(db, \"SELECT * FROM users\")!\n\n/// Creates a new user from a request body.\noutputs create(db Database, body String) User!\n  ensures email(result.email)\n  proof\n    email_valid: decode validates the email field before insertion\nfrom\n    user as User = decode(body)!\n    insert(db, \"users\", user)!\n    user\n\n/// Routes incoming HTTP requests.\ninputs request(route Route, body String, db Database) Response!\nfrom\n    Get(\"/health\") =&gt; ok(\"healthy\")\n    Get(\"/users\")  =&gt; users(db)! |&gt; encode |&gt; ok\n    Post(\"/users\") =&gt; create(db, body)! |&gt; encode |&gt; created\n    _              =&gt; not_found()\n\n/// Application entry point \u2014 no verb, main is special.\nmain() Result&lt;Unit, Error&gt;!\nfrom\n    port as Port = 8080\n    db as Database = connect(\"postgres://localhost/app\")!\n    server as Server = new_server()\n    route(server, \"/\", request)\n    listen(server, port)!\n</code></pre>"},{"location":"types/","title":"Type System","text":""},{"location":"types/#refinement-types","title":"Refinement Types","text":"<p>Types carry constraints, not just shapes. The compiler rejects invalid values statically \u2014 no unnecessary runtime checks, no <code>unwrap()</code>.</p> <pre><code>type Port is Integer:[16 Unsigned] where 1 .. 65535\ntype Email is String where matches(/^[^@]+@[^@]+\\.[^@]+$/)\ntype NonEmpty&lt;T&gt; is List&lt;T&gt; where len &gt; 0\n\ntransforms head(xs NonEmpty&lt;T&gt;) T    // no Option needed, emptiness is impossible\n</code></pre> <p>The compiler rejects <code>head([])</code> statically.</p>"},{"location":"types/#algebraic-types-with-exhaustive-matching","title":"Algebraic Types with Exhaustive Matching","text":"<p>Like Rust/Haskell, but with row polymorphism. Compiler errors if you forget a variant.</p> <pre><code>type Result&lt;T, E&gt; is Ok(T) | Err(E)\ntype Shape is Circle(radius Decimal) | Rect(w Decimal, h Decimal)\n\n// compiler error if you forget a variant\ntransforms area(s Shape) Decimal\nfrom\n    match s\n        Circle(r) =&gt; pi * r * r\n        Rect(w, h) =&gt; w * h\n</code></pre>"},{"location":"types/#effect-types","title":"Effect Types","text":"<p>IO is encoded in the verb, not in annotations. The compiler knows which functions touch the world (<code>inputs</code>/<code>outputs</code>) and which are pure (<code>transforms</code>/<code>validates</code>). Pure functions get automatic memoization and parallelism.</p> <pre><code>inputs read_config(path Path) String!               // IO inherent, ! = can fail\n\ntransforms parse(s String) Result&lt;Config, Error&gt;   // pure \u2014 failure in return type\n\ntransforms rewrite(c Config) Config                // pure, infallible, parallelizable\n</code></pre>"},{"location":"types/#ownership-lite-linear-types-with-compiler-inferred-borrows","title":"Ownership Lite (Linear Types with Compiler-Inferred Borrows)","text":"<p>Linear types for resources, but without Rust's lifetime annotation burden. The compiler infers borrows or asks you. Ownership is a type modifier, consistent with mutability and other storage concerns.</p> <pre><code>inputs process(file File:[Own]) Data!\nfrom\n    content as String = read(file)\n    close(file)\n</code></pre>"},{"location":"types/#no-null","title":"No Null","text":"<p>No null \u2014 use <code>Option&lt;T&gt;</code>, enforced by the compiler.</p>"}]}