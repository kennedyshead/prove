module InventoryService
  narrative: """
  Products are added to inventory with validated stock levels.
  Orders consume stock. The system ensures stock never goes negative
  and all monetary calculations use exact decimal arithmetic.
  Orders are priced with tax and discount rules.
  """
  Http types Response Server, inputs listen

  type Port is Integer:[16 Unsigned] where 1 .. 65535

  type Quantity is Integer where self >= 0

  type Price is Decimal:[128 Scale:2] where self >= 0

  type Percentage is Decimal:[128 Scale:4] where 0 .. 1

  type Sku is String where matches(r"^[A-Z]{2,4}-[0-9]{4,8}$")

  type Email is String where matches(r"^[^@]+@[^@]+\.[^@]+$")

  type Route is Get(path String)
    | Post(path String)
    | Put(path String)
    | Delete(path String)

  type Product is
    sku Sku
    name String
    price Price
    stock Quantity

  type OrderItem is
    product Product
    quantity Integer where self > 0

  type OrderStatus is Pending
    | Confirmed
    | Shipped
    | Cancelled

  type Order is
    id Integer
    items NonEmpty<List<OrderItem>>
    status OrderStatus
    total Price

  type TaxRule is
    region String
    rate Percentage

  type Discount is FlatOff(amount Price)
    | PercentOff(rate Percentage)
    | BuyNGetFree(buy Integer where self > 0, free Integer where self > 0)

  MAX_CONNECTIONS as Integer = comptime
      match cfg.target
          embedded => 16
          _ => 1024

  DEFAULT_TAX as TaxRule = comptime
      TaxRule("SE", 0.25)

  ROUTES as List<String> = comptime
      ["/health", "/products", "/products/low-stock", "/orders"]

  invariant_network InventoryAccounting
    sum_stock(products) >= 0
    every(order, status == Confirmed)
    implies
    fulfillable(order)
    total_revenue == reduce(confirmed_orders, 0, |acc, o| acc + o.total)

validates sku(code String)
from
    matches(code, r"^[A-Z]{2,4}-[0-9]{4,8}$")

validates in_stock(product Product, requested Integer)
from
    product.stock >= requested

validates fulfillable(order Order)
from
    all(order.items, |item| in_stock(item.product, item.quantity))

validates discount_valid(discount Discount, subtotal Price)
from
    match discount
        FlatOff(amount) => amount <= subtotal
        PercentOff(rate) => rate <= 1
        BuyNGetFree(buy, _) => buy >= 1

transforms subtotal(items List<OrderItem>) Price
  ensures result >= 0
from
    reduce(items, 0, |acc, item| acc + item.product.price * item.quantity)

transforms apply_discount(discount Discount, amount Price) Price
  ensures result >= 0
  ensures result <= amount
  proof
    non_negative: FlatOff is clamped to zero , PercentOff rate is 0 .. 1 , BuyNGetFree only reduces by whole item prices
    bounded: every discount path subtracts from amount , never adds
from
    match discount
        FlatOff(off) => max(0, amount - off)
        PercentOff(rate) => amount * (1 - rate)
        BuyNGetFree(buy, free) =>
            sets as Integer = len(items) / (buy + free)
            amount - sets * cheapest_price(items)

transforms apply_tax(rule TaxRule, amount Price) Price
  ensures result >= amount
  proof
    tax_additive: rate is 0 .. 1 so multiplier ( 1 + rate ) >= 1 , therefore result >= amount
from
    amount * (1 + rule.rate)

transforms calculate_total(items List<OrderItem>, discount Discount, tax TaxRule) Price
  ensures result >= 0
  requires len(items) > 0
  proof
    subtotal: sums the items Price
    apply_discount: deduct when discount > 0
    apply_tax: adds tax when tax > 0
from
    sub as Price = subtotal(items)
    discounted as Price = apply_discount(discount, sub)
    apply_tax(tax, discounted)

transforms deduct_stock(products List<Product>, items List<OrderItem>) List<Product>
  ensures len(result) == len(products)
from
    map(products, |p| match find(items, |item| item.product.sku == p.sku)
        Some(item) => Product(p.sku, p.name, p.price, p.stock - item.quantity)
        None => p)

transforms parse_order(raw String) Result<Order, Error>
from
    decode(raw)

transforms cheapest_price(items List<OrderItem>) Price
  requires len(items) > 0
from
    reduce(items, items[0].product.price, |acc, item| min(acc, item.product.price))

transforms low_stock(products List<Product>, threshold Quantity) List<Product>
from
    filter(products, |p| p.stock <= threshold)

inputs load_config(path String) Config!
from
    raw as String = read_file(path)!
    decode(raw)!

inputs all_products(db Database) List<Product>!
from
    query(db, "SELECT * FROM products")!

inputs product_by_sku(db Database, code Sku) Product!
from
    query_one(db, f"SELECT * FROM products WHERE sku = {code}")!

inputs order_by_id(db Database, id Integer) Order!
from
    query_one(db, f"SELECT * FROM orders WHERE id = {id}")!

inputs tax_rule(db Database, region String) TaxRule!
from
    query_one(db, f"SELECT * FROM tax_rules WHERE region = {region}")!

outputs add_product(db Database, product Product)!
  ensures product_by_sku(db, product.sku) == product
  proof
    persistence: insert writes the product row , and product_by_sku queries the same table by the same SKU
from
    insert(db, "products", product)!

outputs place_order(db Database, order Order, tax TaxRule) Order!
  ensures result.status == Confirmed
  ensures result.total == calculate_total(order.items, FlatOff(0), tax)
  requires fulfillable(order)
  proof
    fulfillment: requires clause guarantees stock sufficiency before deduction , so stock never goes negative
    total_correct: calculate_total is a pure transform applied to the same items and tax rule stored in the result
    status: order is created with Confirmed status after successful insert
from
    total as Price = calculate_total(order.items, FlatOff(0), tax)
    confirmed as Order = Order(order.id, order.items, Confirmed, total)
    insert(db, "orders", confirmed)!
    products as List<Product> = all_products(db)!
    updated as List<Product> = deduct_stock(products, order.items)
    update_all(db, "products", updated)!
    confirmed

outputs cancel_order(db Database, order Order)!
  requires order.status == Pending || order.status == Confirmed
from
    cancelled as Order = Order(order.id, order.items, Cancelled, order.total)
    update(db, "orders", cancelled)!
    products as List<Product> = all_products(db)!
    restored as List<Product> = map(products, |p| match find(order.items, |item| item.product.sku == p.sku)
        Some(item) => Product(p.sku, p.name, p.price, p.stock + item.quantity)
        None => p)
    update_all(db, "products", restored)!

outputs log_request(route Route, status Integer)
from
    write(stdout, f"[{now()}] {route} -> {status}")

transforms evict(cache Cache:[Mutable]) Option<Product>
  why_not: "FIFO would evict recently restocked products under burst queries"
  why_not: "Random eviction gives no guarantees about cache hit rate"
  chosen: "LFU because inventory queries follow power-law distribution â€”
           popular products are queried far more often"
from
    least_frequent(cache)

outputs import_orders(db Database, raw String) List<Order>!
  know: len(raw) > 0
  assume: valid_json(raw)
  believe: all_skus_exist(db, extract_skus(raw))
from
    orders as List<Order> = decode(raw)!
    map(orders, |o| place_order(db, o, default_tax())!)

validates wholesale(quantity Quantity)
  near_miss: 10  => false
  near_miss: 11  => true
  near_miss: 0  => false
from
    quantity > 10

inputs request(route Route, body String, db Database, token String) Response!
from
    user as User = authenticate(token)!
    match route
        Get(/health) => ok("healthy")
        Get(/products) => all_products(db)! |> encode |> ok
        Get(/products/low-stock) => all_products(db)! |> low_stock(5) |> encode |> ok
        Post(/products) =>
            product as Product = decode(body)!
            match valid sku(product.sku)
                false => bad_request("invalid SKU format")
                true =>
                    add_product(db, product)!
                    encode(product) |> created
        Post(/orders) =>
            order as Order = parse_order(body)!
            match valid fulfillable(order)
                false => bad_request("insufficient stock")
                true =>
                    perm as Permission = authorize(user, "orders.create")
                    tax as TaxRule = tax_rule(db, "SE")!
                    place_order(db, order, tax)! |> encode |> created
        Delete(/orders) =>
            order as Order = decode(body)!
            perm as Permission = authorize(user, "orders.cancel")
            cancel_order(db, order)!
            ok("cancelled")
        _ => not_found()

main() Result<Unit, Error>!
from
    cfg as Config = load_config("inventory.yaml")!
    db as Database = connect(cfg.db_url)!
    server as Server = new_server()
    port as Port = cfg.port
    route(server, "/", |r, b| request(r, b, db, extract_token(r)))
    listen(server, port)!
