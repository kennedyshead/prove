# Prove v0.8 — Formatter Type Inference

## Goal

Make `prove format` type-aware: when a variable declaration has no
explicit type annotation and the right-hand side is a function call,
insert the function's return type as the annotation.

**Prerequisite:** v0.7 (IO, Parse, C FFI) must be complete.

---

## The Feature

### Before `prove format`

```prove
table = Table.new()
doc = Parse.toml(source)!
names = Table.keys(root)
trimmed = Text.trim(raw)
count = len(items)
```

### After `prove format`

```prove
table as Table<V> = Table.new()
doc as Result<Value, String> = Parse.toml(source)!
names as List<String> = Table.keys(root)
trimmed as String = Text.trim(raw)
count as Integer = len(items)
```

**Rule:** Only add a type annotation when `type_expr` is `None` (the
user did not write one). Never overwrite an existing annotation.

---

## Current State

The formatter (`formatter.py`) is purely syntactic. It walks the parsed
AST and emits source text — no type information, no symbol table access.

```
prove format:  lex → parse → format
prove check:   lex → parse → check → (format check)
prove build:   lex → parse → check → emit → compile
```

The checker already resolves function return types and registers them in
the symbol table. The formatter just needs access to that information.

---

## Implementation

### 1. Run checker before formatting

Update the `prove format` pipeline to optionally run the checker and
pass the resulting symbol table to the formatter. If the checker finds
errors, format without type inference (graceful degradation).

**File:** `cli.py` — `format_cmd` function

```
prove format:  lex → parse → [check] → format(symbols?)
```

The `--check` flag (dry-run) and `--stdin` mode also get this treatment.

### 2. Accept symbol table in formatter

Add an optional `symbols` parameter to `ProveFormatter`:

**File:** `formatter.py`

```python
class ProveFormatter:
    def __init__(self, symbols: SymbolTable | None = None):
        self._symbols = symbols
```

The formatter remains fully functional without symbols — it just skips
type inference for untyped variable declarations.

### 3. Infer types in `_format_var_decl`

When `vd.type_expr is None` and `self._symbols is not None`, inspect the
value expression to infer the type:

| Value expression | Lookup strategy |
|-----------------|-----------------|
| `Table.new()` | Module-qualified call: resolve `(module, verb, name, arity)` → return type |
| `len(items)` | Unqualified call: resolve `(name, arity)` → return type |
| `source!` | FailProp wrapping a call: unwrap the Result → inner type |
| Other | No inference — leave annotation empty |

**File:** `formatter.py` — new method `_infer_var_type`

### 4. Convert resolved types to type expressions

The symbol table stores resolved `Type` objects (`PrimitiveType`,
`GenericInstance`, `ListType`, etc.). The formatter needs to render
these as source-level type syntax (`String`, `Table<V>`, `List<String>`).

**File:** `formatter.py` — new method `_type_to_str`

| Resolved type | Output |
|---------------|--------|
| `PrimitiveType("String")` | `String` |
| `PrimitiveType("Integer")` | `Integer` |
| `ListType(PrimitiveType("String"))` | `List<String>` |
| `GenericInstance("Table", [TypeVariable("V")])` | `Table<V>` |
| `GenericInstance("Result", [T, E])` | `Result<T, E>` |
| `UnitType` | (skip — don't annotate Unit) |

### 5. Track current module context

For module-qualified calls like `Table.keys(root)`, the formatter
needs to know which module `Table` refers to. The existing
`SymbolTable.resolve_function(module, name, arity)` already handles
this. The formatter needs to track the current module context from
import declarations.

**File:** `formatter.py` — track imports during `_format_module_decl`

---

## Scope Boundaries

**In scope:**
- Variable declarations where RHS is a function call (direct or module-qualified)
- Variable declarations where RHS is a failable call (`expr!`)

**Out of scope (for now):**
- Literal inference (`x = 42` → `x as Integer = 42`)
- Complex expression inference (`x = a + b`)
- Lambda parameter type inference
- Narrowing generic type variables from usage context

---

## Files Changed

| File | Change |
|------|--------|
| `formatter.py` | Accept `SymbolTable`, add `_infer_var_type`, `_type_to_str` |
| `cli.py` | Run checker in `prove format` pipeline, pass symbols to formatter |
| Tests | New test cases for type inference formatting |

---

## Verification

Test with existing stdlib examples and the `read_toml` example project:

```bash
prove format examples/read_toml --check  # should pass after formatting
prove format examples/math --check
prove format examples/hello --check
```

Also verify:
- Existing type annotations are never modified
- Files with checker errors still format (without type inference)
- `prove format --stdin` works with type inference
- Round-trip: `prove format` twice produces identical output
