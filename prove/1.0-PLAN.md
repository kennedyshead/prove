# Prove v1.0 — Self-Hosting Compiler

## Goal

Rewrite the Prove compiler in Prove and compile it with the Python bootstrap
compiler. The resulting binary is a native Prove compiler that can compile
itself.

Current state: ~10,800 lines of Python across 25 modules. 458 tests passing.
Two backends (C default, ASM opt-in).

---

## Bootstrapping Strategy

```
Step 1: Python compiler compiles stdlib .prv → .c → .o
Step 2: Python compiler compiles compiler .prv → .c → .o
Step 3: Link all .o → prove binary
Step 4: New binary compiles itself (prove compiles prove)
Step 5: Diff: output of Step 3 binary vs Step 4 binary must match
```

The Python compiler remains the bootstrap. It compiles the Prove compiler
source into a native binary. That binary then compiles the same source again.
If both produce identical output, the compiler is self-hosting.

**Key constraint:** The Prove compiler written in Prove must only use language
features the Python compiler already supports. No new syntax — only new stdlib
modules (which are C-backed, like the existing ones).

---

## Part 1: Stdlib Modules

See `0.5-PLAN.md` for full details. Four modules:

| Module | Functions | Purpose |
|--------|-----------|---------|
| `InputOutput` (ext) | +14 | Channels: standard, file, dir, system, process |
| `Table` | 8 | Hash map |
| `Character` | 23 | Character/string ops + StringBuilder |
| `Parse` | 4 | Format codecs (TOML, JSON) |

**Prerequisite:** v0.3 (legacy cleanup), v0.4 (language features), and
v0.5 (stdlib) must be complete before compiler modules can be written
in Prove.

---

## Part 2: Compiler Modules in Prove

The Python compiler has 25 modules (~10,800 lines). The Prove version maps
naturally to Prove modules. Algebraic types replace `isinstance` dispatch.
Pattern matching replaces `if isinstance(node, X)` chains.

### Module Dependency Order

```
Source → Tokens → Errors → Ast → Lexer → Types → Symbols → Parser
    → Checker → Prover → CTypes → CEmitter → CCompiler → CRuntime
    → Testing → Config → Builder → Cli
```

### 2.1 `Source` — Spans and Source Files

**Python:** `source.py` (51 lines)

```prove
module Source
  narrative: "Source file locations for diagnostics."

    type Span is
      file String
      start_line Integer
      start_col Integer
      end_line Integer
      end_col Integer

    type SourceFile is
      path String
      content String
```

| Function | Signature |
|----------|-----------|
| `source_lines` | `transforms source_lines(sf SourceFile) List<String>` |
| `dummy_span` | `transforms dummy_span() Span` |

**Est.:** ~30 lines of Prove

### 2.2 `Tokens` — Token Kinds and Keywords

**Python:** `tokens.py` (188 lines) — `TokenKind` enum with 67 variants,
`KEYWORDS` dict, `Token` dataclass.

```prove
module Tokens
  narrative: "Token types and keyword tables."

type TokenKind is
    Main | From | Type | Is | As | With | Use | Where
  | Match | Comptime | Valid | Module | Domain | When
  | Transforms | Inputs | Outputs | Validates | Types_
  | Ensures | Requires | Proof
  | WhyNot | Chosen | NearMiss | Know | Assume | Believe
  | Intent | Narrative | Temporal | Satisfies | InvariantNetwork
  | IntegerLit | DecimalLit | StringLit | BooleanLit | CharLit
  | TripleStringLit | RegexLit | RawStringLit | PathLit
  | InterpStart | InterpEnd
  | Plus | Minus | Star | Slash | Percent
  | Equal | NotEqual | Less | Greater | LessEqual | GreaterEqual
  | And | Or | Bang | PipeArrow | FatArrow | DotDot | Dot
  | Assign | Arrow
  | LParen | RParen | LBracket | RBracket | Comma | Colon | Pipe
  | Newline | Indent | Dedent | DocComment
  | Identifier | TypeIdentifier | ConstantIdentifier
  | Eof

type Token is
  kind TokenKind
  value String
  span Span
```

| Function | Signature |
|----------|-----------|
| `keyword_lookup` | `transforms keyword_lookup(name String) Option<TokenKind>` |
| `is_newline_suppressed` | `validates is_newline_suppressed(kind TokenKind) Boolean` |
| `token_name` | `transforms token_name(kind TokenKind) String` |

**Est.:** ~120 lines of Prove (algebraic type is verbose but clear)

### 2.3 `Errors` — Diagnostics

**Python:** `errors.py` (154 lines)

```prove
module Errors
  narrative: "Compiler diagnostic types and rendering."

type Severity is Error_ | Warning_

type DiagnosticLabel is
  span Span
  message String

type Suggestion is
  message String

type Diagnostic is
  severity Severity
  code String
  message String
  labels List<DiagnosticLabel>
  suggestions List<Suggestion>
```

| Function | Signature |
|----------|-----------|
| `render_diagnostic` | `outputs render_diagnostic(d Diagnostic, source SourceFile)` |
| `render_all` | `outputs render_all(diags List<Diagnostic>, source SourceFile)` |
| `is_error` | `validates is_error(d Diagnostic) Boolean` |
| `has_errors` | `validates has_errors(diags List<Diagnostic>) Boolean` |

**Est.:** ~100 lines of Prove

### 2.4 `Ast` — AST Nodes

**Python:** `ast_nodes.py` (437 lines) — 40+ frozen dataclasses.

This is where Prove's algebraic types shine. The `isinstance` dispatch
throughout the Python compiler becomes `match` expressions.

```prove
module Ast
  narrative: "Abstract syntax tree nodes for parsed Prove source."

type TypeExpr is
    SimpleType(name String, span Span)
  | GenericType(name String, args List<TypeExpr>, span Span)
  | ModifiedType(name String, modifiers List<TypeModifier>, span Span)

type TypeModifier is
  name Option<String>
  value String
  span Span

type Pattern is
    VariantPattern(name String, fields List<Pattern>, span Span)
  | WildcardPattern(span Span)
  | LiteralPattern(value String, span Span)
  | BindingPattern(name String, span Span)

type Expr is
    IntegerLitE(value String, span Span)
  | DecimalLitE(value String, span Span)
  | StringLitE(value String, span Span)
  | BooleanLitE(value Boolean, span Span)
  | CharLitE(value String, span Span)
  | RegexLitE(pattern String, span Span)
  | RawStringLitE(value String, span Span)
  | PathLitE(value String, span Span)
  | TripleStringLitE(value String, span Span)
  | StringInterpE(parts List<Expr>, span Span)
  | ListLiteralE(elements List<Expr>, span Span)
  | IdentifierE(name String, span Span)
  | TypeIdentifierE(name String, span Span)
  | BinaryE(left Expr, op String, right Expr, span Span)
  | UnaryE(op String, operand Expr, span Span)
  | CallE(func Expr, args List<Expr>, span Span)
  | FieldE(obj Expr, field String, span Span)
  | PipeE(left Expr, right Expr, span Span)
  | FailPropE(expr Expr, span Span)
  | LambdaE(params List<String>, body Expr, span Span)
  | ValidE(name String, args Option<List<Expr>>, span Span)
  | MatchE(subject Option<Expr>, arms List<MatchArm>, span Span)
  | ComptimeE(body List<Stmt>, span Span)
  | IndexE(obj Expr, index Expr, span Span)

type Stmt is
    VarDeclS(name String, type_expr Option<TypeExpr>, value Expr, span Span)
  | AssignmentS(target String, value Expr, span Span)
  | ExprStmtS(expr Expr, span Span)

type MatchArm is
  pattern Pattern
  body List<Stmt>
  span Span

type Param is
  name String
  type_expr TypeExpr
  constraint Option<Expr>
  span Span

type ProofObligation is
  name String
  text String
  condition Option<Expr>
  span Span

type ProofBlock is
  obligations List<ProofObligation>
  span Span

type NearMiss is
  input Expr
  expected Expr
  span Span

type ImportItem is
  verb Option<String>
  name String
  span Span

type FieldDef is
  name String
  type_expr TypeExpr
  constraint Option<Expr>
  span Span

type Variant is
  name String
  fields List<FieldDef>
  span Span

type TypeBody is
    RefinementDef(base_type TypeExpr, constraint Expr, span Span)
  | AlgebraicDef(variants List<Variant>, span Span)
  | RecordDef(fields List<FieldDef>, span Span)

type FunctionDef is
  verb String
  name String
  params List<Param>
  return_type Option<TypeExpr>
  can_fail Boolean
  ensures List<Expr>
  requires List<Expr>
  proof Option<ProofBlock>
  why_not List<String>
  chosen Option<String>
  near_misses List<NearMiss>
  know List<Expr>
  assume List<Expr>
  believe List<Expr>
  intent Option<String>
  satisfies List<String>
  body List<BodyItem>
  doc_comment Option<String>
  span Span

type MainDef is
  return_type Option<TypeExpr>
  can_fail Boolean
  body List<BodyItem>
  doc_comment Option<String>
  span Span

type TypeDef is
  name String
  type_params List<String>
  body TypeBody
  span Span

type ConstantDef is
  name String
  type_expr Option<TypeExpr>
  value Expr
  span Span

type ImportDecl is
  module_ String
  items List<ImportItem>
  span Span

type InvariantNetwork is
  name String
  constraints List<Expr>
  span Span

type ModuleDecl is
  name String
  narrative Option<String>
  temporal Option<List<String>>
  imports List<ImportDecl>
  types List<TypeDef>
  constants List<ConstantDef>
  invariants List<InvariantNetwork>
  body List<Declaration>
  span Span

type Declaration is
    FuncDecl(def_ FunctionDef)
  | MainDecl(def_ MainDef)
  | ModDecl(def_ ModuleDecl)

type BodyItem is
    StmtItem(stmt Stmt)
  | MatchItem(expr MatchExpr)

type Module_ is
  declarations List<Declaration>
  span Span
```

**Est.:** ~250 lines of Prove (mostly type definitions)

### 2.5 `ResolvedTypes` — Type System

**Python:** `types_.py` (185 lines)

```prove
module ResolvedTypes
  narrative: "Resolved type representations after checking."

type Type is
    Primitive(name String, modifiers List<String>)
  | UnitT
  | RecordT(name String, fields Map<Type>)
  | AlgebraicT(name String, variants List<VariantInfo>)
  | RefinementT(name String, base Type)
  | GenericInstanceT(base_name String, args List<Type>)
  | TypeVarT(name String)
  | FunctionT(param_types List<Type>, return_type Type)
  | ListT(element Type)
  | ErrorT

type VariantInfo is
  name String
  fields Map<Type>
```

| Function | Signature |
|----------|-----------|
| `type_name` | `transforms type_name(ty Type) String` |
| `types_compatible` | `validates types_compatible(expected Type, actual Type) Boolean` |
| `is_pointer_type` | `validates is_pointer_type(ty Type) Boolean` |

Constants: `INTEGER`, `DECIMAL`, `FLOAT`, `BOOLEAN`, `STRING`, `CHARACTER`,
`BYTE`, `UNIT_` — each a `Type` value.

**Est.:** ~120 lines of Prove

### 2.6 `Symbols` — Symbol Table

**Python:** `symbols.py` (159 lines)

```prove
module Symbols
  narrative: "Lexical scoping and function registry."

type SymbolKind is Variable | Parameter | Constant_ | Function_

type Symbol is
  name String
  kind SymbolKind
  type_ Type
  used Boolean
  span Span

type FunctionSignature is
  verb String
  name String
  params List<Param>
  return_type Type
  can_fail Boolean

type Scope is
  symbols Map<Symbol>
  parent Option<Scope>

type SymbolTable is
  scopes List<Scope>
  functions Map<FunctionSignature>
  types Map<Type>
```

| Function | Signature |
|----------|-----------|
| `st_new` | `transforms st_new() SymbolTable` |
| `st_push_scope` | `transforms st_push_scope(st SymbolTable) SymbolTable` |
| `st_pop_scope` | `transforms st_pop_scope(st SymbolTable) SymbolTable` |
| `st_define` | `transforms st_define(st SymbolTable, sym Symbol) SymbolTable` |
| `st_lookup` | `transforms st_lookup(st SymbolTable, name String) Option<Symbol>` |
| `st_register_function` | `transforms st_register_function(st SymbolTable, sig FunctionSignature) SymbolTable` |
| `st_lookup_function` | `transforms st_lookup_function(st SymbolTable, name String) Option<FunctionSignature>` |
| `st_register_type` | `transforms st_register_type(st SymbolTable, name String, ty Type) SymbolTable` |
| `st_lookup_type` | `transforms st_lookup_type(st SymbolTable, name String) Option<Type>` |

**Est.:** ~120 lines of Prove

### 2.7 `Lexer` — Tokenization

**Python:** `lexer.py` (656 lines) — the most algorithmically complex module.

The lexer needs character-by-character traversal, indent/dedent tracking,
string interpolation nesting, and regex-vs-division disambiguation.

| Function | Signature |
|----------|-----------|
| `lex` | `transforms lex(source SourceFile) Result<List<Token>, List<Diagnostic>>` |

Internal helpers (private to module):
- `scan_token` — main dispatch on current character
- `scan_identifier` — read word, check keyword table
- `scan_number` — integer or decimal literal
- `scan_string` — regular, triple-quoted, raw, interpolated
- `scan_regex` — regex literal after disambiguation
- `scan_path` — path literal (`p"..."`)
- `emit_indent_dedent` — compare leading spaces to indent stack
- `skip_comment` — single-line `//` comments
- `scan_doc_comment` — `///` doc comments

**Est.:** ~500 lines of Prove (similar to Python, character ops via `Character`)

### 2.8 `Parser` — Parsing

**Python:** `parser.py` (1604 lines) — Pratt expression parser + recursive
descent for declarations.

| Function | Signature |
|----------|-----------|
| `parse` | `transforms parse(tokens List<Token>) Result<Module_, List<Diagnostic>>` |

The Pratt parser maps cleanly to Prove. The binding power table becomes a
`match` on `TokenKind`. Recursive descent for declarations uses the same
pattern: peek at current token, dispatch to specific parse function.

Key internal functions:
- `parse_expression(min_bp)` — Pratt core
- `parse_prefix` — unary, literals, identifiers, parenthesized
- `parse_infix` — binary ops, field access, call, index, pipe
- `parse_declaration` — dispatch on verb keyword
- `parse_function` — verb, name, params, return type, contracts, body
- `parse_type_def` — `type X is ...`
- `parse_module_decl` — `module X` with narrative, imports, body
- `parse_match` — `match` expression with arms
- `parse_proof` — `proof` block with obligations

**Est.:** ~1,200 lines of Prove

### 2.9 `Checker` — Semantic Analysis

**Python:** `checker.py` (1266 lines) — two-pass analyzer.

| Function | Signature |
|----------|-----------|
| `check` | `transforms check(module_ Module_, st SymbolTable) Result<SymbolTable, List<Diagnostic>>` |

Pass 1: Register all top-level declarations (types, functions, constants,
imports) into the symbol table. This allows mutual recursion.

Pass 2: Check each declaration body:
- Type inference via `match` on `Expr` variants
- Verb enforcement (pure verbs cannot call IO functions)
- Match exhaustiveness
- Unused variable detection
- Contract type checking (ensures/requires must be Boolean)

The Python `isinstance` dispatch becomes `match` on algebraic variants:

```
// Python:
if isinstance(expr, BinaryExpr):
    left_ty = self._infer(expr.left)
    ...

// Prove:
match expr
  BinaryE(left, op, right, span) =>
    left_ty as Type = infer(left, st)
    ...
```

**Est.:** ~900 lines of Prove

### 2.10 `Prover` — Proof Verification

**Python:** `prover.py` (149 lines)

| Function | Signature |
|----------|-----------|
| `verify_proof` | `transforms verify_proof(fd FunctionDef) List<Diagnostic>` |

Checks: E390, E391, E392, E393, W321, W322, W324.

**Est.:** ~120 lines of Prove

### 2.11 `CTypes` — C Type Mapping

**Python:** `c_types.py` (168 lines)

```prove
module CTypes
  narrative: "Map resolved types to C type representations."

type CType is
  decl String
  is_pointer Boolean
  header Option<String>
```

| Function | Signature |
|----------|-----------|
| `map_type` | `transforms map_type(ty Type) CType` |
| `mangle_name` | `transforms mangle_name(verb String, name String, params List<Type>) String` |
| `mangle_type_name` | `transforms mangle_type_name(name String) String` |

**Est.:** ~130 lines of Prove

### 2.12 `CEmitter` — C Code Generation

**Python:** `c_emitter.py` (1321 lines) — the largest module.

| Function | Signature |
|----------|-----------|
| `emit_c` | `transforms emit_c(module_ Module_, st SymbolTable) String` |

This is a large AST walker. Every `isinstance` check becomes a `match`
arm. String building uses `StringBuilder` from `Character` module.

Key sections:
- Type definitions → C structs/unions/typedefs
- Function definitions → C functions with mangled names
- Expression emission → recursive match on all Expr variants
- Lambda hoisting → collect during emission, insert at top
- Builtin dispatch → `println`, `len`, `to_string`, etc.
- Proof branching → `when` conditions become if/else-if chains
- Retain/release → reference counting at scope boundaries

**Est.:** ~1,000 lines of Prove

### 2.13 `CCompiler` — Invoking gcc

**Python:** `c_compiler.py` (84 lines)

| Function | Signature |
|----------|-----------|
| `find_c_compiler` | `inputs find_c_compiler() String!` |
| `compile_c` | `inputs compile_c(source_path String, output_path String, compiler String, extra_sources List<String>) Result<Unit, String>` |

Uses `InputOutput.system` and `InputOutput.file`.

**Est.:** ~60 lines of Prove

### 2.14 `CRuntime` — Runtime File Copying

**Python:** `c_runtime.py` (44 lines)

| Function | Signature |
|----------|-----------|
| `copy_runtime` | `outputs copy_runtime(build_dir String)!` |

Copies bundled C runtime `.c`/`.h` files to the build directory. In the
self-hosted compiler, these files are embedded as string constants or
read from a known install path.

**Est.:** ~40 lines of Prove

### 2.15 `Testing` — Contract Test Generation

**Python:** `testing.py` (674 lines)

| Function | Signature |
|----------|-----------|
| `generate_tests` | `transforms generate_tests(module_ Module_, st SymbolTable, c_source String) String` |

Generates a standalone C test program from `ensures`, `near_miss`, and
`believe` annotations. Property-based testing with random inputs.

**Est.:** ~500 lines of Prove

### 2.16 `Config` — Project Configuration

**Python:** `config.py` (92 lines)

```prove
module Config
  narrative: "Load and represent prove.toml configuration."

type PackageConfig is
  name String
  version String

type BuildConfig is
  entry String
  output String

type TestConfig is
  rounds Integer

type StyleConfig is
  line_length Integer

type ProveConfig is
  package_ PackageConfig
  build BuildConfig
  test_ TestConfig
  style StyleConfig
```

| Function | Signature |
|----------|-----------|
| `find_config` | `inputs find_config(start String) Option<String>` |
| `load_config` | `inputs load_config(path String) ProveConfig!` |
| `default_config` | `transforms default_config() ProveConfig` |

Uses `Parse` and `InputOutput` modules.

**Est.:** ~80 lines of Prove

### 2.17 `StdlibLoader` — Stdlib Loading

**Python:** `stdlib_loader.py` (275 lines)

| Function | Signature |
|----------|-----------|
| `load_stdlib` | `inputs load_stdlib(name String) List<FunctionSignature>!` |
| `available_modules` | `transforms available_modules() List<String>` |

In the self-hosted compiler, stdlib `.prv` files are either embedded as
string constants or read from the install directory.

**Est.:** ~200 lines of Prove

### 2.18 `Builder` — Build Pipeline

**Python:** `builder.py` (208 lines)

```prove
module Builder
  narrative: "Orchestrate the full compilation pipeline."

type BuildResult is
  ok Boolean
  binary Option<String>
  diagnostics List<Diagnostic>
  c_error Option<String>
```

| Function | Signature |
|----------|-----------|
| `build_project` | `inputs build_project(project_dir String, config ProveConfig) BuildResult` |

Pipeline: find sources → lex → parse → check → emit C → copy runtime →
compile C → binary.

**Est.:** ~150 lines of Prove

### 2.19 `Cli` — Command Line Interface

**Python:** `cli.py` (592 lines) — uses Click framework.

The self-hosted CLI parses `InputOutput.process()` directly (no Click dependency).

| Function | Signature |
|----------|-----------|
| `main` | `main() Result<Unit, Error>!` |
| `cmd_build` | `inputs cmd_build(path String)!` |
| `cmd_check` | `inputs cmd_check(path String)!` |
| `cmd_test` | `inputs cmd_test(path String)!` |
| `cmd_new` | `outputs cmd_new(name String)!` |

Argument parsing is simple: `prove build [path]`, `prove check [path]`,
`prove test [path]`, `prove new <name>`.

**Est.:** ~300 lines of Prove

### Compiler Module Summary

| Module | Python lines | Prove est. | Key stdlib deps |
|--------|-------------|------------|-----------------|
| Source | 51 | 30 | — |
| Tokens | 188 | 120 | Map |
| Errors | 154 | 100 | Character, InputOutput |
| Ast | 437 | 250 | — |
| Lexer | 656 | 500 | Character |
| ResolvedTypes | 185 | 120 | Map |
| Symbols | 159 | 120 | Map |
| Parser | 1,604 | 1,200 | — |
| Checker | 1,266 | 900 | Table |
| Prover | 149 | 120 | Table |
| CTypes | 168 | 130 | Character |
| CEmitter | 1,321 | 1,000 | Character |
| CCompiler | 84 | 60 | InputOutput, Character |
| CRuntime | 44 | 40 | InputOutput |
| Testing | 674 | 500 | Character |
| Config | 92 | 80 | Parse, InputOutput |
| StdlibLoader | 275 | 200 | InputOutput, Character |
| Builder | 208 | 150 | InputOutput, Character |
| Cli | 592 | 300 | InputOutput |
| **Total** | **~10,800** | **~5,920** | |

The Prove version is estimated at ~55% of the Python line count. Algebraic
types eliminate boilerplate (no `@dataclass(frozen=True)`, no `__init__`,
no type imports). Pattern matching replaces `isinstance` chains.

---

## Part 3: Implementation Phases

### Phase 1: Core Stdlib (C-backed)

Completed in v0.5 (see `0.5-PLAN.md`).

### Phase 2: Foundation Modules (in Prove)

Write the compiler's data structure modules in Prove. These have no
circular dependencies and can be tested independently.

| Module | Depends on |
|--------|------------|
| `Source` | — |
| `Tokens` | Source, Map |
| `Errors` | Source, Character, InputOutput |
| `Ast` | Source, Tokens |
| `ResolvedTypes` | Map |

**Verification:** Python compiler builds each module. Write test programs
that construct AST nodes, tokens, and types.

### Phase 3: Front End (in Prove)

| Module | Depends on |
|--------|------------|
| `Lexer` | Source, Tokens, Errors, Character |
| `Parser` | Tokens, Ast, Errors |
| `Symbols` | Ast, ResolvedTypes, Map |

**Verification:** Write a test program that lexes and parses a `.prv` file,
prints the token count and declaration count. Compare with Python compiler
output.

### Phase 4: Middle End (in Prove)

| Module | Depends on |
|--------|------------|
| `Checker` | Ast, ResolvedTypes, Symbols, Errors, Table |
| `Prover` | Ast, Errors, Table |

**Verification:** Write a test program that checks a `.prv` file and reports
diagnostics. Compare with Python compiler output.

### Phase 5: Back End (in Prove)

| Module | Depends on |
|--------|------------|
| `CTypes` | ResolvedTypes, Character |
| `CEmitter` | Ast, ResolvedTypes, Symbols, CTypes, Character |
| `CCompiler` | InputOutput, Character |
| `CRuntime` | InputOutput |
| `Testing` | Ast, ResolvedTypes, Symbols, CTypes, Character |

**Verification:** Write a test program that compiles a `.prv` file to C,
then diff the C output against the Python compiler's output. They should
be identical.

### Phase 6: Pipeline (in Prove)

| Module | Depends on |
|--------|------------|
| `Config` | Parse, InputOutput |
| `StdlibLoader` | InputOutput, Character, Ast, Symbols |
| `Builder` | all above |
| `Cli` | Builder, InputOutput |

**Verification:** The compiled binary can `prove build examples/hello` and
produce a working `hello` binary. Compare output with Python-compiled
version.

### Phase 7: Self-Hosting

1. Compile all compiler `.prv` modules with Python compiler → binary A
2. Use binary A to compile all compiler `.prv` modules → binary B
3. Use binary B to compile all compiler `.prv` modules → binary C
4. Verify: binary B and binary C produce identical output
5. Binary B is the self-hosted compiler

### Phase 8: Cleanup

- Remove Python compiler dependency from build (keep as reference)
- Add `prove self-test` command that runs the bootstrap verification
- Update documentation
- Tag v1.0.0

---

## Part 4: What Stays in Python

Some features are not needed for self-hosting and remain Python-only
until later:

| Feature | Python module | Reason to defer |
|---------|--------------|-----------------|
| LSP server | `lsp.py` | Needs `pygls`, not critical path |
| Formatter | `formatter.py` | Nice-to-have, not needed for compilation |
| Project scaffolding | `project.py` | Simple, low priority |
| ASM backend | `asm_*.py` | C backend is sufficient for self-hosting |

These can be ported after v1.0 when the compiler is stable.

---

## Part 5: Language Features Required

The self-hosted compiler uses these Prove features. All must work
correctly in the Python bootstrap compiler before Phase 2 begins.

| Feature | Used for | Status |
|---------|----------|--------|
| Algebraic types | AST nodes, Token kinds, Types | Working |
| Record types | Span, Token, Diagnostic, Config | Working |
| Pattern matching | All dispatch (replaces isinstance) | Working |
| Generic types | `List<T>`, `Option<T>`, `Result<T,E>`, `Map<V>` | Working |
| String interpolation | Error messages, C code emission | Working |
| Lambdas | HOF callbacks (map, filter, reduce) | Working |
| Pipe operator | Builder pipeline | Working |
| Fail propagation | File I/O, process calls | Working |
| `from` body blocks | All functions | Working |
| `match` with binding | Extracting variant fields | Working |
| Nested match | Complex dispatch | Working |
| Local `as` bindings | Intermediate values | Working |
| `Option` / `Result` | Nullable returns, error handling | Working |
| Module imports | `Module verb name, ...` in module header | Working |
| `Module.function()` calls | Namespaced stdlib access, requires explicit import — unimported functions are errors | v0.4 |
| Pure verbs | `reads`, `creates`, `saves` — standalone verbs in the pure family | v0.4 |
| `type X is binary` | C-backed types with no Prove-visible fields | v0.4 |
| `comptime` blocks | Embedded constants | Working |
| Proof blocks | Contract verification in compiler funcs | Optional |
| `when` conditions | Proof branching | Working |

---

## Risk Assessment

| Risk | Mitigation |
|------|------------|
| Bootstrap compiler bugs | Extensive test suite (458+ tests), fix bugs as found during self-hosting |
| Missing stdlib function | Add to C runtime as needed; stdlib is extensible |
| Performance regression | C backend emits reasonable code; optimize later |
| Circular module deps | Dependency graph is acyclic by design |
| Large compilation units | Each module compiles independently |
| String-heavy code gen | StringBuilder prevents O(n^2) concat |

---

## Success Criteria

1. `prove build src/` produces a native binary (the compiler)
2. That binary can compile itself: `./prove build src/` → identical binary
3. All existing examples compile and run correctly
4. `prove test` passes all contract tests
5. Error messages match Python compiler output
6. Build time < 10 seconds on modern hardware
