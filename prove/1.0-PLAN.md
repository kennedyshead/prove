# Prove v1.0 — Self-Hosting Compiler

## Goal

Rewrite the Prove compiler in Prove and compile it with the Python bootstrap
compiler. The resulting binary is a native Prove compiler that can compile
itself.

Current state: ~10,800 lines of Python across 25 modules. 458 tests passing.
Two backends (C default, ASM opt-in).

---

## Bootstrapping Strategy

```
Step 1: Python compiler compiles stdlib .prv → .c → .o
Step 2: Python compiler compiles compiler .prv → .c → .o
Step 3: Link all .o → prove binary
Step 4: New binary compiles itself (prove compiles prove)
Step 5: Diff: output of Step 3 binary vs Step 4 binary must match
```

The Python compiler remains the bootstrap. It compiles the Prove compiler
source into a native binary. That binary then compiles the same source again.
If both produce identical output, the compiler is self-hosting.

**Key constraint:** The Prove compiler written in Prove must only use language
features the Python compiler already supports. No new syntax — only new stdlib
modules (which are C-backed, like the existing ones).

---

## Part 1: Stdlib Modules

These are the modules the compiler needs. Each is a `.prv` file declaring
types and function signatures, backed by a C implementation that the Python
compiler links in.

### 1.1 `Sys` — Process and Environment

Needed for: running gcc/as/ld, reading CLI args, exit codes, env vars.

```
module Sys
  narrative: "Process execution, arguments, and environment."

type ExitCode is Integer where 0 .. 255

type ProcessResult is
  exit_code ExitCode
  stdout String
  stderr String
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `run` | `inputs run(command String, args List<String>) ProcessResult!` | `popen`/`fork+exec+waitpid` |
| `exit` | `outputs exit(code ExitCode)` | `exit()` |
| `args` | `inputs args() List<String>` | Read from `argc`/`argv` stored at startup |
| `env` | `inputs env(name String) Option<String>` | `getenv()` |
| `cwd` | `inputs cwd() String!` | `getcwd()` |

**C file:** `prove_sys.c` (~120 lines)

### 1.2 `Fs` — File System

Needed for: reading source files, writing C/ASM output, copying runtime
files, finding prove.toml, directory traversal.

```
module Fs
  narrative: "File reading, writing, and path operations."

type Path is String

type DirEntry is
  name String
  path Path
  is_dir Boolean
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `read_file` | `inputs read_file(path Path) String!` | `fopen`+`fread` |
| `write_file` | `outputs write_file(path Path, content String)!` | `fopen`+`fwrite` |
| `file_exists` | `inputs file_exists(path Path) Boolean` | `access()` |
| `dir_exists` | `inputs dir_exists(path Path) Boolean` | `stat()` |
| `list_dir` | `inputs list_dir(path Path) List<DirEntry>!` | `opendir`+`readdir` |
| `mkdir` | `outputs mkdir(path Path)!` | `mkdir()` |
| `copy_file` | `outputs copy_file(src Path, dst Path)!` | `fopen`+`fread`+`fwrite` |
| `join_path` | `transforms join_path(base Path, child String) Path` | String concat with `/` |
| `parent` | `transforms parent(path Path) Path` | Truncate at last `/` |
| `file_name` | `transforms file_name(path Path) String` | After last `/` |
| `extension` | `transforms extension(path Path) String` | After last `.` |
| `stem` | `transforms stem(path Path) String` | Filename without extension |
| `absolute` | `inputs absolute(path Path) Path!` | `realpath()` |
| `walk` | `inputs walk(path Path) List<DirEntry>!` | Recursive `list_dir` |
| `which` | `inputs which(name String) Option<Path>` | Search `PATH` entries |
| `temp_dir` | `inputs temp_dir() Path` | `mkdtemp()` or `/tmp` |

**C file:** `prove_fs.c` (~200 lines)

### 1.3 `Map` — Hash Map

Needed for: symbol tables, keyword lookup, type registries, seen-sets,
builtin dispatch tables. The Python compiler uses `dict` everywhere.

```
module Map
  narrative: "Hash map from String keys to values."

type Map<V> is opaque
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `map_new` | `transforms map_new() Map<V>` | Allocate hash table |
| `map_set` | `transforms map_set(m Map<V>, key String, value V) Map<V>` | Insert/update |
| `map_get` | `transforms map_get(m Map<V>, key String) Option<V>` | Lookup |
| `map_has` | `validates map_has(m Map<V>, key String) Boolean` | Key exists check |
| `map_remove` | `transforms map_remove(m Map<V>, key String) Map<V>` | Delete key |
| `map_keys` | `transforms map_keys(m Map<V>) List<String>` | All keys |
| `map_values` | `transforms map_values(m Map<V>) List<V>` | All values |
| `map_len` | `transforms map_len(m Map<V>) Integer` | Entry count |

**C file:** `prove_map.c` (~250 lines) — open-addressing hash table with
`prove_string_hash()` and `prove_string_eq()` for keys.

### 1.4 `Set` — Hash Set

Needed for: tracking seen names (obligation uniqueness, unused vars),
IO function name sets, concept sets for proof reference checks.

```
module Set
  narrative: "Hash set of strings."

type Set is opaque
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `set_new` | `transforms set_new() Set` | Allocate |
| `set_add` | `transforms set_add(s Set, value String) Set` | Insert |
| `set_has` | `validates set_has(s Set, value String) Boolean` | Membership |
| `set_remove` | `transforms set_remove(s Set, value String) Set` | Delete |
| `set_len` | `transforms set_len(s Set) Integer` | Size |
| `set_to_list` | `transforms set_to_list(s Set) List<String>` | Convert to list |

**C file:** `prove_set.c` (~100 lines) — thin wrapper around Map with
unit values.

### 1.5 `Chars` — Character Operations

Needed for: lexer (classifying characters, building tokens), string
manipulation throughout the compiler.

```
module Chars
  narrative: "Character classification and string building."

type StringBuilder is opaque
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `is_alpha` | `validates is_alpha(c Character) Boolean` | `isalpha()` |
| `is_digit` | `validates is_digit(c Character) Boolean` | `isdigit()` |
| `is_alnum` | `validates is_alnum(c Character) Boolean` | `isalnum()` |
| `is_upper` | `validates is_upper(c Character) Boolean` | `isupper()` |
| `is_lower` | `validates is_lower(c Character) Boolean` | `islower()` |
| `is_space` | `validates is_space(c Character) Boolean` | `isspace()` |
| `char_at` | `transforms char_at(s String, i Integer) Character` | Index into string |
| `substring` | `transforms substring(s String, start Integer, end Integer) String` | Slice |
| `starts_with` | `validates starts_with(s String, prefix String) Boolean` | `strncmp` |
| `ends_with` | `validates ends_with(s String, suffix String) Boolean` | Compare tail |
| `contains` | `validates contains(s String, sub String) Boolean` | `strstr` |
| `index_of` | `transforms index_of(s String, sub String) Option<Integer>` | `strstr` offset |
| `split` | `transforms split(s String, sep String) List<String>` | Split by separator |
| `join` | `transforms join(parts List<String>, sep String) String` | Join with separator |
| `trim` | `transforms trim(s String) String` | Strip whitespace |
| `to_lower` | `transforms to_lower(s String) String` | Lowercase copy |
| `to_upper` | `transforms to_upper(s String) String` | Uppercase copy |
| `replace` | `transforms replace(s String, old String, new String) String` | Replace all occurrences |
| `sb_new` | `transforms sb_new() StringBuilder` | Allocate growable buffer |
| `sb_write` | `transforms sb_write(sb StringBuilder, s String) StringBuilder` | Append string |
| `sb_write_char` | `transforms sb_write_char(sb StringBuilder, c Character) StringBuilder` | Append char |
| `sb_build` | `transforms sb_build(sb StringBuilder) String` | Finalize to String |
| `sb_len` | `transforms sb_len(sb StringBuilder) Integer` | Current length |
| `repeat` | `transforms repeat(s String, n Integer) String` | Repeat n times |

**C file:** `prove_chars.c` (~200 lines)

### 1.6 `Toml` — TOML Parser

Needed for: reading `prove.toml` project configuration.

```
module Toml
  narrative: "Minimal TOML parser for prove.toml files."

type TomlValue is
    TString(value String)
  | TInteger(value Integer)
  | TBoolean(value Boolean)
  | TTable(entries Map<TomlValue>)
  | TArray(items List<TomlValue>)
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `parse_toml` | `transforms parse_toml(source String) Result<TomlValue, String>` | Hand-written parser in C |
| `toml_get` | `transforms toml_get(table TomlValue, key String) Option<TomlValue>` | Table lookup |
| `toml_string` | `transforms toml_string(v TomlValue) Option<String>` | Extract string |
| `toml_integer` | `transforms toml_integer(v TomlValue) Option<Integer>` | Extract integer |
| `toml_boolean` | `transforms toml_boolean(v TomlValue) Option<Boolean>` | Extract boolean |

**C file:** `prove_toml.c` (~300 lines) — minimal TOML parser, enough for
`prove.toml` (tables, strings, integers, booleans, arrays).

### 1.7 `Sort` — Sorting

Needed for: sorted diagnostics, sorted symbol lists for "did you mean?"
suggestions, deterministic output.

| Function | Signature | C backing |
|----------|-----------|-----------|
| `sort_strings` | `transforms sort_strings(items List<String>) List<String>` | `qsort` with `strcmp` |
| `sort_by` | `transforms sort_by(items List<V>, key fn(V) Integer) List<V>` | `qsort` with key fn |

**C file:** `prove_sort.c` (~50 lines)

### Stdlib Summary

| Module | Functions | C lines (est.) | Purpose |
|--------|-----------|----------------|---------|
| `Sys` | 5 | 120 | Process execution, env |
| `Fs` | 16 | 200 | File I/O, paths |
| `Map` | 8 | 250 | Hash map |
| `Set` | 6 | 100 | Hash set |
| `Chars` | 23 | 200 | Character/string ops |
| `Toml` | 5 | 300 | TOML parsing |
| `Sort` | 2 | 50 | Sorting |
| **Total** | **65** | **~1,220** | |

Plus existing stdlib: `Io` (3), `StringUtils` (3), `ListUtils` (1),
`Json` (5), `Regex` (1), `Http` (6).

---

## Part 2: Compiler Modules in Prove

The Python compiler has 25 modules (~10,800 lines). The Prove version maps
naturally to Prove modules. Algebraic types replace `isinstance` dispatch.
Pattern matching replaces `if isinstance(node, X)` chains.

### Module Dependency Order

```
Source → Tokens → Errors → Ast → Lexer → Types → Symbols → Parser
    → Checker → Prover → CTypes → CEmitter → CCompiler → CRuntime
    → Testing → Config → Builder → Cli
```

### 2.1 `Source` — Spans and Source Files

**Python:** `source.py` (51 lines)

```
module Source
  narrative: "Source file locations for diagnostics."

type Span is
  file String
  start_line Integer
  start_col Integer
  end_line Integer
  end_col Integer

type SourceFile is
  path String
  content String
```

| Function | Signature |
|----------|-----------|
| `source_lines` | `transforms source_lines(sf SourceFile) List<String>` |
| `dummy_span` | `transforms dummy_span() Span` |

**Est.:** ~30 lines of Prove

### 2.2 `Tokens` — Token Kinds and Keywords

**Python:** `tokens.py` (188 lines) — `TokenKind` enum with 67 variants,
`KEYWORDS` dict, `Token` dataclass.

```
module Tokens
  narrative: "Token types and keyword tables."

type TokenKind is
    Main | From | Type | Is | As | With | Use | Where
  | Match | Comptime | Valid | Module | Domain | When
  | Transforms | Inputs | Outputs | Validates | Types_
  | Ensures | Requires | Proof
  | WhyNot | Chosen | NearMiss | Know | Assume | Believe
  | Intent | Narrative | Temporal | Satisfies | InvariantNetwork
  | IntegerLit | DecimalLit | StringLit | BooleanLit | CharLit
  | TripleStringLit | RegexLit | RawStringLit | PathLit
  | InterpStart | InterpEnd
  | Plus | Minus | Star | Slash | Percent
  | Equal | NotEqual | Less | Greater | LessEqual | GreaterEqual
  | And | Or | Bang | PipeArrow | FatArrow | DotDot | Dot
  | Assign | Arrow
  | LParen | RParen | LBracket | RBracket | Comma | Colon | Pipe
  | Newline | Indent | Dedent | DocComment
  | Identifier | TypeIdentifier | ConstantIdentifier
  | Eof

type Token is
  kind TokenKind
  value String
  span Span
```

| Function | Signature |
|----------|-----------|
| `keyword_lookup` | `transforms keyword_lookup(name String) Option<TokenKind>` |
| `is_newline_suppressed` | `validates is_newline_suppressed(kind TokenKind) Boolean` |
| `token_name` | `transforms token_name(kind TokenKind) String` |

**Est.:** ~120 lines of Prove (algebraic type is verbose but clear)

### 2.3 `Errors` — Diagnostics

**Python:** `errors.py` (154 lines)

```
module Errors
  narrative: "Compiler diagnostic types and rendering."

type Severity is Error_ | Warning_

type DiagnosticLabel is
  span Span
  message String

type Suggestion is
  message String

type Diagnostic is
  severity Severity
  code String
  message String
  labels List<DiagnosticLabel>
  suggestions List<Suggestion>
```

| Function | Signature |
|----------|-----------|
| `render_diagnostic` | `outputs render_diagnostic(d Diagnostic, source SourceFile)` |
| `render_all` | `outputs render_all(diags List<Diagnostic>, source SourceFile)` |
| `is_error` | `validates is_error(d Diagnostic) Boolean` |
| `has_errors` | `validates has_errors(diags List<Diagnostic>) Boolean` |

**Est.:** ~100 lines of Prove

### 2.4 `Ast` — AST Nodes

**Python:** `ast_nodes.py` (437 lines) — 40+ frozen dataclasses.

This is where Prove's algebraic types shine. The `isinstance` dispatch
throughout the Python compiler becomes `match` expressions.

```
module Ast
  narrative: "Abstract syntax tree nodes for parsed Prove source."

type TypeExpr is
    SimpleType(name String, span Span)
  | GenericType(name String, args List<TypeExpr>, span Span)
  | ModifiedType(name String, modifiers List<TypeModifier>, span Span)

type TypeModifier is
  name Option<String>
  value String
  span Span

type Pattern is
    VariantPattern(name String, fields List<Pattern>, span Span)
  | WildcardPattern(span Span)
  | LiteralPattern(value String, span Span)
  | BindingPattern(name String, span Span)

type Expr is
    IntegerLitE(value String, span Span)
  | DecimalLitE(value String, span Span)
  | StringLitE(value String, span Span)
  | BooleanLitE(value Boolean, span Span)
  | CharLitE(value String, span Span)
  | RegexLitE(pattern String, span Span)
  | RawStringLitE(value String, span Span)
  | PathLitE(value String, span Span)
  | TripleStringLitE(value String, span Span)
  | StringInterpE(parts List<Expr>, span Span)
  | ListLiteralE(elements List<Expr>, span Span)
  | IdentifierE(name String, span Span)
  | TypeIdentifierE(name String, span Span)
  | BinaryE(left Expr, op String, right Expr, span Span)
  | UnaryE(op String, operand Expr, span Span)
  | CallE(func Expr, args List<Expr>, span Span)
  | FieldE(obj Expr, field String, span Span)
  | PipeE(left Expr, right Expr, span Span)
  | FailPropE(expr Expr, span Span)
  | LambdaE(params List<String>, body Expr, span Span)
  | ValidE(name String, args Option<List<Expr>>, span Span)
  | MatchE(subject Option<Expr>, arms List<MatchArm>, span Span)
  | ComptimeE(body List<Stmt>, span Span)
  | IndexE(obj Expr, index Expr, span Span)

type Stmt is
    VarDeclS(name String, type_expr Option<TypeExpr>, value Expr, span Span)
  | AssignmentS(target String, value Expr, span Span)
  | ExprStmtS(expr Expr, span Span)

type MatchArm is
  pattern Pattern
  body List<Stmt>
  span Span

type Param is
  name String
  type_expr TypeExpr
  constraint Option<Expr>
  span Span

type ProofObligation is
  name String
  text String
  condition Option<Expr>
  span Span

type ProofBlock is
  obligations List<ProofObligation>
  span Span

type NearMiss is
  input Expr
  expected Expr
  span Span

type ImportItem is
  verb Option<String>
  name String
  span Span

type FieldDef is
  name String
  type_expr TypeExpr
  constraint Option<Expr>
  span Span

type Variant is
  name String
  fields List<FieldDef>
  span Span

type TypeBody is
    RefinementDef(base_type TypeExpr, constraint Expr, span Span)
  | AlgebraicDef(variants List<Variant>, span Span)
  | RecordDef(fields List<FieldDef>, span Span)

type FunctionDef is
  verb String
  name String
  params List<Param>
  return_type Option<TypeExpr>
  can_fail Boolean
  ensures List<Expr>
  requires List<Expr>
  proof Option<ProofBlock>
  why_not List<String>
  chosen Option<String>
  near_misses List<NearMiss>
  know List<Expr>
  assume List<Expr>
  believe List<Expr>
  intent Option<String>
  satisfies List<String>
  body List<BodyItem>
  doc_comment Option<String>
  span Span

type MainDef is
  return_type Option<TypeExpr>
  can_fail Boolean
  body List<BodyItem>
  doc_comment Option<String>
  span Span

type TypeDef is
  name String
  type_params List<String>
  body TypeBody
  span Span

type ConstantDef is
  name String
  type_expr Option<TypeExpr>
  value Expr
  span Span

type ImportDecl is
  module_ String
  items List<ImportItem>
  span Span

type InvariantNetwork is
  name String
  constraints List<Expr>
  span Span

type ModuleDecl is
  name String
  narrative Option<String>
  temporal Option<List<String>>
  imports List<ImportDecl>
  types List<TypeDef>
  constants List<ConstantDef>
  invariants List<InvariantNetwork>
  body List<Declaration>
  span Span

type Declaration is
    FuncDecl(def_ FunctionDef)
  | MainDecl(def_ MainDef)
  | ModDecl(def_ ModuleDecl)

type BodyItem is
    StmtItem(stmt Stmt)
  | MatchItem(expr MatchExpr)

type Module_ is
  declarations List<Declaration>
  span Span
```

**Est.:** ~250 lines of Prove (mostly type definitions)

### 2.5 `ResolvedTypes` — Type System

**Python:** `types_.py` (185 lines)

```
module ResolvedTypes
  narrative: "Resolved type representations after checking."

type Type is
    Primitive(name String, modifiers List<String>)
  | UnitT
  | RecordT(name String, fields Map<Type>)
  | AlgebraicT(name String, variants List<VariantInfo>)
  | RefinementT(name String, base Type)
  | GenericInstanceT(base_name String, args List<Type>)
  | TypeVarT(name String)
  | FunctionT(param_types List<Type>, return_type Type)
  | ListT(element Type)
  | ErrorT

type VariantInfo is
  name String
  fields Map<Type>
```

| Function | Signature |
|----------|-----------|
| `type_name` | `transforms type_name(ty Type) String` |
| `types_compatible` | `validates types_compatible(expected Type, actual Type) Boolean` |
| `is_pointer_type` | `validates is_pointer_type(ty Type) Boolean` |

Constants: `INTEGER`, `DECIMAL`, `FLOAT`, `BOOLEAN`, `STRING`, `CHARACTER`,
`BYTE`, `UNIT_` — each a `Type` value.

**Est.:** ~120 lines of Prove

### 2.6 `Symbols` — Symbol Table

**Python:** `symbols.py` (159 lines)

```
module Symbols
  narrative: "Lexical scoping and function registry."

type SymbolKind is Variable | Parameter | Constant_ | Function_

type Symbol is
  name String
  kind SymbolKind
  type_ Type
  used Boolean
  span Span

type FunctionSignature is
  verb String
  name String
  params List<Param>
  return_type Type
  can_fail Boolean

type Scope is
  symbols Map<Symbol>
  parent Option<Scope>

type SymbolTable is
  scopes List<Scope>
  functions Map<FunctionSignature>
  types Map<Type>
```

| Function | Signature |
|----------|-----------|
| `st_new` | `transforms st_new() SymbolTable` |
| `st_push_scope` | `transforms st_push_scope(st SymbolTable) SymbolTable` |
| `st_pop_scope` | `transforms st_pop_scope(st SymbolTable) SymbolTable` |
| `st_define` | `transforms st_define(st SymbolTable, sym Symbol) SymbolTable` |
| `st_lookup` | `transforms st_lookup(st SymbolTable, name String) Option<Symbol>` |
| `st_register_function` | `transforms st_register_function(st SymbolTable, sig FunctionSignature) SymbolTable` |
| `st_lookup_function` | `transforms st_lookup_function(st SymbolTable, name String) Option<FunctionSignature>` |
| `st_register_type` | `transforms st_register_type(st SymbolTable, name String, ty Type) SymbolTable` |
| `st_lookup_type` | `transforms st_lookup_type(st SymbolTable, name String) Option<Type>` |

**Est.:** ~120 lines of Prove

### 2.7 `Lexer` — Tokenization

**Python:** `lexer.py` (656 lines) — the most algorithmically complex module.

The lexer needs character-by-character traversal, indent/dedent tracking,
string interpolation nesting, and regex-vs-division disambiguation.

| Function | Signature |
|----------|-----------|
| `lex` | `transforms lex(source SourceFile) Result<List<Token>, List<Diagnostic>>` |

Internal helpers (private to module):
- `scan_token` — main dispatch on current character
- `scan_identifier` — read word, check keyword table
- `scan_number` — integer or decimal literal
- `scan_string` — regular, triple-quoted, raw, interpolated
- `scan_regex` — regex literal after disambiguation
- `scan_path` — path literal (`p"..."`)
- `emit_indent_dedent` — compare leading spaces to indent stack
- `skip_comment` — single-line `//` comments
- `scan_doc_comment` — `///` doc comments

**Est.:** ~500 lines of Prove (similar to Python, character ops via `Chars`)

### 2.8 `Parser` — Parsing

**Python:** `parser.py` (1604 lines) — Pratt expression parser + recursive
descent for declarations.

| Function | Signature |
|----------|-----------|
| `parse` | `transforms parse(tokens List<Token>) Result<Module_, List<Diagnostic>>` |

The Pratt parser maps cleanly to Prove. The binding power table becomes a
`match` on `TokenKind`. Recursive descent for declarations uses the same
pattern: peek at current token, dispatch to specific parse function.

Key internal functions:
- `parse_expression(min_bp)` — Pratt core
- `parse_prefix` — unary, literals, identifiers, parenthesized
- `parse_infix` — binary ops, field access, call, index, pipe
- `parse_declaration` — dispatch on verb keyword
- `parse_function` — verb, name, params, return type, contracts, body
- `parse_type_def` — `type X is ...`
- `parse_module_decl` — `module X` with narrative, imports, body
- `parse_match` — `match` expression with arms
- `parse_proof` — `proof` block with obligations

**Est.:** ~1,200 lines of Prove

### 2.9 `Checker` — Semantic Analysis

**Python:** `checker.py` (1266 lines) — two-pass analyzer.

| Function | Signature |
|----------|-----------|
| `check` | `transforms check(module_ Module_, st SymbolTable) Result<SymbolTable, List<Diagnostic>>` |

Pass 1: Register all top-level declarations (types, functions, constants,
imports) into the symbol table. This allows mutual recursion.

Pass 2: Check each declaration body:
- Type inference via `match` on `Expr` variants
- Verb enforcement (pure verbs cannot call IO functions)
- Match exhaustiveness
- Unused variable detection
- Contract type checking (ensures/requires must be Boolean)

The Python `isinstance` dispatch becomes `match` on algebraic variants:

```
// Python:
if isinstance(expr, BinaryExpr):
    left_ty = self._infer(expr.left)
    ...

// Prove:
match expr
  BinaryE(left, op, right, span) =>
    left_ty as Type = infer(left, st)
    ...
```

**Est.:** ~900 lines of Prove

### 2.10 `Prover` — Proof Verification

**Python:** `prover.py` (149 lines)

| Function | Signature |
|----------|-----------|
| `verify_proof` | `transforms verify_proof(fd FunctionDef) List<Diagnostic>` |

Checks: E390, E391, E392, E393, W321, W322, W324.

**Est.:** ~120 lines of Prove

### 2.11 `CTypes` — C Type Mapping

**Python:** `c_types.py` (168 lines)

```
module CTypes
  narrative: "Map resolved types to C type representations."

type CType is
  decl String
  is_pointer Boolean
  header Option<String>
```

| Function | Signature |
|----------|-----------|
| `map_type` | `transforms map_type(ty Type) CType` |
| `mangle_name` | `transforms mangle_name(verb String, name String, params List<Type>) String` |
| `mangle_type_name` | `transforms mangle_type_name(name String) String` |

**Est.:** ~130 lines of Prove

### 2.12 `CEmitter` — C Code Generation

**Python:** `c_emitter.py` (1321 lines) — the largest module.

| Function | Signature |
|----------|-----------|
| `emit_c` | `transforms emit_c(module_ Module_, st SymbolTable) String` |

This is a large AST walker. Every `isinstance` check becomes a `match`
arm. String building uses `StringBuilder` from `Chars` module.

Key sections:
- Type definitions → C structs/unions/typedefs
- Function definitions → C functions with mangled names
- Expression emission → recursive match on all Expr variants
- Lambda hoisting → collect during emission, insert at top
- Builtin dispatch → `println`, `len`, `to_string`, etc.
- Proof branching → `when` conditions become if/else-if chains
- Retain/release → reference counting at scope boundaries

**Est.:** ~1,000 lines of Prove

### 2.13 `CCompiler` — Invoking gcc

**Python:** `c_compiler.py` (84 lines)

| Function | Signature |
|----------|-----------|
| `find_c_compiler` | `inputs find_c_compiler() String!` |
| `compile_c` | `inputs compile_c(source_path String, output_path String, compiler String, extra_sources List<String>) Result<Unit, String>` |

Uses `Sys.run` and `Fs.which`.

**Est.:** ~60 lines of Prove

### 2.14 `CRuntime` — Runtime File Copying

**Python:** `c_runtime.py` (44 lines)

| Function | Signature |
|----------|-----------|
| `copy_runtime` | `outputs copy_runtime(build_dir String)!` |

Copies bundled C runtime `.c`/`.h` files to the build directory. In the
self-hosted compiler, these files are embedded as string constants or
read from a known install path.

**Est.:** ~40 lines of Prove

### 2.15 `Testing` — Contract Test Generation

**Python:** `testing.py` (674 lines)

| Function | Signature |
|----------|-----------|
| `generate_tests` | `transforms generate_tests(module_ Module_, st SymbolTable, c_source String) String` |

Generates a standalone C test program from `ensures`, `near_miss`, and
`believe` annotations. Property-based testing with random inputs.

**Est.:** ~500 lines of Prove

### 2.16 `Config` — Project Configuration

**Python:** `config.py` (92 lines)

```
module Config
  narrative: "Load and represent prove.toml configuration."

type PackageConfig is
  name String
  version String

type BuildConfig is
  entry String
  output String

type TestConfig is
  rounds Integer

type StyleConfig is
  line_length Integer

type ProveConfig is
  package_ PackageConfig
  build BuildConfig
  test_ TestConfig
  style StyleConfig
```

| Function | Signature |
|----------|-----------|
| `find_config` | `inputs find_config(start String) Option<String>` |
| `load_config` | `inputs load_config(path String) ProveConfig!` |
| `default_config` | `transforms default_config() ProveConfig` |

Uses `Toml` and `Fs` modules.

**Est.:** ~80 lines of Prove

### 2.17 `StdlibLoader` — Stdlib Loading

**Python:** `stdlib_loader.py` (275 lines)

| Function | Signature |
|----------|-----------|
| `load_stdlib` | `inputs load_stdlib(name String) List<FunctionSignature>!` |
| `available_modules` | `transforms available_modules() List<String>` |

In the self-hosted compiler, stdlib `.prv` files are either embedded as
string constants or read from the install directory.

**Est.:** ~200 lines of Prove

### 2.18 `Builder` — Build Pipeline

**Python:** `builder.py` (208 lines)

```
module Builder
  narrative: "Orchestrate the full compilation pipeline."

type BuildResult is
  ok Boolean
  binary Option<String>
  diagnostics List<Diagnostic>
  c_error Option<String>
```

| Function | Signature |
|----------|-----------|
| `build_project` | `inputs build_project(project_dir String, config ProveConfig) BuildResult` |

Pipeline: find sources → lex → parse → check → emit C → copy runtime →
compile C → binary.

**Est.:** ~150 lines of Prove

### 2.19 `Cli` — Command Line Interface

**Python:** `cli.py` (592 lines) — uses Click framework.

The self-hosted CLI parses `Sys.args()` directly (no Click dependency).

| Function | Signature |
|----------|-----------|
| `main` | `main() Result<Unit, Error>!` |
| `cmd_build` | `inputs cmd_build(path String)!` |
| `cmd_check` | `inputs cmd_check(path String)!` |
| `cmd_test` | `inputs cmd_test(path String)!` |
| `cmd_new` | `outputs cmd_new(name String)!` |

Argument parsing is simple: `prove build [path]`, `prove check [path]`,
`prove test [path]`, `prove new <name>`.

**Est.:** ~300 lines of Prove

### Compiler Module Summary

| Module | Python lines | Prove est. | Key stdlib deps |
|--------|-------------|------------|-----------------|
| Source | 51 | 30 | — |
| Tokens | 188 | 120 | Map |
| Errors | 154 | 100 | Chars, Io |
| Ast | 437 | 250 | — |
| Lexer | 656 | 500 | Chars |
| ResolvedTypes | 185 | 120 | Map |
| Symbols | 159 | 120 | Map |
| Parser | 1,604 | 1,200 | — |
| Checker | 1,266 | 900 | Map, Set |
| Prover | 149 | 120 | Set |
| CTypes | 168 | 130 | Chars |
| CEmitter | 1,321 | 1,000 | Chars |
| CCompiler | 84 | 60 | Sys, Fs |
| CRuntime | 44 | 40 | Fs |
| Testing | 674 | 500 | Chars |
| Config | 92 | 80 | Toml, Fs |
| StdlibLoader | 275 | 200 | Fs |
| Builder | 208 | 150 | Fs |
| Cli | 592 | 300 | Sys, Io |
| **Total** | **~10,800** | **~5,920** | |

The Prove version is estimated at ~55% of the Python line count. Algebraic
types eliminate boilerplate (no `@dataclass(frozen=True)`, no `__init__`,
no type imports). Pattern matching replaces `isinstance` chains.

---

## Part 3: Implementation Phases

### Phase 1: Core Stdlib (C-backed)

Implement and test the 7 new stdlib modules.

| Deliverable | Files |
|-------------|-------|
| `prove_sys.c/h` | C runtime for Sys module |
| `prove_fs.c/h` | C runtime for Fs module |
| `prove_map.c/h` | C runtime for Map module |
| `prove_set.c/h` | C runtime for Set module |
| `prove_chars.c/h` | C runtime for Chars module |
| `prove_toml.c/h` | C runtime for Toml module |
| `prove_sort.c/h` | C runtime for Sort module |
| `stdlib/sys.prv` | Prove type signatures |
| `stdlib/fs.prv` | Prove type signatures |
| `stdlib/map.prv` | Prove type signatures |
| `stdlib/set.prv` | Prove type signatures |
| `stdlib/chars.prv` | Prove type signatures |
| `stdlib/toml.prv` | Prove type signatures |
| `stdlib/sort.prv` | Prove type signatures |
| `c_runtime.py` | Register new runtime files |
| `stdlib_loader.py` | Register new stdlib modules |
| Tests | Unit tests for each C implementation |

**Verification:** Write small `.prv` programs using each module, compile and
run them with the Python compiler.

### Phase 2: Foundation Modules (in Prove)

Write the compiler's data structure modules in Prove. These have no
circular dependencies and can be tested independently.

| Module | Depends on |
|--------|------------|
| `Source` | — |
| `Tokens` | Source, Map |
| `Errors` | Source, Chars, Io |
| `Ast` | Source, Tokens |
| `ResolvedTypes` | Map |

**Verification:** Python compiler builds each module. Write test programs
that construct AST nodes, tokens, and types.

### Phase 3: Front End (in Prove)

| Module | Depends on |
|--------|------------|
| `Lexer` | Source, Tokens, Errors, Chars |
| `Parser` | Tokens, Ast, Errors |
| `Symbols` | Ast, ResolvedTypes, Map |

**Verification:** Write a test program that lexes and parses a `.prv` file,
prints the token count and declaration count. Compare with Python compiler
output.

### Phase 4: Middle End (in Prove)

| Module | Depends on |
|--------|------------|
| `Checker` | Ast, ResolvedTypes, Symbols, Errors, Map, Set |
| `Prover` | Ast, Errors, Set |

**Verification:** Write a test program that checks a `.prv` file and reports
diagnostics. Compare with Python compiler output.

### Phase 5: Back End (in Prove)

| Module | Depends on |
|--------|------------|
| `CTypes` | ResolvedTypes, Chars |
| `CEmitter` | Ast, ResolvedTypes, Symbols, CTypes, Chars |
| `CCompiler` | Sys, Fs |
| `CRuntime` | Fs |
| `Testing` | Ast, ResolvedTypes, Symbols, CTypes, Chars |

**Verification:** Write a test program that compiles a `.prv` file to C,
then diff the C output against the Python compiler's output. They should
be identical.

### Phase 6: Pipeline (in Prove)

| Module | Depends on |
|--------|------------|
| `Config` | Toml, Fs |
| `StdlibLoader` | Fs, Ast, Symbols |
| `Builder` | all above |
| `Cli` | Builder, Sys, Io |

**Verification:** The compiled binary can `prove build examples/hello` and
produce a working `hello` binary. Compare output with Python-compiled
version.

### Phase 7: Self-Hosting

1. Compile all compiler `.prv` modules with Python compiler → binary A
2. Use binary A to compile all compiler `.prv` modules → binary B
3. Use binary B to compile all compiler `.prv` modules → binary C
4. Verify: binary B and binary C produce identical output
5. Binary B is the self-hosted compiler

### Phase 8: Cleanup

- Remove Python compiler dependency from build (keep as reference)
- Add `prove self-test` command that runs the bootstrap verification
- Update documentation
- Tag v1.0.0

---

## Part 4: What Stays in Python

Some features are not needed for self-hosting and remain Python-only
until later:

| Feature | Python module | Reason to defer |
|---------|--------------|-----------------|
| LSP server | `lsp.py` | Needs `pygls`, not critical path |
| Formatter | `formatter.py` | Nice-to-have, not needed for compilation |
| Project scaffolding | `project.py` | Simple, low priority |
| ASM backend | `asm_*.py` | C backend is sufficient for self-hosting |

These can be ported after v1.0 when the compiler is stable.

---

## Part 5: Language Features Required

The self-hosted compiler uses these Prove features. All must work
correctly in the Python bootstrap compiler before Phase 2 begins.

| Feature | Used for | Status |
|---------|----------|--------|
| Algebraic types | AST nodes, Token kinds, Types | Working |
| Record types | Span, Token, Diagnostic, Config | Working |
| Pattern matching | All dispatch (replaces isinstance) | Working |
| Generic types | `List<T>`, `Option<T>`, `Result<T,E>`, `Map<V>` | Working |
| String interpolation | Error messages, C code emission | Working |
| Lambdas | HOF callbacks (map, filter, reduce) | Working |
| Pipe operator | Builder pipeline | Working |
| Fail propagation | File I/O, process calls | Working |
| `from` body blocks | All functions | Working |
| `match` with binding | Extracting variant fields | Working |
| Nested match | Complex dispatch | Working |
| Local `as` bindings | Intermediate values | Working |
| `Option` / `Result` | Nullable returns, error handling | Working |
| `with X use` imports | Module dependencies | Working |
| `comptime` blocks | Embedded constants | Working |
| Proof blocks | Contract verification in compiler funcs | Optional |
| `when` conditions | Proof branching | Working |

---

## Risk Assessment

| Risk | Mitigation |
|------|------------|
| Bootstrap compiler bugs | Extensive test suite (458+ tests), fix bugs as found during self-hosting |
| Missing stdlib function | Add to C runtime as needed; stdlib is extensible |
| Performance regression | C backend emits reasonable code; optimize later |
| Circular module deps | Dependency graph is acyclic by design |
| Large compilation units | Each module compiles independently |
| String-heavy code gen | StringBuilder prevents O(n^2) concat |

---

## Success Criteria

1. `prove build src/` produces a native binary (the compiler)
2. That binary can compile itself: `./prove build src/` → identical binary
3. All existing examples compile and run correctly
4. `prove test` passes all contract tests
5. Error messages match Python compiler output
6. Build time < 10 seconds on modern hardware
