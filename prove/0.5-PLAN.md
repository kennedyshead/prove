# Prove v0.5 — Turbo Runtime and AST Optimizer

## Goal

Two foundational components that make the self-hosted compiler fast:

1. **Turbo runtime** — arena allocator, hardware-accelerated hash, and
   string interning. These replace `malloc`/`free` and naive string
   comparisons with structures optimized for compiler workloads.
2. **AST optimizer** — a new pipeline stage between the Prover and C
   Emitter that performs source-level optimizations on the checked AST.

**Prerequisite:** v0.4 (language features) must be complete.

---

## Part 1: Turbo Runtime

### 1.1 Arena Allocator

A bump-pointer allocator for compiler-lifetime objects. All AST nodes,
tokens, and strings are allocated from the arena and freed in one shot
when compilation finishes. Eliminates per-object `malloc`/`free` and
reference counting overhead.

```c
typedef struct {
    char *base;
    char *ptr;
    char *end;
    ProveArena *next;   // linked list of chunks
} ProveArena;
```

| Function | Signature | Description |
|----------|-----------|-------------|
| `prove_arena_new` | `ProveArena *prove_arena_new(size_t initial_size)` | Create arena (default 1 MB) |
| `prove_arena_alloc` | `void *prove_arena_alloc(ProveArena *a, size_t size, size_t align)` | Bump-allocate |
| `prove_arena_reset` | `void prove_arena_reset(ProveArena *a)` | Reset pointer (reuse memory) |
| `prove_arena_free` | `void prove_arena_free(ProveArena *a)` | Free all chunks |

**Allocation strategy:** Objects grow upward from `base`. When a chunk
fills, allocate a new one (double the size). `reset` rewinds all chunks
without freeing — useful for per-function scratch allocations.

**C file:** `prove_arena.c/h` (~80 lines)

---

### 1.2 Fast Hash

Hardware CRC32 on x86_64 (`_mm_crc32_u64`) and ARM64 (`__crc32cd`),
with a portable fallback for other architectures.

```c
uint32_t prove_hash(const char *data, size_t len);
```

| Function | Signature | Description |
|----------|-----------|-------------|
| `prove_hash` | `uint32_t prove_hash(const char *data, size_t len)` | Hash bytes |

Used by the string intern table (below) and the Table module (v0.6).

**C file:** `prove_hash.c/h` (~60 lines, including `#ifdef` dispatch)

---

### 1.3 String Intern Table

A global string deduplication table. Every string literal and identifier
is interned — stored once, compared by pointer equality. This is the
single biggest optimization for the compiler, where string comparisons
dominate (keyword lookup, symbol resolution, type name matching).

```c
typedef struct {
    const char **entries;    // interned string pointers
    uint32_t *hashes;        // precomputed hashes
    size_t count;
    size_t capacity;
    ProveArena *arena;       // strings allocated here
} ProveInternTable;
```

| Function | Signature | Description |
|----------|-----------|-------------|
| `prove_intern` | `const char *prove_intern(ProveInternTable *t, const char *s, size_t len)` | Intern a string |
| `prove_intern_table_new` | `ProveInternTable *prove_intern_table_new(ProveArena *a)` | Create table |
| `prove_intern_table_free` | `void prove_intern_table_free(ProveInternTable *t)` | Free table |

After interning, `a == b` (pointer comparison) replaces `strcmp(a, b)`.
All keyword tokens, type names, and identifiers go through `prove_intern`.

**C file:** `prove_intern.c/h` (~100 lines)

---

### Turbo Runtime Summary

| Component | Functions | C lines (est.) | Purpose |
|-----------|-----------|----------------|---------|
| Arena allocator | 4 | 80 | Bump-pointer allocation |
| Fast hash | 1 | 60 | Hardware CRC32 |
| String intern | 3 | 100 | String deduplication |
| **Total** | **8** | **~240** | |

---

## Part 2: AST Optimizer

A new pipeline stage inserted after the Prover and before the C Emitter:

```
Lexer → Parser → Checker → Prover → Optimizer → C Emitter → C Compiler
```

The optimizer operates on the checked, verified AST. It performs
source-level transformations that the C compiler cannot easily do
because they require knowledge of Prove semantics (verb purity,
immutability guarantees, algebraic type structure).

### 2.1 Tail Call Optimization (TCO)

Detect recursive calls in tail position and rewrite them as loops.
Required for recursive functions to avoid stack overflow — Prove has
no loops, so recursion is the only iteration mechanism.

```
// Before (recursive):
transforms factorial(n Integer, acc Integer) Integer
  terminates: n
from
    match n
        0 => acc
        _ => factorial(n - 1, n * acc)

// After (loop):
transforms factorial(n Integer, acc Integer) Integer
from
    loop:
        if n == 0: return acc
        acc = n * acc
        n = n - 1
```

TCO applies when:
- The recursive call is the last expression in a branch
- All arguments to the recursive call are computable before the call
- The function has `terminates` (guarantees convergence)

### 2.2 Iterator Fusion

Chain operations like `map(filter(xs, p), f)` fuse into a single pass
instead of creating intermediate lists.

```
// Before (two passes, intermediate list):
map(filter(xs, |x| x > 0), |x| x * 2)

// After (single pass):
fused_map_filter(xs, |x| x > 0, |x| x * 2)
```

### 2.3 Copy Elision

When a `transforms` function's result is immediately bound and the
source is not used again, avoid copying. Pure verbs guarantee the
source is not mutated, making this safe.

### 2.4 Match Compilation

Convert nested `match` expressions into efficient decision trees.
Avoid redundant tag checks when patterns share prefixes.

```
// Before (naive):
match shape
    Circle(r) => ...
    Square(s) => ...

// After (jump table on tag):
switch (shape.tag) {
    case TAG_Circle: ... break;
    case TAG_Square: ... break;
}
```

### 2.5 Small Function Inlining

Inline functions with a single expression body. Pure verbs guarantee
no side effects, so inlining is always safe for pure functions.

Candidates: functions where the body is a single expression (no
bindings, no match) and the function is called more than once.

### 2.6 Dead Branch Elimination

Remove match arms that the type checker has proven unreachable.
Remove `explain`-verified branches where the condition is statically
known to be true or false.

### Optimizer Summary

| Optimization | Benefit | Complexity |
|-------------|---------|------------|
| TCO | Stack safety for recursion | Medium |
| Iterator fusion | Eliminate intermediate allocations | Medium |
| Copy elision | Reduce copies for pure functions | Low |
| Match compilation | Efficient algebraic dispatch | Medium |
| Small function inlining | Eliminate call overhead | Low |
| Dead branch elimination | Remove unreachable code | Low |

**Implementation:** New Python module `optimizer.py` (~400 lines).
Operates on the existing AST — no new IR. Each optimization is a
separate pass over the AST, applied in sequence.

---

## Deliverables

| Deliverable | Description |
|-------------|-------------|
| `prove_arena.c/h` | Arena allocator |
| `prove_hash.c/h` | Hardware CRC32 hash |
| `prove_intern.c/h` | String intern table |
| `optimizer.py` | AST optimizer (TCO, fusion, elision, match, inline, dead branch) |
| `builder.py` | Updated pipeline to include optimizer stage |
| Tests | C runtime unit tests + optimizer transformation tests |

---

## Verification

**Runtime:** Write C test programs that exercise arena allocation,
hashing, and string interning. Measure performance vs `malloc`/`strcmp`.

**Optimizer:** Write `.prv` programs with known optimization
opportunities. Compile with and without optimizer, verify:
- Identical output behavior
- Reduced C code size (dead branch, inlining)
- No stack overflow on deep recursion (TCO)
