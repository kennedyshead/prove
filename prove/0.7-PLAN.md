# Prove v0.7 — IO Extensions and Parse

## Goal

Extend InputOutput with the channels the self-hosted compiler needs
(process execution, directory operations, command-line arguments) and
add the Parse module for reading `prove.toml`.

**Prerequisite:** v0.6 (core stdlib) must be complete.

---

## Modules

### 1. `InputOutput` (Extended) — Process Execution and Process State

The existing `InputOutput` module (`console`, `file`) gains `system`,
`dir`, and `process` channels plus `validates` for existence checks.

```prove
module InputOutput
  narrative: "Handles IO operations."

  type ExitCode is Integer where 0 .. 255

  type ProcessResult is
    exit_code ExitCode
    standard_output String
    standard_error String

  type DirEntry is
      File(name String, path String)
    | Directory(name String, path String)
```

| Channel | Verb | Signature | C backing | Python equivalent |
|---------|------|-----------|-----------|-------------------|
| `console` | `inputs` | `console() String` | `fgets(stdin)` | `input()` |
| `console` | `outputs` | `console(text String)` | `fputs(stdout)` | `print()` |
| `console` | `validates` | `console() Boolean` | `!feof(stdin)` | `not sys.stdin.closed` |
| `file` | `inputs` | `file(path String) String!` | `fopen`+`fread` | `open(p).read()` |
| `file` | `outputs` | `file(path String, content String)!` | `fopen`+`fwrite` | `open(p,'w').write()` |
| `file` | `validates` | `file(path String) Boolean` | `access()` | `os.path.isfile()` |
| `system` | `inputs` | `system(command String, args List<String>) ProcessResult!` | `fork+exec+waitpid` | `subprocess.run()` |
| `system` | `outputs` | `system(code ExitCode)` | `exit()` | `sys.exit()` |
| `system` | `validates` | `system(command String) Boolean` | Search `PATH` | `shutil.which()` |
| `dir` | `inputs` | `dir(path String) List<DirEntry>!` | `opendir`+`readdir` | `os.listdir()` |
| `dir` | `outputs` | `dir(path String)!` | `mkdir()` | `os.mkdir()` |
| `dir` | `validates` | `dir(path String) Boolean` | `stat()` | `os.path.isdir()` |
| `process` | `inputs` | `process() List<String>` | `argc`/`argv` | `sys.argv` |
| `process` | `validates` | `process(value String) Boolean` | `argv` contains value | `x in sys.argv` |

**C file:** Extend existing `prove_input_output.c` (~150 lines added)

---

### 2. `Parse` — Format Codecs

Needed for: reading `prove.toml` configuration. Extensible to any
structured format (JSON, YAML, etc.) with the same two-function pattern.

```prove
module Parse
  narrative: "Encoding and decoding of structured data formats."
```

| Function | Signature | C backing |
|----------|-----------|-----------|
| `toml` | `creates toml(source String) Result<T, String>` | TOML parser, maps to target type |
| `toml` | `reads toml(value T) String` | Struct to TOML text |
| `json` | `creates json(source String) Result<T, String>` | JSON parser, maps to target type |
| `json` | `reads json(value T) String` | Struct to JSON text |

**C files:** `prove_parse_toml.c` (~300 lines), `prove_parse_json.c` (~250 lines)
— each format is a separate C file, all registered under the `Parse` module.

Additional formats (YAML, CSV, etc.) follow the same pattern: add a
function named after the format with `:creates` and `:reads` verbs.

---

## Summary

| Module | Functions | C lines (est.) | Purpose |
|--------|-----------|----------------|---------|
| `InputOutput` (ext) | +14 | +150 | system, dir, process, validates |
| `Parse` | 4 | 550 | Format codecs (TOML, JSON) |
| **Total** | **18** | **~700** | |

---

## Deliverables

| Deliverable | Description |
|-------------|-------------|
| `prove_input_output.c/h` | Extend existing InputOutput runtime |
| `prove_parse_toml.c/h` | TOML codec for Parse module |
| `prove_parse_json.c/h` | JSON codec for Parse module |
| `stdlib/input_output.prv` | Extended InputOutput type signatures |
| `stdlib/parse.prv` | Parse module signatures |
| `c_runtime.py` | Register new runtime files |
| `stdlib_loader.py` | Register new stdlib modules |
| Tests | Unit tests for each C implementation |

---

## Verification

Write small `.prv` programs using each module, compile and run them
with the Python compiler. Each program exercises the module's full API.
