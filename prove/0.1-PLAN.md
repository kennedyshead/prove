# Prove v0.1 — Stricter Contract Enforcement

## Summary

Contracts are the single source of truth for tests. If you declare what a
function guarantees, you must prove why.

## Changes

### Warnings promoted to errors

| Old | New | Meaning |
|-----|-----|---------|
| W390 | **E390** | `ensures` without `proof` block |
| W320 | **E392** | proof obligations < ensures count |
| W323 | **E393** | `believe` without `ensures` |

### New warning

| Code | Meaning |
|------|---------|
| W324 | `ensures` without `requires` |

### Doc-comment test generation removed

Doc comments (`///`) remain as documentation. Test generation from
`/// add(1, 2) == 3` has been removed — contracts (`ensures`, `believe`,
`near_miss`) are the single source of truth for test generation.

### Style configuration

Added `[style]` section to `prove.toml` with `line_length = 90` default.

### Files changed

<<<<<<< Updated upstream
- `src/prove/prover.py` — promote 3 warnings to errors, add W324
- `src/prove/testing.py` — remove doc-comment test generation
- `src/prove/config.py` — add StyleConfig with line_length
- `src/prove/project.py` — add [style] to TOML template
- `tests/test_prover.py` — update 4 tests, add 2 new tests
- `tests/test_testing.py` — delete doc test, add proof blocks
- `examples/math/src/main.prv` — add proof blocks and requires
- `examples/*/prove.toml` — add [style] section
- `README.md` — created
- `CLAUDE.md` — updated diagnostic codes and structure
=======
2. **Add `readln`** — `prove_readln()` in prove_string.h/c (fgets + strip newline). Add `"readln": "prove_readln"` to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_string.h`, `src/prove/runtime/prove_string.c`, `src/prove/c_emitter.py`

3. **Fix `len` dispatch** — In `_emit_call`, check inferred arg type: String → `prove_string_len`, List → `prove_list_len`.
   - **File:** `src/prove/c_emitter.py`

4. **Fix `to_string` dispatch** — By arg type: Integer→`prove_string_from_int`, Decimal/Float→`prove_string_from_double`, Boolean→`prove_string_from_bool`, Char→`prove_string_from_char`, String→identity.
   - **File:** `src/prove/c_emitter.py`

5. **Add `clamp`** — Inline in prove_runtime.h, add to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_runtime.h`, `src/prove/c_emitter.py`

6. **Add `prove_list_free` with element destructor** — `void prove_list_free(Prove_List*, void (*)(void*))` for Phase F.
   - **Files:** `src/prove/runtime/prove_list.h`, `src/prove/runtime/prove_list.c`

7. **Tests** for each fix.
   - **Files:** `tests/test_c_emitter.py`, `tests/test_builder.py`

---

## Phase C: Contract Checking in Checker

**Goal:** `ensures`/`requires`/`know`/`assume`/`believe` are type-checked; `satisfies`/`intent` validated.

1. **Type-check `ensures`** — In `_check_function`, after body check (params in scope), push sub-scope with `result` bound to return type, infer each ensures expr, verify Boolean → E380.
2. **Type-check `requires`** — Same param scope, verify Boolean → E381.
3. **Type-check `know`/`assume`/`believe`** — Verify Boolean → E384/E385/E386.
4. **`satisfies` check** — Verify each named type exists → E382/E383.
5. **`intent` plausibility** — Warning W310 if intent set but no ensures/requires.
6. **`requires` constrains test inputs** — In testing.py, extract simple range bounds from requires and use them for random generation.
7. **Tests** for each new error code.

**Files:** `src/prove/checker.py`, `src/prove/testing.py`, `tests/test_checker.py`

---

## Phase D: Proof Verification (`prover.py`)

**Goal:** New module — structural proof checks. The language's identity feature.

Create `src/prove/prover.py` with `ProofVerifier`:
1. `ensures` without `proof` block → E390
2. Obligation names unique → E391
3. Obligations should cover ensures count → W320
4. Proof text should reference function concepts (param names, "result") → W321
5. Duplicate near-miss inputs → W322
6. `believe` without `ensures` → W323

Integrate: call from `_check_function` after body check.

`assume` → runtime assertion: in emitter, for each `assume:` expr emit `if (!(cond)) prove_panic("assumption violated");` at function entry.

**Files:** `src/prove/prover.py` (new), `src/prove/checker.py`, `src/prove/c_emitter.py`, `tests/test_prover.py` (new)

---

## Phase E: Transitive Verb Purity

**Goal:** Catch calls to user-defined IO functions from pure contexts.

1. After pass 1, collect names of all `inputs`/`outputs` verb functions → `self._io_function_names`
2. In `_check_pure_expr`, if CallExpr targets a name in `_io_function_names` → E363
3. Tests: `transforms` calling user-defined `outputs` → E363; lambda calling IO → error.

**Files:** `src/prove/checker.py`, `tests/test_checker.py`

---

## Phase F: Scope-Based Retain/Release

**Goal:** Stop heap leaks with simple RC. Retain on assignment, release at scope exit.

1. On `VarDecl` for pointer types, emit `prove_retain(var)` after assignment
2. Before each `return`, emit `prove_release(var)` for all pointer locals (skip the return value)
3. Tests: verify emitted C has retain/release; integration test with string locals

**Files:** `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase G: Higher-Order Functions + Lambda Fixes

**Goal:** `map`/`filter`/`reduce` work in generated C.

1. Create `src/prove/runtime/prove_hof.h` + `prove_hof.c` — C implementations using function pointers
2. Add to `_RUNTIME_FILES` in c_runtime.py
3. Fix lambda param types — infer from call context instead of hardcoding int64_t
4. Special-case HOF calls in emitter to pass function pointer + elem size
5. Detect closure capture → compiler error (not supported in v0.1)
6. Tests: map/filter/reduce on integer list

**Files:** `src/prove/runtime/prove_hof.h` (new), `src/prove/runtime/prove_hof.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase H: Diagnostic Quality

**Goal:** Source lines in error output, notes/suggestions on key errors.

1. **Source line display** — Add file cache to `DiagnosticRenderer`. Load source, show offending line + caret underline.
2. **Notes on key errors** — E310 (undefined name): fuzzy-match "did you mean X?". E321 (type mismatch): note with expected vs actual types. E330 (wrong arg count): show function signature.
3. Tests for rendered output.

**Files:** `src/prove/errors.py`, `src/prove/checker.py`, `tests/test_cli.py`

---

## Phase I: Stdlib Loading + Builder Fixes

**Goal:** `with io use ...` resolves to real function signatures.

1. Move `stdlib/*.prv` → `src/prove/stdlib/`, add `__init__.py`, update `pyproject.toml` package data
2. Create `src/prove/stdlib_loader.py` — `load_stdlib(name) -> list[FunctionSignature]` using importlib.resources
3. Wire into `_register_import` in checker — when module matches stdlib, register real signatures
4. Fix `project.py` LICENSE path — use package-relative path or skip
5. `prove new` also creates README.md
6. Tests: import resolution, scaffolding

**Files:** `src/prove/stdlib/*.prv` (moved), `src/prove/stdlib_loader.py` (new), `src/prove/checker.py`, `src/prove/project.py`, `pyproject.toml`, `tests/test_checker.py`, `tests/test_cli.py`

---

## Phase J: HTTP Runtime

**Goal:** Minimal real HTTP server. POSIX sockets, single-threaded, HTTP/1.0.

1. Create `src/prove/runtime/prove_http.h` + `prove_http.c`:
   - `Prove_Server` (fd + port), `Prove_Request` (method/path/body), `Prove_Response` (status + body)
   - `prove_http_new_server`, `prove_http_listen` (accept loop + minimal HTTP parse), `prove_http_ok`, `prove_http_not_found`
2. Add to `_RUNTIME_FILES`, add `#include` support in emitter
3. Update `stdlib/http.prv` signatures to match C API
4. Update `examples/http_server/` to use stdlib imports + serve on a port
5. Tests: build http_server binary (verify compilation succeeds)

**Files:** `src/prove/runtime/prove_http.h` (new), `src/prove/runtime/prove_http.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `src/prove/stdlib/http.prv`, `examples/http_server/src/main.prv`, `tests/test_builder.py`

---

## Phase K: Expanded Emitter Tests

**Goal:** Comprehensive coverage for all emitter features.

Add tests for: match → switch, algebraic constructors, record field access, list literal + index, pipe expression, fail propagation (`!`), lambda with correct types, retain/release, `assume` assertion, string interpolation edge cases.

**File:** `tests/test_c_emitter.py`

---

## Phase L: Stubs + Cleanup

1. Create `src/prove/formatter.py` — v0.1: parse + re-emit with normalized indent. Wire into `prove format`.
2. Create `src/prove/lsp.py` — Stub module with placeholder.
3. `prove view` — Parse file, dump AST as indented text.
4. Remove `check_only` dead parameter from `_compile_project`.
5. Wire `prove check` to also run proof verification.

**Files:** `src/prove/formatter.py` (new), `src/prove/lsp.py` (new), `src/prove/cli.py`

---

## Verification

After each phase: `pytest tests/ -v` (all pass), `ruff check src/ tests/` (clean).

Final:
1. `prove build examples/hello` → binary prints "Hello from Prove!"
2. `prove check examples/math` → reports proof/contract status
3. `prove test examples/math` → property tests pass
4. `prove build examples/http_server` → binary serves HTTP
5. `prove new myproject` → complete scaffold with README
6. `prove format examples/hello/src/main.prv` → runs OK

---
---

# v0.2 — Assembly Backend + AI-Resistance Phase 2

## Overview

v0.2 has two pillars: **native code generation** (direct ASM emission replacing the C backend) and **AI-Resistance Phase 2** (deeper generation resistance features from the language spec). See `0.2-PLAN.md` for full assembly backend details.

---

## Pillar 1: Assembly Backend

Current pipeline: `.prv` → AST → Checker → `CEmitter` → `.c` → gcc → binary
New pipeline: `.prv` → AST → Checker → `AsmEmitter` → `.s` → `as` + `ld` → binary

### Architecture

```
AST + SymbolTable → AsmEmitter (AST walker)
                        ↓
                    AsmCodegen (abstract interface)
                     /          \
            X86_64Codegen    ARM64Codegen
```

### Phases (see `0.2-PLAN.md` for full detail)

1. **Infrastructure + Hello World** — x86_64 backend, `--target asm-x86_64`, C runtime linked as `.o`
2. **Arithmetic + Functions + Variables** — integer ops, name mangling, stack-based locals
3. **Control Flow + Booleans** — if/else branches, comparisons, logical ops
4. **Strings + Builtins + Pipes** — string ops, interpolation, builtin dispatch, pipe desugaring
5. **Records + Algebraic Types + Match** — struct layout, tagged unions, switch emission
6. **Lists + HOF + Lambdas** — list ops, hoisted lambdas, map/filter/reduce
7. **ARM64 Backend** — full AAPCS64 ABI, cross-compile + QEMU testing
8. **Float/Decimal + Full Parity** — xmm/d registers, Option/Result, verify identical output to C backend
9. **Self-Hosted Runtime** — compiler intrinsics (`@alloc`, `@syscall`, `@ptr_read`, etc.), runtime `.prv` files, bootstrap

---

## Pillar 2: AI-Resistance Phase 2

From the language spec: *"Phase 2 targets deeper failure modes in AI code generation: the inability to reason about alternatives, uncertainty, temporal ordering, and interconnected constraints."*

### Phase M: Counterfactual Annotations

**Goal:** `why_not` / `chosen` annotations are parsed, stored, and verified.

1. Parser already handles `why_not:` and `chosen:` — verify they attach to function AST nodes
2. Checker validates: `chosen` is required if any `why_not` is present → E400
3. Checker validates: `chosen` rationale references function concepts (params, return type, verb) → W400
4. Emitter: annotations are compile-time only, no runtime cost

```prove
transforms evict(cache Cache) Option<Entry>
    why_not: "FIFO would evict still-hot entries under burst traffic"
    why_not: "Random eviction has unbounded worst-case for repeated keys"
    chosen: "LRU because access recency correlates with reuse probability"
    from
        // LRU implementation
```

**Files:** `src/prove/checker.py`, `src/prove/ast_nodes.py`, `tests/test_checker.py`

---

### Phase N: Near-Miss Testing (Enhanced)

**Goal:** `near_miss` annotations generate executable boundary tests.

1. v0.1 parses near-miss annotations — v0.2 generates actual test cases from them
2. Each `near_miss: input => expected` becomes a concrete test in `prove test`
3. Compiler verifies each near-miss exercises a distinct branch/boundary → W322 (already stubbed)
4. Redundant near-misses (same branch path) are rejected

```prove
validates leap_year(y Integer)
    near_miss: 1900 => false   // divisible by 100 but not 400
    near_miss: 2000 => true    // divisible by 400
    near_miss: 2100 => false   // the trap most people forget
    from
        y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)
```

**Files:** `src/prove/testing.py`, `src/prove/prover.py`, `tests/test_testing.py`

---

### Phase O: Epistemic Annotations (Full)

**Goal:** `know` / `assume` / `believe` have distinct compiler behaviors.

1. **`know`** — Proven by the type system. Zero runtime cost. Compiler error if not actually provable from types → E410
2. **`assume`** — Compiler inserts runtime validation at function entry (already stubbed in v0.1 Phase D). Log on violation.
3. **`believe`** — Compiler generates adversarial property tests specifically targeting this claim. If a counterexample is found, it's a compile error → E411

```prove
transforms process_order(order Order) Receipt
    know: len(order.items) > 0            // enforced by NonEmpty type — zero cost
    assume: order.total == sum(prices)    // runtime check inserted
    believe: order.user.is_verified       // aggressive tests generated to falsify
    from
        // implementation
```

**Files:** `src/prove/checker.py`, `src/prove/prover.py`, `src/prove/testing.py`, `src/prove/c_emitter.py` (or `asm_emitter.py`)

---

### Phase P: Temporal Effect Ordering

**Goal:** `temporal:` declarations enforce call ordering across function boundaries.

1. Module-level `temporal: a -> b -> c` declares required ordering
2. Checker builds call graph within module
3. Verify all execution paths respect declared ordering → E420
4. Cross-function: if `authorize` must follow `authenticate`, any path calling `access` without prior `authorize` is an error

```prove
module Auth
    temporal: authenticate -> authorize -> access

    inputs authenticate(creds Credentials) Token!
    transforms authorize(token Token, resource Resource) Permission
    inputs access(perm Permission, resource Resource) Data!
```

**Files:** `src/prove/checker.py` (call graph analysis), `src/prove/ast_nodes.py`, `tests/test_checker.py`

---

### Phase Q: Invariant Networks

**Goal:** `invariant_network` declarations with `satisfies` verification.

1. Parse `invariant_network Name` blocks with constraint expressions
2. Functions declare `satisfies NetworkName`
3. Checker verifies the function's postconditions are consistent with the network's constraints
4. Structural check: function must have `ensures` clauses that reference network variables → W430
5. Full constraint solving deferred — v0.2 does structural checks only

```prove
invariant_network AccountingRules
    total_assets == total_liabilities + equity
    revenue - expenses == net_income

transforms post_transaction(ledger Ledger, tx Transaction) Ledger
    satisfies AccountingRules
    ensures result.total_assets == result.total_liabilities + result.equity
    from
        // implementation
```

**Files:** `src/prove/ast_nodes.py`, `src/prove/checker.py`, `src/prove/prover.py`, `tests/test_prover.py`

---

### Phase R: Context-Aware Call Resolution

**Goal:** Resolve which verb-variant to call based on context.

From the spec: *"At call sites, you use just the function name — the compiler resolves which verb-variant to call."*

1. Boolean context (`if`, `&&`, `||`, `!`) → resolves to `validates` variant
2. Expected type from assignment/parameter → matches variant returning that type
3. Parameter types disambiguate between variants with same return type
4. Ambiguous → compiler error with suggestions listing available variants → E440
5. `valid` keyword: as expression forces validates call, as reference passes validates as predicate

```prove
validates email(address String)
transforms email(raw String) Email
inputs email(user_id Integer) Email!

// Boolean context → validates email
if email(input)
    clean as Email = email(raw_input)    // Email context → transforms
    stored as Email = email(user.id)     // Email context + Integer → inputs
```

**Files:** `src/prove/checker.py`, `src/prove/tokens.py` (add `valid`), `src/prove/parser.py`, `tests/test_checker.py`

---

### Phase S: Refutation Challenges

**Goal:** Compiler generates plausible-but-wrong alternatives and requires programmer to refute them.

1. For functions with `ensures`, generate simplified alternative implementations
2. Present as `challenge[C0xx]` in `prove check` output
3. Programmer adds `refute:` annotation with counterexample or argument
4. Compiler verifies refutation is valid (counterexample actually fails the alternative)

This is the most ambitious Phase 2 feature — scope it to simple arithmetic/comparison mutations initially.

**Files:** `src/prove/prover.py`, `src/prove/errors.py`, `src/prove/cli.py`

---

## Deferred to v0.3+

From the language spec, these features are not in v0.2 scope:

- **AI-Resistance Phase 3**: Binary `.prv` format, semantic normalization, source fragmentation, identity-bound compilation, anti-training license enforcement
- **Ownership / Linear Types**: `File:[Own]`, compiler-inferred borrows
- **Concurrency**: `par_map`, structured concurrency, data race prevention
- **Domain-Specific Syntax**: `domain` keyword, project-specific grammar extensions
- **Semantic Commit Messages**: Compiler verifies commit messages match code changes
- **Incremental Compilation**: Caching, dependency tracking for fast rebuilds

---

## v0.2 Verification

After all phases:
1. `prove build --target asm-x86_64 examples/hello` → binary prints "Hello from Prove!"
2. `prove build --target asm-arm64 examples/hello` → binary works (QEMU or native)
3. All examples produce identical output with both `native` and `asm-*` targets
4. `prove check` validates counterfactual, epistemic, temporal, and invariant annotations
5. `prove test` runs near-miss boundary tests alongside property tests
6. Context-aware call resolution works for multi-verb function names
7. `pytest tests/ -v` — all pass. `ruff check src/ tests/` — clean.
>>>>>>> Stashed changes
