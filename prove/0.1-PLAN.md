# Complete Prove Compiler v0.1 — All Remaining Items

## Context

The Prove compiler has phases 1-5 partially implemented (225 tests, lint clean). The core pipeline works: `.prv` → lex → parse → check → emit C → compile → binary. But several v0.1 features from `/workspace/PLAN.md` are missing or incomplete. This plan covers everything needed to reach full v0.1.

Key gaps: proof blocks are parsed but ignored, contracts aren't type-checked, the C runtime has correctness bugs (Result has no success payload, `len` on String emits wrong call, retain/release never called), verb purity only checks hardcoded builtin names, stdlib imports don't resolve, and diagnostic output lacks source lines.

---

## Phase A: Test Infrastructure

**Goal:** Shared fixtures before adding features. Zero risk.

1. Create `tests/conftest.py` — extract `needs_cc` fixture (duplicated in test_builder.py + test_testing.py) and `parse_check(source)` helper (repeated in test_testing.py, useful elsewhere)
2. Create `tests/fixtures/` with small `.prv` files: `simple_math.prv`, `algebraic.prv`, `failable.prv`, `contracts.prv`
3. Remove duplicate fixtures from test_builder.py, test_testing.py

**Files:** `tests/conftest.py` (new), `tests/fixtures/*.prv` (new), `tests/test_builder.py`, `tests/test_testing.py`

---

## Phase B: C Runtime Fixes

**Goal:** Fix correctness bugs so compiled programs work for existing features.

1. **Fix `Prove_Result` payload** — Add union: `ok_int` (int64_t), `ok_double` (double), `ok_ptr` (void*). Add typed constructors (`prove_result_ok_int`, `prove_result_ok_ptr`, `prove_result_ok_void`) and unwrappers. Update `c_emitter.py` `_emit_fail_prop` and return handling to select correct constructor based on success type. Update `testing.py` Result references.
   - **Files:** `src/prove/runtime/prove_result.h`, `src/prove/c_emitter.py`, `src/prove/testing.py`

2. **Add `readln`** — `prove_readln()` in prove_string.h/c (fgets + strip newline). Add `"readln": "prove_readln"` to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_string.h`, `src/prove/runtime/prove_string.c`, `src/prove/c_emitter.py`

3. **Fix `len` dispatch** — In `_emit_call`, check inferred arg type: String → `prove_string_len`, List → `prove_list_len`.
   - **File:** `src/prove/c_emitter.py`

4. **Fix `to_string` dispatch** — By arg type: Integer→`prove_string_from_int`, Decimal/Float→`prove_string_from_double`, Boolean→`prove_string_from_bool`, Char→`prove_string_from_char`, String→identity.
   - **File:** `src/prove/c_emitter.py`

5. **Add `clamp`** — Inline in prove_runtime.h, add to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_runtime.h`, `src/prove/c_emitter.py`

6. **Add `prove_list_free` with element destructor** — `void prove_list_free(Prove_List*, void (*)(void*))` for Phase F.
   - **Files:** `src/prove/runtime/prove_list.h`, `src/prove/runtime/prove_list.c`

7. **Tests** for each fix.
   - **Files:** `tests/test_c_emitter.py`, `tests/test_builder.py`

---

## Phase C: Contract Checking in Checker

**Goal:** `ensures`/`requires`/`know`/`assume`/`believe` are type-checked; `satisfies`/`intent` validated.

1. **Type-check `ensures`** — In `_check_function`, after body check (params in scope), push sub-scope with `result` bound to return type, infer each ensures expr, verify Boolean → E380.
2. **Type-check `requires`** — Same param scope, verify Boolean → E381.
3. **Type-check `know`/`assume`/`believe`** — Verify Boolean → E384/E385/E386.
4. **`satisfies` check** — Verify each named type exists → E382/E383.
5. **`intent` plausibility** — Warning W310 if intent set but no ensures/requires.
6. **`requires` constrains test inputs** — In testing.py, extract simple range bounds from requires and use them for random generation.
7. **Tests** for each new error code.

**Files:** `src/prove/checker.py`, `src/prove/testing.py`, `tests/test_checker.py`

---

## Phase D: Proof Verification (`prover.py`)

**Goal:** New module — structural proof checks. The language's identity feature.

Create `src/prove/prover.py` with `ProofVerifier`:
1. `ensures` without `proof` block → E390
2. Obligation names unique → E391
3. Obligations should cover ensures count → W320
4. Proof text should reference function concepts (param names, "result") → W321
5. Duplicate near-miss inputs → W322
6. `believe` without `ensures` → W323

Integrate: call from `_check_function` after body check.

`assume` → runtime assertion: in emitter, for each `assume:` expr emit `if (!(cond)) prove_panic("assumption violated");` at function entry.

**Files:** `src/prove/prover.py` (new), `src/prove/checker.py`, `src/prove/c_emitter.py`, `tests/test_prover.py` (new)

---

## Phase E: Transitive Verb Purity

**Goal:** Catch calls to user-defined IO functions from pure contexts.

1. After pass 1, collect names of all `inputs`/`outputs` verb functions → `self._io_function_names`
2. In `_check_pure_expr`, if CallExpr targets a name in `_io_function_names` → E363
3. Tests: `transforms` calling user-defined `outputs` → E363; lambda calling IO → error.

**Files:** `src/prove/checker.py`, `tests/test_checker.py`

---

## Phase F: Scope-Based Retain/Release

**Goal:** Stop heap leaks with simple RC. Retain on assignment, release at scope exit.

1. On `VarDecl` for pointer types, emit `prove_retain(var)` after assignment
2. Before each `return`, emit `prove_release(var)` for all pointer locals (skip the return value)
3. Tests: verify emitted C has retain/release; integration test with string locals

**Files:** `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase G: Higher-Order Functions + Lambda Fixes

**Goal:** `map`/`filter`/`reduce` work in generated C.

1. Create `src/prove/runtime/prove_hof.h` + `prove_hof.c` — C implementations using function pointers
2. Add to `_RUNTIME_FILES` in c_runtime.py
3. Fix lambda param types — infer from call context instead of hardcoding int64_t
4. Special-case HOF calls in emitter to pass function pointer + elem size
5. Detect closure capture → compiler error (not supported in v0.1)
6. Tests: map/filter/reduce on integer list

**Files:** `src/prove/runtime/prove_hof.h` (new), `src/prove/runtime/prove_hof.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase H: Diagnostic Quality

**Goal:** Source lines in error output, notes/suggestions on key errors.

1. **Source line display** — Add file cache to `DiagnosticRenderer`. Load source, show offending line + caret underline.
2. **Notes on key errors** — E310 (undefined name): fuzzy-match "did you mean X?". E321 (type mismatch): note with expected vs actual types. E330 (wrong arg count): show function signature.
3. Tests for rendered output.

**Files:** `src/prove/errors.py`, `src/prove/checker.py`, `tests/test_cli.py`

---

## Phase I: Stdlib Loading + Builder Fixes

**Goal:** `with io use ...` resolves to real function signatures.

1. Move `stdlib/*.prv` → `src/prove/stdlib/`, add `__init__.py`, update `pyproject.toml` package data
2. Create `src/prove/stdlib_loader.py` — `load_stdlib(name) -> list[FunctionSignature]` using importlib.resources
3. Wire into `_register_import` in checker — when module matches stdlib, register real signatures
4. Fix `project.py` LICENSE path — use package-relative path or skip
5. `prove new` also creates README.md
6. Tests: import resolution, scaffolding

**Files:** `src/prove/stdlib/*.prv` (moved), `src/prove/stdlib_loader.py` (new), `src/prove/checker.py`, `src/prove/project.py`, `pyproject.toml`, `tests/test_checker.py`, `tests/test_cli.py`

---

## Phase J: HTTP Runtime

**Goal:** Minimal real HTTP server. POSIX sockets, single-threaded, HTTP/1.0.

1. Create `src/prove/runtime/prove_http.h` + `prove_http.c`:
   - `Prove_Server` (fd + port), `Prove_Request` (method/path/body), `Prove_Response` (status + body)
   - `prove_http_new_server`, `prove_http_listen` (accept loop + minimal HTTP parse), `prove_http_ok`, `prove_http_not_found`
2. Add to `_RUNTIME_FILES`, add `#include` support in emitter
3. Update `stdlib/http.prv` signatures to match C API
4. Update `examples/http_server/` to use stdlib imports + serve on a port
5. Tests: build http_server binary (verify compilation succeeds)

**Files:** `src/prove/runtime/prove_http.h` (new), `src/prove/runtime/prove_http.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `src/prove/stdlib/http.prv`, `examples/http_server/src/main.prv`, `tests/test_builder.py`

---

## Phase K: Expanded Emitter Tests

**Goal:** Comprehensive coverage for all emitter features.

Add tests for: match → switch, algebraic constructors, record field access, list literal + index, pipe expression, fail propagation (`!`), lambda with correct types, retain/release, `assume` assertion, string interpolation edge cases.

**File:** `tests/test_c_emitter.py`

---

## Phase L: Stubs + Cleanup

1. Create `src/prove/formatter.py` — v0.1: parse + re-emit with normalized indent. Wire into `prove format`.
2. Create `src/prove/lsp.py` — Stub module with placeholder.
3. `prove view` — Parse file, dump AST as indented text.
4. Remove `check_only` dead parameter from `_compile_project`.
5. Wire `prove check` to also run proof verification.

**Files:** `src/prove/formatter.py` (new), `src/prove/lsp.py` (new), `src/prove/cli.py`

---

## Verification

After each phase: `pytest tests/ -v` (all pass), `ruff check src/ tests/` (clean).

Final:
1. `prove build examples/hello` → binary prints "Hello from Prove!"
2. `prove check examples/math` → reports proof/contract status
3. `prove test examples/math` → property tests pass
4. `prove build examples/http_server` → binary serves HTTP
5. `prove new myproject` → complete scaffold with README
6. `prove format examples/hello/src/main.prv` → runs OK
