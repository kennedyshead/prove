# Plan: Assembly Backend for Prove Compiler

## Context

The Prove compiler currently emits C source code, then invokes gcc to produce binaries. The user wants to replace this with **direct assembly emission** targeting both **x86_64** and **ARM64**, and eventually **self-host the runtime in Prove**.

Current pipeline: `.prv` → Lexer → Parser → AST → Checker → `CEmitter` → `.c` → gcc → binary
New pipeline: `.prv` → Lexer → Parser → AST → Checker → `AsmEmitter` → `.s` → `as` + `ld` → binary

## Architecture

```
AST + SymbolTable → AsmEmitter (AST walker)
                        ↓
                    AsmCodegen (abstract interface)
                     /          \
            X86_64Codegen    ARM64Codegen
```

- **`AsmEmitter`** walks the AST (parallel to `CEmitter`), calls abstract codegen methods
- **`AsmCodegen`** defines the interface: prologue/epilogue, arithmetic, comparison, branches, calls, etc.
- **`X86_64Codegen`** / **`ARM64Codegen`** emit actual instructions per platform ABI
- **Stack-based evaluation**: each expression pushes result to a stack slot or register; simple and correct before optimizing

## New Files

| File | Purpose |
|------|---------|
| `src/prove/asm_emitter.py` | Main AST walker → codegen calls (parallel to `c_emitter.py`) |
| `src/prove/asm_types.py` | Type → size/alignment/is_pointer mapping (parallel to `c_types.py`) |
| `src/prove/asm_codegen.py` | Abstract `AsmCodegen` base + `Value`/`Location` types |
| `src/prove/asm_x86_64.py` | x86_64 System V ABI backend |
| `src/prove/asm_arm64.py` | ARM64 AAPCS64 backend |
| `src/prove/asm_assembler.py` | Invoke `as` + `gcc`/`ld` (parallel to `c_compiler.py`) |
| `src/prove/asm_runtime.py` | Compile C runtime to `.o` for linking (bootstrap phase) |
| `tests/test_asm_emitter.py` | Unit tests for ASM emission |
| `tests/test_asm_builder.py` | Integration tests: `.prv` → binary → run |

## Modified Files

| File | Change |
|------|--------|
| `src/prove/builder.py` | Add ASM pipeline path alongside C pipeline |
| `src/prove/config.py` | Accept `asm-x86_64` / `asm-arm64` as target values |
| `src/prove/cli.py` | Add `--target` option to `prove build` |

## Phased Delivery

### Phase 1: Infrastructure + Hello World
**Goal**: `prove build --target asm-x86_64 examples/hello` prints "Hello from Prove!"

- Create `asm_codegen.py` with `Value`, `Location`, abstract `AsmCodegen` base
- Create `asm_x86_64.py` with function prologue/epilogue, `emit_call`, `emit_load_address`, string literal data section
- Create `asm_types.py` with basic type mapping (Integer, String, Unit)
- Create `asm_emitter.py` skeleton: emit `main()`, `StringLit`, `CallExpr` for `println`
- Create `asm_assembler.py` to invoke `as` + `gcc` for linking
- Create `asm_runtime.py` to compile C runtime `.c` → `.o` for linking
- Modify `builder.py`, `config.py`, `cli.py` for `--target` routing
- Integration test: hello world builds and runs

### Phase 2: Arithmetic + Functions + Variables
- `FunctionDef` emission with name mangling, parameter spilling to stack
- `VarDecl` with stack allocation
- Binary ops: `+`, `-`, `*`, `/`, `%` (integer)
- Unary ops: `-`, `!`
- `IdentifierExpr` load from stack
- User function calls with ABI-correct argument passing
- Test: `examples/math` builds and runs correctly

### Phase 3: Control Flow + Booleans
- `IfExpr` → conditional branches (both statement and expression forms)
- Comparison ops: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Logical ops: `&&`, `||` (short-circuit)
- `assume` assertions → panic on failure
- `BooleanLit`, `CharLit`

### Phase 4: Strings + Builtins + Pipes
- String operations: concat, equality, interpolation
- `to_string` dispatch per type
- `len` dispatch (string vs list)
- `readln`, `print`, `clamp` builtins
- Pipe expression desugaring: `a |> f |> g` → `g(f(a))`
- Retain/release for pointer-type locals

### Phase 5: Records + Algebraic Types + Match
- `struct_layout()` for field offset computation
- Record field access (`emit_load_field`)
- Algebraic type tag+union layout, constructor functions
- `MatchExpr` → tag switch with variant field binding
- Test: `examples/http_server` builds and runs

### Phase 6: Lists + HOF + Lambdas
- List literal creation via `prove_list_new` + `prove_list_push`
- List indexing via `prove_list_get` with type cast
- Lambda hoisting as static functions
- map/filter/reduce calls with function pointers
- `FailPropExpr` (`?` operator) with Result checking

### Phase 7: ARM64 Backend
- Implement `ARM64Codegen` with full AAPCS64 ABI
- `stp`/`ldp` for prologue/epilogue, `bl` for calls, `cset` for comparisons
- Cross-assemble with `aarch64-linux-gnu-as` / `aarch64-linux-gnu-gcc`
- Test with QEMU user-mode if not on ARM64 hardware

### Phase 8: Float/Decimal + Option + Full Parity
- Float operations using `xmm`/`d` registers
- `Option<T>` monomorphized struct layout
- `Result<T,E>` full support
- Decimal type handling
- Verify all existing examples produce identical output to C backend

### Phase 9: Self-Hosted Runtime (long-term)
- Add compiler intrinsics: `@alloc`, `@dealloc`, `@memcpy`, `@syscall`, `@ptr_read`, `@ptr_write`, `@sizeof`
- Write `prove_string.prv` using intrinsics (replaces `prove_string.c`)
- Write `prove_list.prv`, `prove_result.prv`, `prove_hof.prv`
- Bootstrap: compile runtime `.prv` → `.s` → `.o`, then link with user code
- C runtime remains as fallback

## Key Design Decisions

- **Stack-based codegen** (no register allocator): simpler, correct-by-construction. Peephole optimization (keep top-of-stack in rax/x0) added later.
- **C runtime as bootstrap**: compiled to `.o` and linked with ASM output until Phase 9.
- **Same name mangling** as C backend: ensures ABI compatibility with C runtime functions.
- **Both backends coexist**: `--target native` (default) uses C, `--target asm-x86_64` / `asm-arm64` uses ASM. Existing tests unaffected.

## Verification

After each phase:
1. Run `python -m pytest tests/test_asm_emitter.py -v` for unit tests
2. Run `python -m pytest tests/test_asm_builder.py -v` for integration tests
3. Build each example with both `native` and `asm-x86_64` targets, compare stdout
4. Run `ruff check src/ tests/` and `mypy src/` for code quality
