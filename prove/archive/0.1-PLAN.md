# Prove v0.1 — Stricter Contract Enforcement

## Summary

Contracts are the single source of truth for tests. If you declare what a
function guarantees, you must prove why.

## Changes

### Warnings promoted to errors

| Old | New | Meaning |
|-----|-----|---------|
| W390 | **E390** | `ensures` without `proof` block |
| W320 | **E392** | proof obligations < ensures count |
| W323 | **E393** | `believe` without `ensures` |

### New warning

| Code | Meaning |
|------|---------|
| W324 | `ensures` without `requires` |

### Doc-comment test generation removed

Doc comments (`///`) remain as documentation. Test generation from
`/// add(1, 2) == 3` has been removed — contracts (`ensures`, `believe`,
`near_miss`) are the single source of truth for test generation.

### Style configuration

Added `[style]` section to `prove.toml` with `line_length = 90` default.

### Files changed

- `src/prove/prover.py` — promote 3 warnings to errors, add W324
- `src/prove/testing.py` — remove doc-comment test generation
- `src/prove/config.py` — add StyleConfig with line_length
- `src/prove/project.py` — add [style] to TOML template
- `tests/test_prover.py` — update 4 tests, add 2 new tests
- `tests/test_testing.py` — delete doc test, add proof blocks
- `examples/math/src/main.prv` — add proof blocks and requires
- `examples/*/prove.toml` — add [style] section
- `README.md` — created
- `CLAUDE.md` — updated diagnostic codes and structure

---

## Phase B: Runtime Builtins + Emitter Fixes

1. **Add `readln`** — `prove_readln()` in prove_string.h/c (fgets + strip newline). Add `"readln": "prove_readln"` to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_string.h`, `src/prove/runtime/prove_string.c`, `src/prove/c_emitter.py`

2. **Fix `len` dispatch** — In `_emit_call`, check inferred arg type: String → `prove_string_len`, List → `prove_list_len`.
   - **File:** `src/prove/c_emitter.py`

3. **Fix `to_string` dispatch** — By arg type: Integer→`prove_string_from_int`, Decimal/Float→`prove_string_from_double`, Boolean→`prove_string_from_bool`, Char→`prove_string_from_char`, String→identity.
   - **File:** `src/prove/c_emitter.py`

4. **Add `clamp`** — Inline in prove_runtime.h, add to `_BUILTIN_MAP`.
   - **Files:** `src/prove/runtime/prove_runtime.h`, `src/prove/c_emitter.py`

5. **Add `prove_list_free` with element destructor** — `void prove_list_free(Prove_List*, void (*)(void*))` for Phase F.
   - **Files:** `src/prove/runtime/prove_list.h`, `src/prove/runtime/prove_list.c`

6. **Tests** for each fix.
   - **Files:** `tests/test_c_emitter.py`, `tests/test_builder.py`

---

## Phase C: Contract Checking in Checker

**Goal:** `ensures`/`requires`/`know`/`assume`/`believe` are type-checked; `satisfies`/`intent` validated.

1. **Type-check `ensures`** — In `_check_function`, after body check (params in scope), push sub-scope with `result` bound to return type, infer each ensures expr, verify Boolean → E380.
2. **Type-check `requires`** — Same param scope, verify Boolean → E381.
3. **Type-check `know`/`assume`/`believe`** — Verify Boolean → E384/E385/E386.
4. **`satisfies` check** — Verify each named type exists → E382/E383.
5. **`intent` plausibility** — Warning W310 if intent set but no ensures/requires.
6. **`requires` constrains test inputs** — In testing.py, extract simple range bounds from requires and use them for random generation.
7. **Tests** for each new error code.

**Files:** `src/prove/checker.py`, `src/prove/testing.py`, `tests/test_checker.py`

---

## Phase D: Proof Verification (`prover.py`)

**Goal:** New module — structural proof checks. The language's identity feature.

Create `src/prove/prover.py` with `ProofVerifier`:
1. `ensures` without `proof` block → E390
2. Obligation names unique → E391
3. Obligations should cover ensures count → W320
4. Proof text should reference function concepts (param names, "result") → W321
5. Duplicate near-miss inputs → W322
6. `believe` without `ensures` → W323

Integrate: call from `_check_function` after body check.

`assume` → runtime assertion: in emitter, for each `assume:` expr emit `if (!(cond)) prove_panic("assumption violated");` at function entry.

**Files:** `src/prove/prover.py` (new), `src/prove/checker.py`, `src/prove/c_emitter.py`, `tests/test_prover.py` (new)

---

## Phase E: Transitive Verb Purity

**Goal:** Catch calls to user-defined IO functions from pure contexts.

1. After pass 1, collect names of all `inputs`/`outputs` verb functions → `self._io_function_names`
2. In `_check_pure_expr`, if CallExpr targets a name in `_io_function_names` → E363
3. Tests: `transforms` calling user-defined `outputs` → E363; lambda calling IO → error.

**Files:** `src/prove/checker.py`, `tests/test_checker.py`

---

## Phase F: Scope-Based Retain/Release

**Goal:** Stop heap leaks with simple RC. Retain on assignment, release at scope exit.

1. On `VarDecl` for pointer types, emit `prove_retain(var)` after assignment
2. Before each `return`, emit `prove_release(var)` for all pointer locals (skip the return value)
3. Tests: verify emitted C has retain/release; integration test with string locals

**Files:** `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase G: Higher-Order Functions + Lambda Fixes

**Goal:** `map`/`filter`/`reduce` work in generated C.

1. Create `src/prove/runtime/prove_hof.h` + `prove_hof.c` — C implementations using function pointers
2. Add to `_RUNTIME_FILES` in c_runtime.py
3. Fix lambda param types — infer from call context instead of hardcoding int64_t
4. Special-case HOF calls in emitter to pass function pointer + elem size
5. Detect closure capture → compiler error (not supported in v0.1)
6. Tests: map/filter/reduce on integer list

**Files:** `src/prove/runtime/prove_hof.h` (new), `src/prove/runtime/prove_hof.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `tests/test_c_emitter.py`

---

## Phase H: Diagnostic Quality

**Goal:** Source lines in error output, notes/suggestions on key errors.

1. **Source line display** — Add file cache to `DiagnosticRenderer`. Load source, show offending line + caret underline.
2. **Notes on key errors** — E310 (undefined name): fuzzy-match "did you mean X?". E321 (type mismatch): note with expected vs actual types. E330 (wrong arg count): show function signature.
3. Tests for rendered output.

**Files:** `src/prove/errors.py`, `src/prove/checker.py`, `tests/test_cli.py`

---

## Phase I: Stdlib Loading + Builder Fixes

**Goal:** `with io use ...` resolves to real function signatures.

1. Move `stdlib/*.prv` → `src/prove/stdlib/`, add `__init__.py`, update `pyproject.toml` package data
2. Create `src/prove/stdlib_loader.py` — `load_stdlib(name) -> list[FunctionSignature]` using importlib.resources
3. Wire into `_register_import` in checker — when module matches stdlib, register real signatures
4. Fix `project.py` LICENSE path — use package-relative path or skip
5. `prove new` also creates README.md
6. Tests: import resolution, scaffolding

**Files:** `src/prove/stdlib/*.prv` (moved), `src/prove/stdlib_loader.py` (new), `src/prove/checker.py`, `src/prove/project.py`, `pyproject.toml`, `tests/test_checker.py`, `tests/test_cli.py`

---

## Phase J: HTTP Runtime

**Goal:** Minimal real HTTP server. POSIX sockets, single-threaded, HTTP/1.0.

1. Create `src/prove/runtime/prove_http.h` + `prove_http.c`:
   - `Prove_Server` (fd + port), `Prove_Request` (method/path/body), `Prove_Response` (status + body)
   - `prove_http_new_server`, `prove_http_listen` (accept loop + minimal HTTP parse), `prove_http_ok`, `prove_http_not_found`
2. Add to `_RUNTIME_FILES`, add `#include` support in emitter
3. Update `stdlib/http.prv` signatures to match C API
4. Update `examples/http_server/` to use stdlib imports + serve on a port
5. Tests: build http_server binary (verify compilation succeeds)

**Files:** `src/prove/runtime/prove_http.h` (new), `src/prove/runtime/prove_http.c` (new), `src/prove/c_runtime.py`, `src/prove/c_emitter.py`, `src/prove/stdlib/http.prv`, `examples/http_server/src/main.prv`, `tests/test_builder.py`

---

## Phase K: Expanded Emitter Tests

**Goal:** Comprehensive coverage for all emitter features.

Add tests for: match → switch, algebraic constructors, record field access, list literal + index, pipe expression, fail propagation (`!`), lambda with correct types, retain/release, `assume` assertion, string interpolation edge cases.

**File:** `tests/test_c_emitter.py`

---

## Phase L: Stubs + Cleanup

1. Create `src/prove/formatter.py` — v0.1: parse + re-emit with normalized indent. Wire into `prove format`.
2. Create `src/prove/lsp.py` — Stub module with placeholder.
3. `prove view` — Parse file, dump AST as indented text.
4. Remove `check_only` dead parameter from `_compile_project`.
5. Wire `prove check` to also run proof verification.

**Files:** `src/prove/formatter.py` (new), `src/prove/lsp.py` (new), `src/prove/cli.py`

---

## Verification

After each phase: `pytest tests/ -v` (all pass), `ruff check src/ tests/` (clean).

Final:
1. `prove build examples/hello` → binary prints "Hello from Prove!"
2. `prove check examples/math` → reports proof/contract status
3. `prove test examples/math` → property tests pass
4. `prove build examples/http_server` → binary serves HTTP
5. `prove new myproject` → complete scaffold with README
6. `prove format examples/hello/src/main.prv` → runs OK
